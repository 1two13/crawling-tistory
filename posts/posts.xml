<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>희스토리</title>
    <link>https://1two13.tistory.com/</link>
    <description>주니어 FE 개발자입니다.
지식 공유하는 것을 좋아합니다 :)</description>
    <language>ko</language>
    <pubDate>Tue, 10 Dec 2024 09:45:40 +0900</pubDate>
    <generator>TISTORY</generator>
    <ttl>100</ttl>
    <managingEditor>1two13</managingEditor>
    <image>
      <title>희스토리</title>
      <url>https://tistory1.daumcdn.net/tistory/5849058/attach/3893385da4084beab426de0a25069d0d</url>
      <link>https://1two13.tistory.com</link>
    </image>
    <item>
      <title>FE 디자인 패턴_(1)</title>
      <link>https://1two13.tistory.com/entry/FE-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B41</link>
      <description>&lt;div style=&quot;padding: 15px 20px; background-color: #f4f4f4; border-radius: 0px 0px; border: 1px solid #d9d9d9; line-height: 1.8;&quot;&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;&lt;b&gt;목차&lt;/b&gt;&lt;/p&gt;
&lt;ol id=&quot;toc&quot; style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;&lt;/ol&gt;
&lt;script type=&quot;text/javascript&quot;&gt; $(function(){  $(&quot;#toc&quot;).toc({content: &quot;.tt_article_useless_p_margin&quot;, headings: &quot;h3&quot;}); });&lt;/script&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;/div&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;디자인 패턴이란?&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;소프트웨어를 개발하는 과정의 반복되는 일반적인 문제들에 대해 기준이 되는 해결책 제공&lt;/li&gt;
&lt;li&gt;반복되는 문제 상황들을 최적화된 방법으로 해결하도록 돕는 컨셉&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Singleton 패턴&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;span style=&quot;background-color: #f6e199;&quot;&gt;앱 전체&lt;/span&gt;에서 공유 및 사용되는&amp;nbsp;&lt;span style=&quot;background-color: #f6e199;&quot;&gt;단일&lt;/span&gt; 인스턴스&lt;/li&gt;
&lt;li&gt;즉, 싱글톤 패턴은 인스턴스를 1번만 만들 수 있어야 한다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;클래스로 예시를 작성해보면 변수를 생성하여 생성자에서 변수가 생성된 인스턴스를 가리키도록 하면 된다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1722557690303&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;let instance
let counter = 0

class Counter {
  constructor() {
    if (instance) {
      throw new Error('You can only create one instance!')
    }
    instance = this
  }

  getInstance() {
    return this
  }

  getCount() {
    return counter
  }

  increment() {
    return ++counter
  }

  decrement() {
    return --counter
  }
}

const singletonCounter = Object.freeze(new Counter())
export default singletonCounter&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;장점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;메모리 공간 절약&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;단점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;JS에서는 객체 리터럴을 사용해 동일한 구현을 할 수 있기에 굳이..?&lt;/li&gt;
&lt;li&gt;모든 테스트는 이전 테스트에서 만들어진 전역 인스턴스를 수정해야하기 때문에 테스트의 어려움&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React의 상태 관리&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Redux, Context를 사용&lt;/li&gt;
&lt;li&gt;싱글톤은 인스턴스의 값을 직접 수정할 수 있지만, 위의 도구는 읽기 전용 상태를 제거&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Svelte의 상태 관리&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;내장된 store 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Proxy 패턴&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;대상 객체에 대하여 &lt;span style=&quot;background-color: #f6e199;&quot;&gt;읽기 및 쓰기 직접 제어&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;대상 객체를 직접 다루지 않고 proxy 객체와 인터렉션&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722561715768&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;const person = {
  name: 'John Doe',
  age: 42,
  nationality: 'American',
}

const personProxy = new Proxy(person, {
  get: (obj, prop) =&amp;gt; {
    console.log(`The value of ${prop} is ${obj[prop]}`)
  },
  set: (obj, prop, value) =&amp;gt; {
    console.log(`Changed ${prop} from ${obj[prop]} to ${value}`)
    obj[prop] = value
  },
})&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;장점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;유효성 검사, 포메팅, 알림, 디버깅 구현 시 유용&lt;/li&gt;
&lt;li&gt;JS에서 제공되는 빌트인 객체 중 하나인 &lt;span style=&quot;background-color: #f6e199;&quot;&gt;Reflect&lt;/span&gt;를 사용하면 대상 객체 쉽게 조작 가능&lt;/li&gt;
&lt;li&gt;객체의 동작 커스터마이징 가능 (다양한 메서드 존재) &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MDN 참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722562841487&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;const personProxy = new Proxy(person, {
  get: (obj, prop) =&amp;gt; {
    console.log(Reflect.get(obj, prop))
  },
  set: (obj, prop, value) =&amp;gt; {
    console.log(Reflect.set(obj, prop, value)) // boolean
  },
})&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;단점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;2번째 인자로 전달하는 핸들러 객체를 너무 헤비하게 사용하면 앱 성능에 좋지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Provider 패턴&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;여러 자식 컴포넌트 간에 데이터 공유&lt;/li&gt;
&lt;li&gt;각 레이어에 직접 데이터를 주지 않고,&amp;nbsp;컴포넌트가 직접 데이터에 접근하는 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;장점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;data를 필요로 하지 않는 컴포넌트는 prop을 받지 않음&lt;/li&gt;
&lt;li&gt;props drilling 제거&lt;/li&gt;
&lt;li&gt;보통 UI 테마를 여러 컴포넌트가 공유하기 위해 사용&lt;/li&gt;
&lt;li&gt;styled-components를 사용하는 경우 제공되는 ThemeProvider 사용하여 해당 Provider 값에 접근 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;단점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;컨텍스트를 참조하는 모든 컴포넌트는 컨텍스트 변경시 모두 리렌더링되기 때문에 성능 이슈 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React의 상태 관리&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;모든 컴포넌트를 Provider(고차함수(HOC)로 Context 객체 제공)로 감싸고 createContext 메서드를 사용하여 Context 객체 생성&lt;/li&gt;
&lt;li&gt;각 컴포넌트는 useContext 훅을 사용하여 data에 접근 및 함수 호출 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722563542804&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;export const ThemeContext = React.createContext()

const themes = {
  light: {
    background: '#fff',
    color: '#000',
  },
  dark: {
    background: '#171717',
    color: '#fff',
  },
}

export default function App() {
  const [theme, setTheme] = useState('dark')

  function toggleTheme() {
    setTheme(theme === 'light' ? 'dark' : 'light')
  }

  const providerValue = {
    theme: themes[theme],
    toggleTheme,
  }

  return (
    &amp;lt;div className={`App theme-${theme}`}&amp;gt;
      &amp;lt;ThemeContext.Provider value={providerValue}&amp;gt;
        &amp;lt;Toggle /&amp;gt;
        &amp;lt;List /&amp;gt;
      &amp;lt;/ThemeContext.Provider&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre id=&quot;code_1722564145165&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;// Toggle 컴포넌트
import React, { useContext } from 'react'
import { ThemeContext } from './App'

export default function Toggle() {
  const theme = useContext(ThemeContext)

  return (
    &amp;lt;label className=&quot;switch&quot;&amp;gt;
      &amp;lt;input type=&quot;checkbox&quot; onClick={theme.toggleTheme} /&amp;gt;
      &amp;lt;span className=&quot;slider round&quot; /&amp;gt;
    &amp;lt;/label&amp;gt;
  )
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Svelte의 상태 관리&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;부모 컴포넌트에서 setContext를 사용하여 값을 설정하고, 자식 컴포넌트에서 getContext를 사용하여 값을 가져오기&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722565231341&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  import { setContext } from 'svelte';
  
  const value = { user: 'John Doe' };
  
  setContext('userContext', value);
&amp;lt;/script&amp;gt;

&amp;lt;Child /&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre id=&quot;code_1722565259041&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  import { getContext } from 'svelte';
  
  const { user } = getContext('userContext');
&amp;lt;/script&amp;gt;

&amp;lt;p&amp;gt;User: {user}&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;writable 스토어 사용하기&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722565284739&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;import { writable } from 'svelte/store';

export const userStore = writable('John Doe');&lt;/code&gt;&lt;/pre&gt;
&lt;pre id=&quot;code_1722565326967&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  import { userStore } from './store.js';
  
  $userStore = 'Jane Doe';
&amp;lt;/script&amp;gt;

&amp;lt;Child /&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre id=&quot;code_1722565345543&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  import { userStore } from './store.js';
  
  let user;
  $: user = $userStore;
&amp;lt;/script&amp;gt;

&amp;lt;p&amp;gt;User: {user}&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Prototype 패턴&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;span style=&quot;background-color: #f6e199;&quot;&gt;동일 타입의 여러 객체&lt;/span&gt;들이 &lt;span style=&quot;background-color: #f6e199;&quot;&gt;프로퍼티&lt;/span&gt; 공유&lt;/li&gt;
&lt;li&gt;JS 객체의 기본 속성인 Prototype 사용 (prototype chain 가능)&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;모든 프로퍼티는 클래스 자체에 선언되고 prototype 또는 __proto__를 사용하여 prototype 객체 확인이 가능하다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1722565618983&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;class Dog {
  constructor(name) {
    this.name = name
  }

  bark() {
    return `Woof!`
  }
}

const dog1 = new Dog('Daisy')

console.log(Dog.prototype) // constructor: &amp;fnof; Dog(name, breed) bark: &amp;fnof; bark()
console.log(dog1.__proto__) // constructor: &amp;fnof; Dog(name, breed) bark: &amp;fnof; bark()&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Object.create 메서드를 사용해서 프로토타입으로 쓰일 객체를 인자로 받아 새로운 객체를 생성할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1722566267851&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;const dog = {
  bark() {
    return `Woof!`
  },
}

const pet1 = Object.create(dog)&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;장점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;메서드 중복을 줄일 수 있음&lt;/li&gt;
&lt;li&gt;인스턴스를 만든 뒤에도 prototype에 프로퍼티 추가 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722566096704&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;Dog.prototype.play&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;단점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;프로토타입 체인이 깊어지면 코드 추적, 디버깅 어려움&lt;/li&gt;
&lt;li&gt;프로토타입을 변경하면 모든 인스턴스에 영향을 줌&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Container/Presentational 패턴&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;비즈니스 로직으로부터 뷰를 분리하여 관심사 분리 강제
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;Presentational Components: 뷰 로직&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;Container Components: 비즈니스 로직&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;장점&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;Presentational 컴포넌트는 데이터 변경 없이 화면에 출력하기 때문에 재사용 가능&lt;/span&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;Presentational 컴포넌트는 테스트 용이 (일반적으로 순수함수로 구현되기 때문에 요구하는 데이터만 인자로 넘겨 테스트)&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;단점&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;너무 작은 규모의 앱에서는 오버엔지니어링&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React의 상태 관리&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;비즈니스 로직을 커스텀 훅으로 생성하여 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722567077040&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;export default function useDogImages() {
  const [dogs, setDogs] = useState([])

  useEffect(() =&amp;gt; {
    fetch('https://dog.ceo/api/breed/labrador/images/random/6')
      .then(res =&amp;gt; res.json())
      .then(({ message }) =&amp;gt; setDogs(message))
  }, [])

  return dogs
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;svelte의 상태 관리&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;svelte에서는 .svelte 파일 하나에 HTML, CSS, JS가 모두 포함되는 구조이기 때문에 관심사 분리를 React처럼 하는 것은 오히려 비효율적이라는 생각이 든다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Observer 패턴&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Observer를 활용해 Observer에게 이벤트 발생을 알림&lt;/li&gt;
&lt;li&gt;이벤트가 발생할 때마다 Observable은 모든 Observer에게 이벤트 전파&amp;nbsp;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Observer: 구독하는 주체(받은 데이터 처리)&lt;/li&gt;
&lt;li&gt;Observable: 구독 가능한 주체(이벤트 모니터링)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;observable 객체의 주요 특징
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;observers: 이벤트가 발생할 때마다 전파할 observer들의 배열&lt;/li&gt;
&lt;li&gt;subscribe(): Observer를 Observer 배열에 추가&lt;/li&gt;
&lt;li&gt;unsubscribe(): Observer 배열에서 Observer 제거&lt;/li&gt;
&lt;li&gt;notify(): 등록된 모든 Observer들에게 이벤트 전파&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722572861557&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;class Observable {
  constructor() {
    this.observers = []
  }

  subscribe(func) {
    this.observers.push(func)
  }

  unsubscribe(func) {
    this.observers = this.observers.filter(observer =&amp;gt; observer !== func)
  }

  notify(data) {
    this.observers.forEach(observer =&amp;gt; observer(data))
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;a href=&quot;https://rxjs.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RxJS&lt;/a&gt; 오픈소스 라이브러리를 사용하면 Observable과 Observer를 만들 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1722573293201&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
import { fromEvent, merge } from &quot;rxjs&quot;;
import { sample, mapTo } from &quot;rxjs/operators&quot;;

import &quot;./styles.css&quot;;

merge(
  fromEvent(document, &quot;mousedown&quot;).pipe(mapTo(false)),
  fromEvent(document, &quot;mousemove&quot;).pipe(mapTo(true))
)
  .pipe(sample(fromEvent(document, &quot;mouseup&quot;)))
  .subscribe(isDragging =&amp;gt; {
    console.log(&quot;Were you dragging?&quot;, isDragging);
  });

ReactDOM.render(
  &amp;lt;div className=&quot;App&quot;&amp;gt;Click or drag anywhere and check the console!&amp;lt;/div&amp;gt;,
  document.getElementById(&quot;root&quot;)
);&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;장점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;비동기 호출, 이벤트 기반 데이터 처리 시 유용&lt;/li&gt;
&lt;li&gt;Observer 객체는 Observable 객체와 언제든지 분리 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;단점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Observer가 복잡해지면 모든 Observer들에 알림 전파 시 성능 이슈 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Module 패턴&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;코드를 재사용 가능하면서도 작게 나누기&lt;/li&gt;
&lt;li&gt;import, export하여 재사용&lt;/li&gt;
&lt;li&gt;Dynamic import를 사용하여 특정 조건에서 특정 모듈을 로드할 수 있다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722574701879&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;import('module').then(module =&amp;gt; {
  module.default()
  module.namedExport()
})

// Or with async/await
(async () =&amp;gt; {
  const module = await import('module')
  module.default()
  module.namedExport()
})()&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;장점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;코드의 일부분 캡슐화 가능&lt;/li&gt;
&lt;li&gt;의도치 않은 전역 변수 할당 예방&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Mixin 패턴&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;상속 없이 객체나 클래스에 기능 추가&lt;/li&gt;
&lt;li&gt;단독으로 사용 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722576765217&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;class Dog {
  constructor(name) {
    this.name = name
  }
}

const dogFunctionality = {
  bark: () =&amp;gt; console.log('Woof!'),
  wagTail: () =&amp;gt; console.log('Wagging my tail!'),
  play: () =&amp;gt; console.log('Playing!'),
}

Object.assign(Dog.prototype, dogFunctionality)&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;단점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;복잡도 증가&lt;/li&gt;
&lt;li&gt;재사용 어려움&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React의 상태 관리&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;훅으로 대체됨&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Svelte의 상태 관리&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;믹스인 객체를 가지고 와 컴포넌트의 메소드로 추가하여 필요할 때마다 재사용&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722820571398&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;// src/dogFunctionality.js
export const dogFunctionality = {
  bark() {
    console.log('Woof!');
  },
  wagTail() {
    console.log('Wagging my tail!');
  },
  play() {
    console.log('Playing!');
  },
};

&amp;lt;!-- src/DogComponent.svelte --&amp;gt;
&amp;lt;script&amp;gt;
  import { dogFunctionality } from './dogFunctionality.js';

  // 믹스인 기능을 현재 컴포넌트의 메소드로 추가
  Object.assign(this, dogFunctionality);

  let name = 'Buddy';

  onMount(() =&amp;gt; {
    console.log(`${name} is ready!`);
  });
&amp;lt;/script&amp;gt;

&amp;lt;h1&amp;gt;{name}&amp;lt;/h1&amp;gt;
&amp;lt;button on:click={() =&amp;gt; bark()}&amp;gt;Bark&amp;lt;/button&amp;gt;
&amp;lt;button on:click={() =&amp;gt; wagTail()}&amp;gt;Wag Tail&amp;lt;/button&amp;gt;
&amp;lt;button on:click={() =&amp;gt; play()}&amp;gt;Play&amp;lt;/button&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Command 패턴&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;특정 작업을 실행하는 개체와 메서드를 호출하는 개체 분리&lt;/li&gt;
&lt;li&gt;class 함수 내에서 모든 메서드를 구현하지 않고, execute라는 하나의 메서드만 가지도록 하기&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1722821652990&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;class OrderManager {
  constructor() {
    this.orders = []
  }

  execute(command, ...args) {
    return command.execute(this.orders, ...args)
  }
}

class Command {
  constructor(execute) {
    this.execute = execute
  }
}

function PlaceOrderCommand(order, id) {
  return new Command(orders =&amp;gt; {
    orders.push(id)
    return `You have successfully ordered ${order} (${id})`
  })
}

function CancelOrderCommand(id) {
  return new Command(orders =&amp;gt; {
    orders = orders.filter(order =&amp;gt; order.id !== id)
    return `You have canceled your order ${id}`
  })
}

function TrackOrderCommand(id) {
  return new Command(() =&amp;gt; `Your order ${id} will arrive in 20 minutes.`)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;=&amp;gt; OrderManager가 메서드를 직접 갖지 않고, execute라는 메서드를 통해 분리된 함수를 사용&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;장점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;객체와 메서드 분리&lt;/li&gt;
&lt;li&gt;(수명이 지정된 명령, 명령을 큐에 담아 특정한 시간대에 처리 가능)&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;단점&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;커맨드 패턴을 쓸만한 상황이 많지 않아 불필요한 코드 생성되는 이슈&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://patterns-dev-kr.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&amp;nbsp;noreferrer&quot;&gt;https://patterns-dev-kr.github.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/164</guid>
      <comments>https://1two13.tistory.com/entry/FE-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B41#entry164comment</comments>
      <pubDate>Sun, 4 Aug 2024 13:46:23 +0900</pubDate>
    </item>
    <item>
      <title>i18n을 사용하여 다국어 처리 하기</title>
      <link>https://1two13.tistory.com/entry/i18n%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EB%8B%A4%EA%B5%AD%EC%96%B4-%EC%B2%98%EB%A6%AC-%ED%95%98%EA%B8%B0</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;다국어 처리를 위해 먼저 파일을 생성했다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;src/lib/i18n&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;131&quot; data-origin-height=&quot;80&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/dk8r9b/btsIcDWGGeY/JBRTdlTyzoV4Knnt3DXIX1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/dk8r9b/btsIcDWGGeY/JBRTdlTyzoV4Knnt3DXIX1/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/dk8r9b/btsIcDWGGeY/JBRTdlTyzoV4Knnt3DXIX1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdk8r9b%2FbtsIcDWGGeY%2FJBRTdlTyzoV4Knnt3DXIX1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; data-origin-width=&quot;131&quot; data-origin-height=&quot;80&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;svelte를 사용하고 있기 때문에 svelte-18n 공식문서를 채택했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;각각의 json 파일에는 언어를 작성해두었다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1719405474612&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;// en-US.json
{
  &quot;common&quot;: {
    &quot;cancel&quot;: &quot;Cancel&quot;,
    &quot;close&quot;: &quot;Close&quot;,
    &quot;delete&quot;: &quot;Delete&quot;
  },
 }
 
 // ko-KR.json
 {
  &quot;common&quot;: {
    &quot;cancel&quot;: &quot;취소&quot;,
    &quot;close&quot;: &quot;닫기&quot;,
    &quot;delete&quot;: &quot;삭제하기&quot;
  },
 }&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그리고 index.ts 파일에는 공식 깃헙에 나와있는 그대로를 작성해줬다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;locale 변수는 현재 선택된 언어의 코드이다. store에 사용하고 있는 언어를 저장하는 방식으로 사용했다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1719405921622&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;import { init, locale, register } from 'svelte-i18n';
import { languages } from '@/types/i18n';
import { storeLanguageCode } from '@/routes/store';
import { get } from 'svelte/store';

const defaultLocale = get(storeLanguageCode);

languages.forEach((language) =&amp;gt; {
  register(language.code, () =&amp;gt; import(`./locales/${language.code}.json`));
});

init({
  fallbackLocale: defaultLocale,
  initialLocale: defaultLocale,
});

const initI18n = () =&amp;gt; {
  console.log('i18n initialized');
};

locale.subscribe((loc) =&amp;gt; {
  if (loc) {
    storeLanguageCode.set(loc || '');
  }
});

export default initI18n;&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이제 그럼 작성해둔 문자열을 다국어 처리하는 과정이 필요하다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1719406363792&quot; style=&quot;background-color: #f8f8f8; color: #383a42; text-align: start;&quot; data-ke-type=&quot;codeblock&quot; data-ke-language=&quot;typescript&quot;&gt;&lt;code&gt;import { t, locale, locales } from 'svelte-i18n';

locale.subscribe(() =&amp;gt; {
  menuTabs = {
    [APP_ROUTE.MAIN]: $t('menu.search'),
  };
});

&amp;lt;select
  class=&quot;select-bordered select h-auto min-h-fit border border-zinc-500 bg-transparent py-2 text-xs text-white focus:border focus:border-zinc-100&quot;
  bind:value={$locale}
&amp;gt;
  {#each $locales as item_locale}
    &amp;lt;option value={item_locale}&amp;gt;
      {languages.find((lang) =&amp;gt; lang.code === item_locale)?.icon}
      {languages.find((lang) =&amp;gt; lang.code === item_locale)?.name}
    &amp;lt;/option&amp;gt;
  {/each}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;여기서 사용되는 t는 반응형으로 사용하며 주어진 key에 해당하는 다국어 문자열을 반환한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;locales 변수는 지원되는 모든 언어 코드의 배열이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;i18n을 사용하면 웹에서 쉽게 다국어화를 구현할 수 있고, 유지보수에도 편리하다는 장점이 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/svelte-i18n&quot; target=&quot;_blank&quot; rel=&quot;noopener&amp;nbsp;noreferrer&quot;&gt;https://www.npmjs.com/package/svelte-i18n&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>TypeScript/그 외</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/160</guid>
      <comments>https://1two13.tistory.com/entry/i18n%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EB%8B%A4%EA%B5%AD%EC%96%B4-%EC%B2%98%EB%A6%AC-%ED%95%98%EA%B8%B0#entry160comment</comments>
      <pubDate>Wed, 26 Jun 2024 21:55:35 +0900</pubDate>
    </item>
    <item>
      <title>HLS(HTTP 라이브 스트리밍)와 m3u8</title>
      <link>https://1two13.tistory.com/entry/HLSHTTP-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D%EA%B3%BC-m3u8</link>
      <description>&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;HLS&lt;/b&gt;&lt;/h3&gt;&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;HTTP Live Streaming은 가장 널리 사용되는 비디오 스트리밍 프로토콜입니다.&lt;br&gt;HLS는 비디오 파일을 다운로드할 수 있는 HTTP 파일 조각으로 나누고 HTTP 프로토콜을 이용하여 전송합니다.&amp;nbsp;&lt;br&gt;Apple이 자사 제품에 사용하기 위해 개발했지만, 현재는 다양한 장치에서 사용되고 있습니다.&amp;nbsp;&lt;br&gt;&amp;nbsp;&lt;br&gt;HLS는 스트리밍을 통해 미디어 파일을 한 번에 모두 보내지 않고 지속적으로 조금씩 사용자 장치에 보냅니다. 따라서 사용자의 장치가 모든 파일을 다운로드하지 않고 비디오 또는 오디오를 재생할 수 있습니다.&amp;nbsp;&lt;br&gt;&amp;nbsp;&lt;/p&gt;&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;장점&lt;/b&gt;&lt;/h3&gt;&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot;&gt;&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;&lt;li&gt;모든 인터넷 장치가 HTTP를 지원하기 때문에 간단하게 실행 가능&lt;/li&gt;&lt;li&gt;재생에 지장을 주지 않고 네트워크 상태에 따라 비디오 품질 조절 가능 (다양한 품질로 스트리밍 세그먼트를 여러개 복사하기 때문에 가능)&lt;/li&gt;&lt;/ul&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;작동 방식&lt;/b&gt;&lt;/h3&gt;&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;1. 미디어 파일이 저장된 서버 또는 스트리밍이 제작된 서버에서 시작&lt;br&gt;2. 비디오 데이터 포맷을 다시 설정하여 모든 장치가 데이터를 인식하고 해석할 수 있도록 인코딩&lt;br&gt;3. 몇 초 길이 분량의 세그먼트로 조각화&lt;br&gt;4. 세그먼트의 인덱스 파일을 생성하여 세그먼트 순서 기록 및 다양한 품질로 여러 세트의 세그먼트 복제&lt;br&gt;5. 클라이언트가 스트리밍 요청 시 HLS 전송&lt;br&gt;&amp;nbsp;&lt;/p&gt;&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;m3u8&lt;/b&gt;&lt;/h3&gt;&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;m3u8은 HLS 파일 형식이다. 이는 아래와 같다.&amp;nbsp;&lt;/p&gt;&lt;pre data-ke-type=&quot;codeblock&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot;&gt;&lt;code&gt;#EXTM3U
#EXT-X-VERSION:3
#EXT-X-INDEPENDENT-SEGMENTS
#EXT-X-STREAM-INF:BANDWIDTH=940300,AVERAGE-BANDWIDTH=849459,CODECS=&quot;avc1.4d4028,mp4a.40.2&quot;,RESOLUTION=1920x1080,FRAME-RATE=30.000
file_example_MP4_1920_18MGprivate.m3u8&lt;/code&gt;&lt;/pre&gt;</description>
      <category>CS/그 외</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/159</guid>
      <comments>https://1two13.tistory.com/entry/HLSHTTP-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D%EA%B3%BC-m3u8#entry159comment</comments>
      <pubDate>Sun, 23 Jun 2024 17:04:32 +0900</pubDate>
    </item>
    <item>
      <title>OAuth 인증 과정</title>
      <link>https://1two13.tistory.com/entry/OAuth-%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95</link>
      <description>&lt;div style=&quot;padding: 15px 20px; background-color: #f4f4f4; border-radius: 0px 0px; border: 1px solid #d9d9d9; line-height: 1.8;&quot;&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;&lt;b&gt;목차&lt;/b&gt;&lt;/p&gt;
&lt;ol id=&quot;toc&quot; style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;&lt;/ol&gt;
&lt;script type=&quot;text/javascript&quot;&gt; $(function(){  $(&quot;#toc&quot;).toc({content: &quot;.tt_article_useless_p_margin&quot;, headings: &quot;h3&quot;}); });&lt;/script&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;/div&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;저번에 프로젝트에서 구글 로그인과 구글 드라이브에 있는 파일들을 공유하는 기능을 구현했고, 이때 OAuth를 사용해 회사의 서비스가 구글에 접근할 수 있는 권한을 얻게 되었다. OAuth의 원리에 대해 공부를 딥하게는 하지 못한채로 프로젝트를 끝낸것 같아 글로 정리하고 세미나를 진행해보기로 했다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;OAuth를 설명하기 이전에 왜 OAuth를 사용해 다른 서비스에 접근하는 권한을 획득하는 방법을 사용하는지에 대해 생각해봤다. 사실 그냥(google을 예로 들겠다) ID/PW를 우리의 서비스에 저장한 채로 구글에 보내 접근 권한을 획득하는 것이 루트도 짧고 편하지만, 사용자는 자신의 아이디와 비밀번호와 같은 개인정보를 처음보는 서비스에 맡기기에는 부담이 있다. 또한 우리 회사의 입장에서 노출되면 안되는 개인정보를 관리하는 것은 부담이 있고, 구글과 같은 회사의 입장에서도 자신의 고객들이 위험에 노출되는 것을 원치 않을 것이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이러한 위험성 때문에 OAuth를 사용하여 사용자는 서비스에 접근하는 권한을 획득한다. OAuth를 사용하면 access token을 얻을 수 있고, ID/PW가 아닌 access token을 통해 권한을 획득할 수 있기 때문이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;역할&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;먼저 계속 언급될 주체들과 그 역할에 대해 알아야 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Resource Owner(user)&lt;/li&gt;
&lt;li&gt;Client(우리의 서비스)&lt;/li&gt;
&lt;li&gt;Resoure Server(google과 같은 다른 서비스 자원, 데이터), Authorization Server(google과 같은 다른 서비스 자원,&amp;nbsp;인증)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그럼 이제 본격적으로 유저가 우리의 웹 서비스에서 구글 드라이브 권한을 얻기위해 OAuth 2.0을 통해 권한을 획득하는 과정에 대해 알아보자.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1. 등록 (client가 resource server에 등록)&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;resource server는 client로부터 아래의 3가지 값을 받는다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. client ID (애플리케이션 식별자)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. client secret (애플리케이션 비밀번호)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. authorized redirect urls (authorized code를 받는 주소)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;등록을 하고 나면 client와 resource server는 client에 대한 정보(client ID, client secret)와 redirect url을 알게 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;2. 인증-Resource Owner의 승인&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;(사용자가 resource server에 접속하는데 동의를 구하는 과정)&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1.&amp;nbsp; resource owner가 client에 접속&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2.&amp;nbsp; 접속하는 과정 중 resource owner가 resource server에 접근이 필요한 경우 client에 login 화면 노출&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;400&quot; data-origin-height=&quot;372&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/GPPlG/btsDT4iVzwA/O7YMTwfnDXtMSMvsitLZN0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/GPPlG/btsDT4iVzwA/O7YMTwfnDXtMSMvsitLZN0/img.png&quot; data-alt=&quot;출처: 생활코딩&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/GPPlG/btsDT4iVzwA/O7YMTwfnDXtMSMvsitLZN0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FGPPlG%2FbtsDT4iVzwA%2FO7YMTwfnDXtMSMvsitLZN0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;242&quot; height=&quot;225&quot; data-origin-width=&quot;400&quot; data-origin-height=&quot;372&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: 생활코딩&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. resource owner가 버튼 클릭 시 사전에 생성해둔 아래와 같은 url로 이동(resource server로 접속)&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;https://resource.server/?client_id=1&amp;amp;scope=B,C&amp;amp;redirect_uri=https://client/callback&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. resouce server는 resource owner의 로그인 여부 파악&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 로그인이 되어 있지 않으면 로그인 화면 노출&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1002&quot; data-origin-height=&quot;1116&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/yBTzJ/btsDVmDp0VF/KnIneEzOUzjJsUGGGDTxGK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/yBTzJ/btsDVmDp0VF/KnIneEzOUzjJsUGGGDTxGK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/yBTzJ/btsDVmDp0VF/KnIneEzOUzjJsUGGGDTxGK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FyBTzJ%2FbtsDVmDp0VF%2FKnIneEzOUzjJsUGGGDTxGK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;446&quot; height=&quot;497&quot; data-origin-width=&quot;1002&quot; data-origin-height=&quot;1116&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;6. 로그인 성공 시 resource server는 &lt;b&gt;client_id&lt;/b&gt; 값과 &lt;b&gt;redirect url&lt;/b&gt; 값의 일치여부 확인&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;7. 일치한다면 resource server는 resource owner에게 &lt;b&gt;scope&lt;/b&gt;에 해당하는 권한을 부여할 것인지 확인하는 화면 노출&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-filename=&quot;blob&quot; data-origin-width=&quot;948&quot; data-origin-height=&quot;1682&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cVuoKP/btsDRajUehM/3fpgUPl9KCwTXm94j0OBz0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cVuoKP/btsDRajUehM/3fpgUPl9KCwTXm94j0OBz0/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cVuoKP/btsDRajUehM/3fpgUPl9KCwTXm94j0OBz0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcVuoKP%2FbtsDRajUehM%2F3fpgUPl9KCwTXm94j0OBz0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;399&quot; height=&quot;708&quot; data-filename=&quot;blob&quot; data-origin-width=&quot;948&quot; data-origin-height=&quot;1682&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;8. resource owner가 권한 허용 시 resource server는 &lt;b&gt;user_id&lt;/b&gt;와 &lt;b&gt;scope&lt;/b&gt;에 대한 정보를 서버에 저장&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;3. 인증-Resource Server의 승인&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. resource server는 authorization &lt;b&gt;code&lt;/b&gt;(임시 비밀번호)를 resource owner에게 전송&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;https://client/callback?code=3&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. location header 값에 의해 &lt;b&gt;위 주소로 이동&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. client는 authorization code의 값을 알게됨&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. client는 &lt;b&gt;resource server로 직접 접근&lt;/b&gt;(authorization_code, client_secret)&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;https://resource.server/toekn?grant_type=authorization_code&amp;amp;code=3&amp;amp;client_id=1&amp;amp;client_secret=2&amp;amp;redirect_uri=https://client/callback&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. resource server는 authorization code를 비교하여 값의 일치여부 확인(client id, client secret, redirect url...)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;4. resource server 엑세스 토큰 발급&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. resource server와 client는 authorization code를 제거한다. (다시 재인증하지 않기 위함)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. resource server는 access token을 발급하고, client에게 전달한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. client는 acess token을 내부에 저장한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;5. API 호출&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;access_token을 query에 추가하여 호출하는 방법 또는 Authorization: Bearer를 HTTP header에 추가하여 호출하는 방법이 있다. 공식문서에서는 HTTP header에 추가하는 방식을 더 선호한다고 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;6. refresh token&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;access token은 만료 기한이 있다. 만료 기한이 지나면 다시 access token을 받아야하는데 그때마다 사용자를 다시 로그인 시키는 것은 UX에 좋지 않다. 이때 사용하는 것이 refresh token이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;사용자가 로그아웃하지 않았다면 새로운 access token이 담긴 JSON 객체를 반환한다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1706078498002&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;{
  &quot;access_token&quot;: &quot;&quot;,
  &quot;expires_in&quot;: 3920,
  &quot;token_type&quot;: Bearer
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=hm2r6LtUbk8&amp;amp;list=PLuHgQVnccGMA4guyznDlykFJh28_R08Q-&amp;amp;index=2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;생활코딩 OAuth 2.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>CS/그 외</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/158</guid>
      <comments>https://1two13.tistory.com/entry/OAuth-%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95#entry158comment</comments>
      <pubDate>Wed, 24 Jan 2024 21:11:03 +0900</pubDate>
    </item>
    <item>
      <title>인증과 인가</title>
      <link>https://1two13.tistory.com/entry/%EC%9D%B8%EC%A6%9D%EA%B3%BC-%EC%9D%B8%EA%B0%80</link>
      <description>&lt;div style=&quot;padding: 15px 20px; background-color: #f4f4f4; border-radius: 0px 0px; border: 1px solid #d9d9d9; line-height: 1.8;&quot;&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;&lt;b&gt;목차&lt;/b&gt;&lt;/p&gt;
&lt;ol id=&quot;toc&quot; style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;&lt;/ol&gt;
&lt;script type=&quot;text/javascript&quot;&gt; $(function(){  $(&quot;#toc&quot;).toc({content: &quot;.tt_article_useless_p_margin&quot;, headings: &quot;h3&quot;}); });&lt;/script&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;/div&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;보안 프로세스인 인증과 인가에 대해서 설명해보려고 한다. 로그인 기능을 구현할 때 인가코드, 인증 이러한 용어들을 듣게 되는데 정확히 뭔지 궁금해져 공부해보게 되었다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1280&quot; data-origin-height=&quot;800&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/kKpsE/btsDT4P8Cjq/kMAx77j7D7vk7fItjGgGS0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/kKpsE/btsDT4P8Cjq/kMAx77j7D7vk7fItjGgGS0/img.png&quot; data-alt=&quot;출처: okta&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/kKpsE/btsDT4P8Cjq/kMAx77j7D7vk7fItjGgGS0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkKpsE%2FbtsDT4P8Cjq%2FkMAx77j7D7vk7fItjGgGS0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;774&quot; height=&quot;484&quot; data-origin-width=&quot;1280&quot; data-origin-height=&quot;800&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: okta&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;인증(소셜 로그인)&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;인증은 식별 가능한 정보로 보호된 리소스에 접근하는 것을 &lt;b&gt;허용하기 이전&lt;/b&gt;에 서비스에 등록된 &lt;b&gt;유저의 신원을 입증&lt;/b&gt;하는 과정이다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;예를 들어 출국할 때 여권으로 신원을 입증하거나 회사에 들어올 때 출입증을 통해 신원을 입증할 수 있다. 웹의 경우에는 아이디와 패스워드를 입력하거나 휴대폰에 전달된 SMS에 적혀있는 코드를 입력하는 것이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;인가(OAuth)&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;인가는 요청된 리소스에 접근할 수 있는 &lt;b&gt;권한&lt;/b&gt;이 있는 &lt;b&gt;인증된 유저&lt;/b&gt;인지 입증하는 과정&lt;/span&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;이다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;예를 들어 회사가 14층에 위치하고 있다면 13층에 위치한 다른 회사에는 접근할 수 없다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;웹에서는 일반적으로 &lt;b&gt;토큰&lt;/b&gt;을 통해서 인가를 다룬다. 사용자의 신원을 바탕으로 인가 세부사항을 가진 토큰을 생성하게 되고, 시스템은 인가 토큰을 이용해서 어떤 권한을 부여할지, 즉 &lt;b&gt;리소스 접근&lt;/b&gt; 요청을 허용할지 거부할지를 결정하게 된다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1336&quot; data-origin-height=&quot;746&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cwfss1/btsDUaQd1S1/OZ9j0Yu3PotqIhKltEKA91/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cwfss1/btsDUaQd1S1/OZ9j0Yu3PotqIhKltEKA91/img.png&quot; data-alt=&quot;출처: okta&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cwfss1/btsDUaQd1S1/OZ9j0Yu3PotqIhKltEKA91/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcwfss1%2FbtsDUaQd1S1%2FOZ9j0Yu3PotqIhKltEKA91%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;748&quot; height=&quot;418&quot; data-origin-width=&quot;1336&quot; data-origin-height=&quot;746&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: okta&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;인증과 인가를 비교해보자면 위의 표와 같다. 인증은 사용자가 보고 직접 변경할 수 있지만, 인가는 볼 수도, 변경할 수도 없다. 그리고 인증은 데이터 전송 시 ID 토큰을 사용하고, 인가는 엑세스 토큰을 사용한다.&amp;nbsp;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;다시 말해, 인증과 인가는 &lt;b&gt;자원&lt;/b&gt;을 &lt;b&gt;유효한 사용자&lt;/b&gt;에게 전달, 공개하기 위한 방법이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;HTTP의 stateless&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;웹 사이트는 HTTP 통신 위에서 동작하고, 모든 요청과 응답은 stateless한 특성을 가지게 된다. 즉, &lt;u&gt;&lt;b&gt;서버&lt;/b&gt;&lt;/u&gt;에서 &lt;b&gt;client의 이전 상태&lt;/b&gt;를 &lt;b&gt;&lt;u&gt;기억하고 있지 않다.&lt;/u&gt;&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Request Header를 사용한 인증 과정은 아래와 같다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. url로 접근&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2.&amp;nbsp; url을 파싱하여 base64로 인코딩&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;3. 인코딩한 값을 request header에 담기&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;4. HTTP 통신&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;5. 서버는 DB에 값이 있는지 체크&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이 특성과 인증을 함께 생각해보면 로그인을 통해 인증을 거쳐도 이후 요청에서는 이전의 인증된 상태를 유지하지 않게 된다. 이러한 상황에서 웹 사이트를 이용하게 된다면 인증/인가가 필요한 모든 상황에서 사용자는 반복적으로 아이디와 패스워드를 입력해야하는 불상사가 있을 것이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그럼, stateless한 HTTP 위에서 인증/인가를 어떠한 방식으로 해야할까?에 대한 의문이 생긴다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;해결책으로는 크게 3가지 방법이 있다. 쿠키, 세션, 토큰&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1. 인증/인가 구현 방식 - 쿠키&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;HTTP 쿠키는 &lt;b&gt;&lt;u&gt;서버&lt;/u&gt;에서 사용자 &lt;u&gt;브라우저&lt;/u&gt;&lt;/b&gt;로 전송하는 키-값 형태의&amp;nbsp;&lt;b&gt;작은 데이터&lt;/b&gt;다. &lt;u&gt;&lt;b&gt;브라우저&lt;/b&gt;&lt;/u&gt;는 서버에서 받은 &lt;b&gt;쿠키를 저장&lt;/b&gt;해 놓았다가 &lt;b&gt;동일한 서버로 재요청&lt;/b&gt;시 제공받았던 데이터를 함께 전송한다. 이를 통해 HTTP의 stateless를 보완해 HTTP 통신에서도 상태 정보를 보존할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;사용자가 로그인할 때 서버는 ID/PW를 쿠키에 담아서 응답하고, 이후 요청부터는 &lt;b&gt;브라우저가 ID/PW를 쿠키에 담아 함께 보내&lt;/b&gt;면, 사용자는 인증/인가를 위해 매번 ID/PW를 입력할 필요가 없다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;참고로 쿠키의 유효기간을 설정하고, &lt;b&gt;response header&lt;/b&gt;에 쿠키를 설정할 수 있다. 또한 쿠키에는 &lt;b&gt;HttpOnly&lt;/b&gt;라는 설정값이 있어 JS로 쿠키에 접근할 수 없도록 막아 XSS(&lt;span style=&quot;background-color: #ffffff; color: #202124; text-align: left;&quot;&gt;Cross Site Scripting, 공격자가 상대방의 브라우저에 스크립트가 실행되도록 해 사용자의 세션을 가로채거나, 웹사이트를 변조하거나, 악의적 콘텐츠를 삽입하거나, 피싱 공격&lt;/span&gt;)와 같은 공격으로부터 보호해줄 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;정리하자면, 쿠키를 사용하면 첫 인증 때 기존 로그인 정보를 쿠키 형태로 브라우저에 심고, 매 요청마다 쿠키를 통해 로그인 정보를 함께 서버로 보내는 것이다. 즉, 매번 자동으로 로그인을 한다고 보면된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;쿠키의 장점은 기존 로그인을 위한 정보를 사용하기 때문에 인증/인가를 위한 추가적인 데이터 저장이 필요없어 &lt;b&gt;서버 대수를 늘려도&lt;/b&gt; 크게 이슈가 발생하지 않는다.&amp;nbsp;하지만 사용자의 &lt;b&gt;주요 정보&lt;/b&gt;를 매번 요청에 담아야 하기 때문에 보안상의 위험이 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;2. 인증/인가 구현 방식 - 세션&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;쿠키의 보안상 문제를 보안하고자 나온 것이 세션이다. 세션은 고객의 주요 정보가 아닌, &lt;b&gt;고객을 식별할 수 있는 값(&lt;u&gt;Session ID&lt;/u&gt;)&lt;/b&gt;을 생성해 &lt;b&gt;쿠키로 주고 받는다&lt;/b&gt;. 따라서 사용자를 식별할 수 있는 값을 생성해야하고, 이를 &lt;b&gt;서버에 저장&lt;/b&gt;하는 작업이 필요하다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;세션을 사용했을 때의 장점은 아래와 같다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 만료기간을 지정할 수 있기 때문에 해커가 가져가더라도 만료 기간이 지나면 사용할 수 없다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 클라이언트 쪽에서 데이터를 가지고 있지 않기 때문에 보안상 쿠키보다 안전하다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 세션은 서버가 관리하고 있기 때문에 세션 자체를 서버에서 삭제하면 더 이상 사용할 수 없다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 단점으로는 &lt;b&gt;다중 서버일 경우에는 매번 같은 서버로 요청이 간다고 보장할 수 없기&lt;/b&gt; 때문에 session ID가 저장되지 않은 곳으로 요청이 가면 사용자를 식별할 수 없다는 단점이 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;물론, 이를 보완하기 위한 방법으로 사용자를 식별해 이전에 통신한 서버로 요청이 가도록 경로를 지정하거나 다중 서버의 모든 session 저장소를 동일하게 유지하는 방법(Session Storage 사용)이 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;어찌됐든, session ID 또한 탈취 가능성이 있고, client 상태를 서버에서 관리한다는 점에 있어서 HTTP stateless 특성과는 거리가 멀고, client가 많아질 경우에는 session storage가 뻑이갈 수 있다는 문제점이 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;3. 인증/인가 구현 방식 - 토큰&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그래서 나온 방식이 HTTP Stateless 특성을 사용하는(상태를 저장하지 않는) 토큰이다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;토큰은 기존 로그인 정보를 그대로 사용하지 않으면서도 서버에서 사용자 식별값을 저장 및 관리하지 않아도 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;토큰은 사용자를 인증할 수 있는 정보가 숨겨진 &lt;u&gt;&lt;b&gt;암호화&lt;/b&gt;&lt;/u&gt;된 &lt;b&gt;access token&lt;/b&gt;을 발급하고, 인증이 필요할 때마다 서버에 토큰과 함께 요청을 보낸다. 서버는 저장된 데이터가 아닌&lt;b&gt; 토큰 해독&lt;/b&gt;을 통해 사용자를 식별할 수 있는 정보를 알아내고 이를 바탕으로 인증/인가를 진행한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;토큰에 다양한 유형과 종류가 있지만 우리팀에서는 &lt;b&gt;JWT&lt;/b&gt;(JSON Web Token)을 사용했다. JWT는 웹 서비스에서 자주 사용되는 토큰으로 header, payload, signature와 같은 요소들로 구성되어 있다. &quot;.&quot;을 구분자로 읽기 어려운 JWT로 생성이 된다.&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc; background-color: #ffffff; color: #666666; text-align: start;&quot; data-ke-list-type=&quot;disc&quot; data-mark=&quot;-&quot;&gt;
&lt;li style=&quot;list-style-type: disc;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;Header: Token 유형, 서명 알고리즘(HS256 or RSA 등)이 담긴다.&lt;/span&gt;&lt;/li&gt;
&lt;li style=&quot;list-style-type: disc;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;Payload: Claim이 포함되는 영역으로 전송하고자 하는 여러 데이터가 담긴다.(Claim 유형: Registered / Public / Private)&lt;/span&gt;&lt;/li&gt;
&lt;li style=&quot;list-style-type: disc;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;Signature: Base64로 인코딩 된 Header, Payload와 서버만이 가지고 있는 비밀 키를 설정한 알고리즘으로 암호화한 값이 담긴다.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;요청과 함께 JWT가 서버에 도착했을 때 서버는 JWT가 &lt;b&gt;시크릿키&lt;/b&gt;를 통해&amp;nbsp;&lt;b&gt;자신이 발행한 것이 맞는지 확인&lt;/b&gt;하고, &lt;b&gt;시크릿키&lt;/b&gt;로 암호화를 진행해 signature 영역과 동일한지 확인한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Apple SD Gothic Neo', Arial, sans-serif; letter-spacing: 0px;&quot;&gt;토큰을 사용하면 서버가 여러대가 있어도 각자의 시크릿키로 해독 및 인증을 진행할 수 있고확장성 높음),&amp;nbsp; 토큰으로 상태관리를 하기 때문에 따로 세션을 둘 필요가 없다는 장점이 있다. &lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Apple SD Gothic Neo', Arial, sans-serif; letter-spacing: 0px;&quot;&gt;하지만 여전히 해커에게 노출될 수 있다는 위험은 배제할 수 없기 때문에 시크릿키에 만료기간을 설정할 수 있다. 만료기간이 지나면 해커뿐만이 아니라 사용자도 사용할 수 없기 때문에 이러한 불편함을 감소하기 위해 &lt;b&gt;refresh token&lt;/b&gt;이 나왔다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. HTTP 통신&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 서버는 &lt;b&gt;시크릿키&lt;/b&gt;를 사용해 access token과 refresh token 생성&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. &lt;b&gt;서버&lt;/b&gt;는 &lt;b&gt;&lt;u&gt;refresh token&lt;/u&gt;만 따로 저장소에 저장&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 서버는 클라이언트에게 &lt;b&gt;access token과 refresh token 전송&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 클라이언트는 2개의 token을 저장&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;6. 클라이언트는 access token을 사용해서 요청 보냄&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;7. 만약 access token이 만료되었을 경우 클라이언트는 access token과 refresh token을 다시 서버로 전송&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;8. 서버는 refresh token을 참조하여 DB 체크&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;9. DB에 있는 정보와 일치한다면 새로 갱신된 access token을 클라이언트에게 전송&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;다른 서비스를 통해 인증을 받을 수도 있는데 예시로는 OAuth가 있다. 이는 다른 글에서 자세하게 작성하도록 하겠다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://auth0.com/intro-to-iam/authentication-vs-authorization&quot; target=&quot;_blank&quot; rel=&quot;noopener&amp;nbsp;noreferrer&quot;&gt;https://auth0.com/intro-to-iam/authentication-vs-authorization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.gmarket.com/45&quot; target=&quot;_blank&quot; rel=&quot;noopener&amp;nbsp;noreferrer&quot;&gt;https://dev.gmarket.com/45&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=y0xMXlOAfss&quot; target=&quot;_blank&quot; rel=&quot;noopener&amp;nbsp;noreferrer&quot;&gt;https://www.youtube.com/watch?v=y0xMXlOAfss&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>CS/그 외</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/157</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9D%B8%EC%A6%9D%EA%B3%BC-%EC%9D%B8%EA%B0%80#entry157comment</comments>
      <pubDate>Tue, 23 Jan 2024 17:59:34 +0900</pubDate>
    </item>
    <item>
      <title>TS와 Zode 비교하기</title>
      <link>https://1two13.tistory.com/entry/TS%EC%99%80-Zode-%EB%B9%84%EA%B5%90%ED%95%98%EA%B8%B0</link>
      <description>&lt;div style=&quot;padding: 15px 20px; background-color: #f4f4f4; border-radius: 0px 0px; border: 1px solid #d9d9d9; line-height: 1.8;&quot;&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;&lt;b&gt;목차&lt;/b&gt;&lt;/p&gt;
&lt;ol id=&quot;toc&quot; style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;&lt;/ol&gt;
&lt;script type=&quot;text/javascript&quot;&gt; $(function(){  $(&quot;#toc&quot;).toc({content: &quot;.tt_article_useless_p_margin&quot;, headings: &quot;h3&quot;}); });&lt;/script&gt;
&lt;/div&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;JS를 쓰고 있는 나는 타입 정의를 위해 TS를 사용하고 있다. 근데 팀원 중 한 분이 Zod를 쓰고 싶어하시길래 도대체 장점이 뭐길래? 라는 의문점이 생겨 알아보기 시작했다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;엄격한 유효성 검증을 위해 사용되는 Zod&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Zod가 TS보다 강력한 이유는 엄격한 유효성 검증을 하기 때문이라고 생각한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 그 만큼 TS보다 작성해야하는 코드가 많다는 생각이 들었다. 어떤면에서 볼때는 강력하지만, 또 다른면에서 볼때는 오히려 난잡하다는 느낌이 들었기 때문이다. 하지만 그럼에도 불구하고 TS에 비해 강력하다고 느낀 강점은 아래와 같다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 데이터 스키마, 즉 데이터 구조와 형식을 정의하기 때문에 TS보다 더 강력한 타입 검증이 가능하다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;컴파일 시 스키마에서 정의한 수준의 타입 검사가 발생하기 때문이다.&lt;/p&gt;
&lt;pre id=&quot;code_1705456568922&quot; class=&quot;routeros&quot; style=&quot;background-color: #f8f8f8; color: #383a42; text-align: start;&quot; data-ke-type=&quot;codeblock&quot; data-ke-language=&quot;typescript&quot;&gt;&lt;code&gt;import { z } from &quot;zod&quot;;

const User = z.object({
  email: z.string().email(),
  image: z.string().url(),
  ips: z.string().ip().array(),
});&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 기본값을 설정할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3.&amp;nbsp;정수형과 실수형을 구분할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 허용되는 범위를 제한할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1705456556087&quot; class=&quot;angelscript&quot; style=&quot;background-color: #f8f8f8; color: #383a42; text-align: start;&quot; data-ke-type=&quot;codeblock&quot; data-ke-language=&quot;typescript&quot;&gt;&lt;code&gt;import { z } from &quot;zod&quot;;

const Url = z.string().url().max(200);
const Age = z.number().int().min(18).max(80);&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그럼에도 불구하고 TS보다 확연하게 작은 커뮤니티로 인해 받을 수 있는 스트레스..(이미 TS는 커뮤니티가 활발함에도 불구하고 종종 스트레스를 받아왔다..) 또한 더 많은 코드의 수(write less X)가 단점이라고 생각한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;TypeScript&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;TS는 이미 엄청나게 큰 커뮤니티가 있어 오류가 발생했을 때 도움을 받을 수 있다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 스키마에서 정의한 수준의 타입 검사는 일어나지 않기 때문에 Zod보다는 덜 엄격하다고 말할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;s&gt;이미 TS로도 충분히 엄격한 타입을 검증하고 있다고생각하기 때문에&amp;nbsp; Zod는 장점도 있지만 내 생각에는 아직 굳이..?라는 생각이 있기는 하다. 그래도 Zod만의 장점이 있기 때문에 추후 사용 여부를 결정하게 된다면 내가 생각한 의견들을 말씀드려 보아야겠다.&amp;nbsp;&lt;/s&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Zod를 사용해보고자 하는 마음으로 기울었다. 그 이유는 정말 엄격한 검증이 가능하기 때문이다. 예를 들어 비밀번호를 6개의 숫자로 지정하고 싶을 때, 일반적으로 number로 타입을 지정할 수 밖에 없다. 하지만 Zod를 사용하면 6개의 숫자가 아닌 경우에 명백한 에러를 호출할 수 있다는 장점이 있기 때문이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://zod.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&amp;nbsp;noreferrer&quot;&gt;https://zod.dev/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>TypeScript/그 외</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/156</guid>
      <comments>https://1two13.tistory.com/entry/TS%EC%99%80-Zode-%EB%B9%84%EA%B5%90%ED%95%98%EA%B8%B0#entry156comment</comments>
      <pubDate>Wed, 17 Jan 2024 11:01:43 +0900</pubDate>
    </item>
    <item>
      <title>Google OAuth 2.0 로그인 구현하기</title>
      <link>https://1two13.tistory.com/entry/Google-OAuth-20-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;Google 로그인과 구글 드라이브의 파일과 비디오를 업로드하는 기능을 맡아 구현하게 되었다. Google 로그인은 물론 구글 드라이브를 연결해본 경험은 없었다. 호기롭게 시작했지만 많은 오류와 시련을 겪었다..&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;변명아닌 변명을 해보자면&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. google 공식문서라고 믿으면 안된다.. (믿는 도끼에 큰 코 다친다고 공식문서는 업데이트도 되지 않았었고, 구글 로그인 관련된 코드를 관리하는 웹과 구글 드라이브 관련 코드를 관리하는 웹이 서로 다른 코드를 예제로 들고 있었다.)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. svelte로 작성된 코드가 없었기 때문에 JS 샘플코드만 가지고 svelte화 시키는 과정에서 시간이 소요되었다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. TS로 작성된 코드도 없었기 때문에 타입 지정하는데 어려움을 겪었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;어쨌든 결과적으로 혼자서 Google 로그인과 구글 드라이브를 연동하여 비디오를 업로드하는 기능까지 구현할 수 있었다. 순정의 끝은 결국 공식문서였고, 공식문서의 도움을 정말 많이 받았다. &lt;s&gt;밉지만 너뿐이다!&lt;/s&gt;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;구글 로그인 기본 단계&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;기본적인 로그인 단계를 설명하자면 아래와 같다. 이런 흐름이구나를 알고 이어서 더 깊게 설명하도록 하겠다.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2348&quot; data-origin-height=&quot;1208&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/q6nHi/btsDp8NCr2k/hCWPClKyrMylmL1H8TgPBK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/q6nHi/btsDp8NCr2k/hCWPClKyrMylmL1H8TgPBK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/q6nHi/btsDp8NCr2k/hCWPClKyrMylmL1H8TgPBK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fq6nHi%2FbtsDp8NCr2k%2FhCWPClKyrMylmL1H8TgPBK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;785&quot; height=&quot;404&quot; data-origin-width=&quot;2348&quot; data-origin-height=&quot;1208&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 프론트에서 Google OAuth 로그인을 요청한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 구글 서버에서 인가코드를 발행한다. (&lt;b&gt;access_token&lt;/b&gt;)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 구글에서 받은 인가코드를 백에게 보내준다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 백은 인가코드를 이용하여 구글 서버에&lt;b&gt; 사용자의 정보&lt;/b&gt;를 요청한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 올바른 인가코드를 받은 구글 서버는 해당 사용자의 정보를 백에게 제공한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;6. 백은 프론트에게 사용자 정보를 전달한다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;참고로 최초 구글 연동시&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;refresh_token&lt;/b&gt;은 1회 발급되고&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;만료기간은 6개월&lt;/b&gt;이다. 그 이후에는 refresh_token이 만료되기 전까지&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;access token만&lt;/b&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;발급된다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;실제 구현 과정&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;참고로 구글 로그인 서비스를 설정하는 방법은 따로 작성하지 않았습니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;구글 로그인 서비스를 구현하기 위해서는 &lt;a href=&quot;https://console.cloud.google.com/home/dashboard&quot;&gt;https://console.cloud.google.com/home/dashboard&lt;/a&gt; 에서 일부 설정을 통해 키와 비밀번호를 발급받아야 합니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이 &lt;a href=&quot;https://velog.io/@chrkb1569/OAuth-2.0%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84#%EA%B5%AC%EA%B8%80-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%84%A4%EC%A0%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;블로그&lt;/a&gt;에서 자세하게 설명되어 있어서 참고하시면 좋을 것 같습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;3678&quot; data-origin-height=&quot;1500&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/pxVaY/btsDwEqsYCc/tTVvWNK1CxK8FuMsw2JGdK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/pxVaY/btsDwEqsYCc/tTVvWNK1CxK8FuMsw2JGdK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/pxVaY/btsDwEqsYCc/tTVvWNK1CxK8FuMsw2JGdK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpxVaY%2FbtsDwEqsYCc%2FtTVvWNK1CxK8FuMsw2JGdK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;835&quot; height=&quot;341&quot; data-origin-width=&quot;3678&quot; data-origin-height=&quot;1500&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 구글 로그인 버튼 클릭 시 Google API Console에서 OAuth 2.0 사용자 인증 정보를 가져오게 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 이때 Google API를 사용하여 데이터에 엑세스하려면 &lt;b&gt;access token&lt;/b&gt;을 가져와야 한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그러기 위해서는 사용자를 Google OAuth 2.0 서버로 리다이렉션이 필요하기 때문에 &lt;span style=&quot;background-color: #f1f3f4; color: #37474f; text-align: left;&quot;&gt;&lt;a href=&quot;https://accounts.google.com/o/oauth2/v2/auth&quot;&gt;https://accounts.google.com/o/oauth2/v2/auth&lt;/a&gt;&lt;/span&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;&lt;span&gt;&amp;nbsp;에&lt;/span&gt;서 Google OAuth 2.0 엔드포인트의 엑세스를 요청하는 URL을 생성한다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;URL에는 sope와 code 등(쿼리 매개변수를 사용하여 필요한 API 엑세스 유형 식별)이 포함되어 있고, 이를 통해 승인 코드가 생성된다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;참고로 scope는 엑세스 토큰에서 허용하는 리소스 및 작업 집합을 제어한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;로그인을 하면 권한 동의를 얻는 메세지가 사용자에게 표시되는데, 동의하면 Google 승인 서버가 애플리케이션에 엑세스하는 토큰 및 해당 토큰이 부여하는 &lt;b&gt;엑세스 범위 목록&lt;/b&gt;을 보낸다. 만약 권한을 동의하지 않으면 서버에서 오류를 반환한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1710&quot; data-origin-height=&quot;1864&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/plQrY/btsDuxeuFYO/5cy2ftIJzPZCATtweUS4lk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/plQrY/btsDuxeuFYO/5cy2ftIJzPZCATtweUS4lk/img.png&quot; data-alt=&quot;출처: 구글 Authorization 공식문서&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/plQrY/btsDuxeuFYO/5cy2ftIJzPZCATtweUS4lk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FplQrY%2FbtsDuxeuFYO%2F5cy2ftIJzPZCATtweUS4lk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;806&quot; height=&quot;879&quot; data-origin-width=&quot;1710&quot; data-origin-height=&quot;1864&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: 구글 Authorization 공식문서&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;동의 후에는 OAuth 2.0 서버가 엑세스 토큰 요청에 지정된 &lt;b&gt;redirect_URI로 응답을 전송&lt;/b&gt;한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;예를 들어 엑세스 토큰 응답은 아래와 같다.&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;https://oauth2.example.com/callback#access_token=4/P7q7W91&amp;amp;token_type=Bearer&amp;amp;expires_in=3600&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 사용자가 부여한 엑세스 범위를 검토하고 백에게 JWT, redirect URL에서 추출한 code와 scope를 Post한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;엑세스 토큰을 얻은 후에 API에 필요한 엑세스 범위가 부여되면 토큰을 사용해 특정 사용자 계정을 대신하여 Google API를 호출할 수 있다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 백은 인가코드(access_token)를 이용하여 구글 서버에&lt;b&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;사용자의 정보&lt;/b&gt;를 요청한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;5. 올바른 인가코드를 받은 구글 서버는 해당 사용자의 정보를 백에게 제공한다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;6. 백은 프론트에게 사용자 정보를 전달한다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;구현 코드 살펴보기&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;pre id=&quot;code_1705297654012&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;  const initCodeClient = () =&amp;gt; {
    window.google.accounts.oauth2
      .initCodeClient({
        client_id: CLIENT_ID,
        scope: SCOPE.join(' '), // scope가 여러개인 경우 배열 안에 값을 추가하여 join
        redirect_uri: '리다이렉트 URL'
        ux_mode: 'redirect',
      })
      .requestCode();
  };&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;아래는 scope 예시다. google drive에 대한 권한 허용을 위해 drive를 추가했다.&lt;/p&gt;
&lt;div style=&quot;background-color: #1e1f22; color: #bcbec4;&quot;&gt;
&lt;pre class=&quot;dart&quot;&gt;&lt;code&gt;export const SCOPE = ['https://www.googleapis.com/auth/drive.readonly', 'profile'];&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/identity/protocols/oauth2?hl=ko&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google OAuth 공식문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/google-api-javascript-client?tab=readme-ov-file&quot; target=&quot;_blank&quot; rel=&quot;noopener&amp;nbsp;noreferrer&quot;&gt;https://github.com/google/google-api-javascript-client?tab=readme-ov-file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/identity/protocols/oauth2/javascript-implicit-flow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JS 웹 애플리케이션에서 Google API에 엑세스할 수 있도록 OAuth 2.0 승인 구현&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>JavaScript/그 외</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/153</guid>
      <comments>https://1two13.tistory.com/entry/Google-OAuth-20-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0#entry153comment</comments>
      <pubDate>Mon, 15 Jan 2024 15:24:31 +0900</pubDate>
    </item>
    <item>
      <title>2024년 더 나은 FE 개발자가 되기 위한 목표</title>
      <link>https://1two13.tistory.com/entry/2024%EB%85%84-%EB%8D%94-%EB%82%98%EC%9D%80-FE-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%90%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EB%AA%A9%ED%91%9C</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;개발자는 스스로를 회고하는 과정이 필수적이라고 생각한다. 그래서 작지만 큰 목표를 세워 이를 이루려고 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. &lt;a href=&quot;https://www.programiz.com/dsa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DSA(Data Structures and Algorithm)&lt;/a&gt; 공부하기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. React를 사용해 개인 프로젝트 하나 개발하고 꾸준히 업데이트 하기 (현재 회사에서는 svelte를 사용하고 있지만, react도 놓치면 안된다고 생각한다.)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 스프린트가 끝난 후 에러로그 작성 및 큰 이벤트 관련하여 블로깅 작성하기&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 문제를 근본적으로 해결하기 위해 노력하고 그 과정을 기록하기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 질문하는 스킬과 의견을 공유하는 스킬을 성장시키기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://techdevguide.withgoogle.com/paths/data-structures-and-algorithms/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;google tech dev guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>회고록</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/152</guid>
      <comments>https://1two13.tistory.com/entry/2024%EB%85%84-%EB%8D%94-%EB%82%98%EC%9D%80-FE-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%90%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EB%AA%A9%ED%91%9C#entry152comment</comments>
      <pubDate>Fri, 12 Jan 2024 11:38:14 +0900</pubDate>
    </item>
    <item>
      <title>프론트엔드 입장에서 바라본 Socket과 WebSocket</title>
      <link>https://1two13.tistory.com/entry/WebSocket%EC%9D%B4%EB%9E%80</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;회사에서 데모 프로젝트를 수행하는데 웹소켓을 사용해 통신을 할 예정이라고 해서 공부하기 시작했다. &lt;s&gt;예전에 분명 써본거 같은데 기억이 안난다..&lt;/s&gt; 아마 프로젝트를 끝내고 나면 더 완벽하게 이해할 수 있을 것 같은데, 그건 또 추후에 포스팅해야겠다. 현 시점에서 생각해본다면 비디오 데이터를 보여줘야하고, 실시간으로 업데이트되는 영상들을 띄어줘야하기 때문에 웹소켓을 사용해 실시간 네트워킹이 필요하기 때문이라고 생각한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;&lt;b&gt;Socket이란?&lt;/b&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;hr data-ke-style=&quot;style6&quot; data-ke-type=&quot;horizontalRule&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;웹소켓에 대해 알아보기 전에 socket이 뭔지에 대해서 궁금했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;socket은 프로그램이 네트워크에서 데이터를 주고받을 수 있도록 &lt;b&gt;&lt;u&gt;네트워크&lt;/u&gt; 환경에 연결&lt;/b&gt;할 수 있게 만들어진 연결부다. 일반적으로 &lt;b&gt;TCP/IP&lt;/b&gt; 프로토콜을 이용하고, TCP/IP 4계층에서 전송 계층 위에 놓인다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Socket을 이용한 통신 프로그래밍을 Socket Programming이라고 하고, 이는 Client Socket과 Server Socket으로 구분된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;통신 연결 요청을 보내는 &lt;b&gt;Client Socket&lt;/b&gt; 흐름은 아래와 같다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 아무 정보가 들어있지 않은 &lt;b&gt;빈 껍데기 Socket을 생성&lt;/b&gt;한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. IP 주소와 Port 번호로 연결하고 싶은 대상을 특정하여 &lt;b&gt;연결을 요청&lt;/b&gt;한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 데이터를 송수신하게 되는데, &lt;b&gt;수신하는 API는 &lt;u&gt;별도의 Thread&lt;/u&gt;&lt;/b&gt;에서 진행하게 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 더 이상의 데이터 송수신이 필요없어지게 되면, 소켓을 닫는다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;통신 연결 요청을 받아들이는 &lt;b&gt;Server Socket&lt;/b&gt; 흐름은 아래와 같다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 아무 정보가 들어있지 않은 &lt;b&gt;빈 껍데기 Socket을 생성&lt;/b&gt;한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. &lt;u&gt;&lt;b&gt;포트&lt;/b&gt;&lt;/u&gt;&lt;b&gt;를 사용해 프로세스를 식별&lt;/b&gt;하기 때문에 Server Socket이 고유한 포트 번호를 만들 수 있도록 &lt;b&gt;Socket과 Port 번호를 바인딩&lt;/b&gt;한다. 참고로 &lt;b&gt;하나의 프로세스는 같은 포트를 가진 Socket을 여러개&lt;/b&gt; 열 수 있다. (client 연결 요청을 받아들을 준비가 완료된 상태)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. client가 연결을 요청할 때까지 계속 대기하다가, 연결 요청이 오면 대기 상태를 종료하고 리턴한다. 아직 연결이 된 상태는 아니다. (listen)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. client 연결을 받고 &lt;b&gt;새로 생성된 Socket과 Client Socket을 매핑&lt;/b&gt;한다. (accept)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 데이터를 송수신하게 되고, 수신하는 API는 별도의 Thread에서 진행하게 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;6. 더 이상의 데이터 송수신이 필요없어지게 되면, 소켓을 닫는다.&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&amp;nbsp;&lt;/h2&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;WebSocket이란?&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;websocket을 사용하면&lt;b&gt;&amp;nbsp;서버와 브라우저 간 &lt;u&gt;연결을 유지한 상태&lt;/u&gt;로 데이터를 교환할 수 있다.&lt;/b&gt; 다시 말해, 서버와 브라우저 간 통신은 &lt;u&gt;HTTP가 아닌&lt;/u&gt; 웹소켓 프로토콜을 사용해 진행한다.&amp;nbsp;이 때 데이터는 &lt;u&gt;&lt;b&gt;packet&lt;/b&gt;&lt;/u&gt; 형태로 전달되고, 전송은 커넥션 중단과 추가 HTTP 요청 없이 &lt;b&gt;양방향&lt;/b&gt;으로 이루어진다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이러한 특징 때문에 websocket은 주식 트레이딩 시스템, 채팅, 비디오 데이터 같이 &lt;b&gt;데이터 교환이 지속적으로 이뤄져야하는 서비스에 적합하다.&amp;nbsp;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;참고로 패킷(packet)은 pack과 bucket를 합친 말로 컴퓨터 간에 데이터를 주고 받을 때 네트워크를 통해서 전송되는 &lt;b&gt;데이터 조각&lt;/b&gt;입니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;div class=&quot;revenue_unit_wrap&quot;&gt;
  &lt;div class=&quot;revenue_unit_item adfit&quot;&gt;
    &lt;div class=&quot;revenue_unit_info&quot;&gt;728x90&lt;/div&gt;
    &lt;ins class=&quot;kakao_ad_area&quot; style=&quot;display: none;&quot; data-ad-unit=&quot;DAN-US3Vkz08ccF5YjEX&quot; data-ad-width=&quot;728px&quot; data-ad-height=&quot;90px&quot;&gt;&lt;/ins&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;//t1.daumcdn.net/kas/static/ba.min.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;revenue_unit_wrap&quot;&gt;
  &lt;div class=&quot;revenue_unit_item adsense responsive&quot;&gt;
    &lt;div class=&quot;revenue_unit_info&quot;&gt;반응형&lt;/div&gt;
    &lt;script src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;
    &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display: block;&quot; data-ad-host=&quot;ca-host-pub-9691043933427338&quot; data-ad-client=&quot;ca-pub-9494913384123847&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
    &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;간단한 예시&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;웹소켓 커넥션을 만들려면 &lt;b&gt;new WebSocket&lt;/b&gt;을 호출하면 된다. 이 때 &lt;b&gt;ws&lt;/b&gt;라는 특수 프로토콜을 사용한다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1678374167274&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;let socket = new WebSocket(&quot;ws://javascript.info&quot;);&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;참고로, wss://라는 프로토콜도 있는데, 항상 &lt;b&gt;wss://&lt;/b&gt;를 사용해야 한다. 보안과 신뢰성 측면에서 ws보다 뛰어나기 때문이다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;ws를 사용하여 데이터를 전송하면 데이터가 암호화되지 않은 채로 전송되기 때문에 데이터가 그대로 노출되고, 아주 오래된 proxy서버는 웹소켓을 몰라서 이상한 헤더가 붙은 요청이 들어왔다고 판단하고 연결을 끊어버린다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;반면 wss://는 &lt;b&gt;TSL&lt;/b&gt;(전송 계층 보안(Transport Layer Security))이라는 보안 계층을 통과해 전달되므로 송신자 측에서 데이터가 암호화되고, 복호화는 수신자 측에서 이뤄지게 된다. 따라서 &lt;b&gt;데이터가 담긴 패킷이 암호화&lt;/b&gt;된 상태로 proxy 서버를 통과하므로 proxy 서버는 패킷 내부를 볼 수 없게 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;socket이 정상적으로 만들어지면 open =&amp;gt; message =&amp;gt; close 순으로 이벤트가 동작한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;open은 커넥션이 제대로 만들어졌을 때, message는 데이터를 수신했을 때, close는 커넥션이 종료되었을 때 발생한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;1. 웹소켓 핸드셰이크&lt;/b&gt;&lt;/h2&gt;
&lt;hr data-ke-style=&quot;style6&quot; data-ke-type=&quot;horizontalRule&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;브라우저와 서버의 연결을 &lt;b&gt;시작&lt;/b&gt;하게 해주는 단계를 핸드셰이크라고 한다. 참고로 &lt;b&gt;최초로 접속&lt;/b&gt;할 때 &lt;b&gt;HTTP 프로토콜 위&lt;/b&gt;에서 핸드셰이크를 하기 때문에 HTTP Header를 사용한다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. new WebSocket(url)을 호출&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. 즉시 소켓 연결 시작&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;3. 커넥션이 유지되는 동안 &lt;u&gt;브라우저&lt;/u&gt;는 &lt;b&gt;헤더&lt;/b&gt;를 사용해서 &lt;u&gt;서버&lt;/u&gt;에 &lt;b&gt;웹소켓을 지원하는지&lt;/b&gt; 물어봄&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;4. 서버가 맞다는 응답을 하면,&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;5. &lt;b&gt;HTTP 프로토콜 대신&lt;/b&gt; 서버와 브라우저간 &lt;b&gt;웹소켓 프로토콜을 사용&lt;/b&gt;하여 통신&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;웹소켓 요청 헤더와 응답 헤더&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;요청 헤더&lt;/b&gt;&lt;/p&gt;
&lt;pre id=&quot;code_1697613087158&quot; class=&quot;html xml&quot; data-ke-language=&quot;html&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;GET /chat // 반드시 GET 메서드를 사용해야 한다. 
Host: javascript.info
Origin: https://javascript.info
Connection: Upgrade // 클라이언트 측에서 프로토콜을 바꾸고 싶다는 신호
Upgrade: websocket // 어떤걸로 바꾸고 싶은지
Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
Sec-WebSocket-Version: 13&lt;/code&gt;&lt;/pre&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Origin: 클라이언트 오리진, 웹소켓 객체는 기본적으로 cross-origin 요청을 지원한다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Sec-WebSocket-Key: 보안을 위해 &lt;b&gt;브라우저&lt;/b&gt;에서 생성한 키로, 서버는 해당 키를 바탕으로 토큰을 생성하고, 브라우저에게 돌려준다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;응답 헤더&lt;/b&gt;&lt;/p&gt;
&lt;pre id=&quot;code_1697613517619&quot; class=&quot;html xml&quot; data-ke-language=&quot;html&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;101 Switching Protocols // 서버가 프로토콜 전환을 승인하면 응답코드 101 반환
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g= // 요청에서의 Key 값을 계산한 값으로 신원 인증에 필요한 헤더&lt;/code&gt;&lt;/pre&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Sec-WebSocket-Accept: 특별한 알고리즘을 사용해 만든 Sec-WebSocket-Key이다. 이 값을 보고 브라우저는 서버가 진짜 웹소켓 프로토콜을 지원하는지 확인한다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;정리하자면 웹소켓을 사용하겠다는 HTTP 요청을 하고 OK 승인을 받으면 통신 규약을 &lt;b&gt;HTTP에서 웹소켓으로 upgrade&lt;/b&gt; 시키고, 소켓을 뚫어 해당 소켓으로 데이터를 주고받을 수 있게 하는 것이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;Extensions(확장)와 Subprotocols(서브 프로토콜) 헤더&lt;/b&gt;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;웹소켓 통신은 Sec-WebSocket-Extensions와 Sec-WebSocket-Protocol 헤더를 지원한다.&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Sec-WebSocket-Extensions 헤더는 브라우저에 의해 자동 생성되고, 그 값엔 데이터 전송과 관련된 무언가나 웹소켓 프로토콜 기능 확장과 관련된 것들이 나열된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Sec-WebSocket-Protocol 헤더에서는 앞으로 사용하게 될 &lt;b&gt;데이터 포맷&lt;/b&gt;을 확인할 수 있다. 이는 &lt;b&gt;new WebSocket의 &lt;u&gt;두 번째 매개변수&lt;/u&gt;&lt;/b&gt;에 값을 넣어서 설정할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;2. 데이터 전송&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;웹소켓 통신은 &lt;b&gt;frame&lt;/b&gt;이라 불리는 데이터 조각을 사용해 이루어진다. 프레임은 서버와 클라이언트 &lt;b&gt;양측&lt;/b&gt;에서 모두 보낼 수 있다. 참고로 프레임 내 담긴 데이터 종류는 다양하지만 &lt;b&gt;WebSocket.send()&lt;/b&gt; 메서드는 &lt;b&gt;텍스트나 이진 데이터&lt;/b&gt;만 보낼 수 있기 때문에 브라우저 환경에서 개발자는 해당 데이터만 다룬다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;3. close 핸드셰이크&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;데이터 송수신이 완료되면, client와 server 모두 Connection을 종료하기 위한 &lt;b&gt;Frame&lt;/b&gt;을 전송할 수 있다. Connection을 종료하고 싶은 쪽에서 Connection을 종료한다는 frame을 보내면, 상대쪽에서 응답으로 close frame을 전송한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.javascript.info/websocket&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ko.javascript.info/websocket&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;읽어보기 좋은 자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://mingule.tistory.com/60&quot; target=&quot;_blank&quot; rel=&quot;noopener&amp;nbsp;noreferrer&quot;&gt;https://mingule.tistory.com/60&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=MPQHvwPxDUw&amp;amp;list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&amp;amp;index=98&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;우아한 테크톡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://javascript.plainenglish.io/svelte-and-websocket-4a690dc3f66c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;svelte에서 WebSocket 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://tech.kakaoenterprise.com/179&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;카카오워크 음성채팅 웹 개발기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>CS/그 외</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/61</guid>
      <comments>https://1two13.tistory.com/entry/WebSocket%EC%9D%B4%EB%9E%80#entry61comment</comments>
      <pubDate>Fri, 12 Jan 2024 11:16:16 +0900</pubDate>
    </item>
    <item>
      <title>ES Module 동작 방식</title>
      <link>https://1two13.tistory.com/entry/ES-Module-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D</link>
      <description>&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;CommonJS(CJS)&lt;/b&gt;&lt;/h3&gt;
&lt;hr data-ke-style=&quot;style5&quot; data-ke-type=&quot;horizontalRule&quot; /&gt;
&lt;pre id=&quot;code_1704949741445&quot; class=&quot;java&quot; style=&quot;background-color: #f8f8f8; color: #383a42; text-align: start;&quot; data-ke-type=&quot;codeblock&quot; data-ke-language=&quot;javascript&quot;&gt;&lt;code&gt;module.exports = { ... } // 모듈 내보낼 때
const utils = require('utils'); // 모듈 가져올 때&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;NodeJS&lt;/b&gt;에서 지원하는 모듈 방식으로 초기 Node 버전부터 사용되었다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;별도의 설정이 없다면 CJS가 기본값이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;require()는 &lt;b&gt;&lt;u&gt;즉시&lt;/u&gt; 스크립트를 실행&lt;/b&gt;하는 구조이고, &lt;b&gt;동기적&lt;/b&gt;으로 작동하기 때문에 import 순서에 따라 스크립트를 실행하고 module.exports에 설정된 값만을 리턴한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;ES Modules&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;pre id=&quot;code_1704949763420&quot; class=&quot;coffeescript&quot; style=&quot;background-color: #f8f8f8; color: #383a42; text-align: start;&quot; data-ke-type=&quot;codeblock&quot; data-ke-language=&quot;javascript&quot;&gt;&lt;code&gt;export.default = () =&amp;gt; { ... } // 모듈 내보낼 때
import utils from 'utils'; // 모듈 가져올 때&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;ECMAScript&lt;/b&gt;에서 지원하는 방식이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;package.json에 &quot;type&quot;: &quot;module&quot;을 설정해야 사용할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;u&gt;&lt;b&gt;비동기 환경&lt;/b&gt;&lt;/u&gt;에서 실행되기 때문에 &lt;b&gt;스크립트를 바로 실행하지 않고&lt;/b&gt;, &lt;u&gt;&lt;b&gt;import/export 구문을 찾아&lt;/b&gt; &lt;b&gt;스크립트를 파싱&lt;/b&gt;&lt;/u&gt;한다. 참고로 파싱 단계에서는 에러를 감지할 수 있다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;u&gt;&lt;b&gt;모듈을 병렬로&lt;/b&gt;&lt;/u&gt; &lt;b&gt;다운로드&lt;/b&gt;하지만, &lt;b&gt;실행은 순차적&lt;/b&gt;으로 한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;import/export를 &lt;b&gt;지원하지 않는&lt;/b&gt; 브라우저가 있기 때문에 &lt;b&gt;&lt;u&gt;번들러&lt;/u&gt;가 필요&lt;/b&gt;하다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;모듈 (import, expot)&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;모듈은 &lt;b&gt;함수와 변수&lt;/b&gt;를 &lt;b&gt;모듈 스코프&lt;/b&gt;에 넣어 관련있는 값들을 한 곳에 모을 수 있다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그리고 모듈 스코프를 통해 모듈의 함수 사이에서 변수를 공유할 수 있다.&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 코드를 &lt;b&gt;독립적&lt;/b&gt;으로 작동할 수 있는 단위로 나눌 수 있고,&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 코드 조각들을 &lt;b&gt;조합&lt;/b&gt;해 같은 모듈들의 모음으로 다양한 애플리케이션을 만들 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;현재(2023) 활발하게 사용되는 모듈 시스템은 CommonJS(CJS)와 Node.js, EcmaScript modules(ESM)이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;ES 모듈 동작 방식&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;코드들이 작성된 파일 자체는 브라우저가 사용할 수 없다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 분석 후 &lt;b&gt;모듈 레코드&lt;/b&gt;라고 하는 &lt;b&gt;&lt;u&gt;데이터 구조&lt;/u&gt;로 변환&lt;/b&gt;이 필요하다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 그런 후 모듈 레코드를 &lt;b&gt;모듈 인스턴스로 변환&lt;/b&gt;해야 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;인스턴스는 &lt;b&gt;코드&lt;/b&gt;와 &lt;b&gt;상태,&lt;/b&gt; 2가지를 결합한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;여기서 코드는 명령어의 집합, 상태는 그 시점의 실제 변수값이라고 생각하면 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;각 모듈은 모듈 인스턴스가 필요하고, 전체 파일이 모듈 인스턴스의 전체 그래프를 그리는 것을 시작으로 모듈을 불러오게 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;ES 모듈은 3가지 단계로 나뉘어 진행된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. &lt;b&gt;구성&lt;/b&gt; - &lt;b&gt;&lt;u&gt;모든 파일&lt;/u&gt;을 찾아 다운로드&lt;/b&gt;(로더의 역할)하고 &lt;b&gt;모듈 레코드로 구문분석&lt;/b&gt;한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. &lt;b&gt;인스턴스화&lt;/b&gt; - &lt;b&gt;export된 값&lt;/b&gt;을 모두 배치하기 위해 &lt;b&gt;메모리에 있는 공간을 찾는다.&lt;/b&gt;(아직 실제 값을 채우지는 않음) 그 다음 &lt;b&gt;export와 import들이 메모리 공간들을 가리키도록&lt;/b&gt; 한다.(linking)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. &lt;b&gt;평가&lt;/b&gt; - 코드를 실행하여 &lt;b&gt;상자의 값을 변수의 실제 값으로&lt;/b&gt; 채운다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;좀 더 구체적으로 살펴보자.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;1. 구성&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;구성 단계에서는 각 모듈에 대해 3가지 일이 일어난다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 모듈이 들어있는 파일을 어디서 다운로드할지 확인하고(HTML에서는 스크립트 태그를 사용해서 &lt;b&gt;로더&lt;/b&gt;에게 어디에서 진입점 파일을 찾을 수 있는지 알려준다.)&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;&amp;lt;script src=&quot;main.js&quot; type=&quot;module&quot;&amp;gt;&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 파일을 가져오고(&lt;b&gt;url을 통해 다운로드&lt;/b&gt;하거나 &lt;b&gt;파일 시스템&lt;/b&gt;에서 불러오기)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;참고로 여러 모듈이 특정 모듈에 의존하고 있어도 &lt;b&gt;모듈 파일은 1번만 불러 들여진다.&lt;/b&gt;(캐시) 로더는 &lt;b&gt;모듈맵&lt;/b&gt;을 이용해서 캐시를 관리하고, 각 전역은 별도의 모듈맵에서 모듈을 관리하기 때문이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 파일을 &lt;b&gt;모듈 레코드&lt;/b&gt;로 구문분석한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;모듈 레코드가 만들어지고 나면, &lt;b&gt;모듈맵에 추가&lt;/b&gt;된다. 그럼 &lt;b&gt;필요할 때마다&lt;/b&gt; 로더가 모듈맵에서 모듈 레코드를 가져올 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;모든 모듈은 코드 상단에 &quot;use strict&quot;가 있는 것처럼 구문분석된다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;브라우저에서는 스크립트 태그 내부에 type=&quot;module&quot;이라고 적어두면 해당 파일은 모듈로 구문분석해야한다고 인식한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;2. 인스턴스화&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;인스턴스는 &lt;b&gt;코드와 상태를 결합&lt;/b&gt;한다. 상태는 메모리에 있기 때문에 &lt;b&gt;모든 것을 메모리에 연결&lt;/b&gt;한다고도 할 수 있다. 인스턴스화 단계에서는 export/import 한 변수에 대한 모든 인스턴스와 메모리 위치가 연결된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. JS 엔진은 모듈 환경 레코드를 생성하고 이를 통해 모듈 레코드의 변수를 관리한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. &lt;b&gt;&lt;u&gt;모든&lt;/u&gt; export에 대해&lt;/b&gt; 메모리에 있는 상자를 찾는다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 모듈 환경 레코드는 각 export와 연관된 메모리의 상자를 추적한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;참고로 &lt;b&gt;export 된 함수 선언&lt;/b&gt;은 &lt;b&gt;인스턴스화 단계에서 &lt;u&gt;초기화&lt;/u&gt;&lt;/b&gt;가 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;export들을 먼저 연결해&lt;/b&gt;서 import들이 모두 각각의 export들에 연결되는 것을 보장한다. (반면, CommonJS는 &lt;b&gt;&lt;u&gt;전체 export 객체&lt;/u&gt;가 내보낼 때 복사&lt;/b&gt;된다. 그래서 나중에 export하는 모듈이 해당 값을 변경하면, 그 모듈을 import하는 모듈은 해당 변경 사항을 알 수 없다.) 하지만 ES 모듈에서는 &lt;b&gt;라이브 바인딩&lt;/b&gt;이라는 것을 사용해 &lt;b&gt;두 모듈 모두 메모리의 같은 위치&lt;/b&gt;를 가리키게 된다. 라이브 바인딩을 사용하는 이유는 코드를 실행하지 않고 모든 모듈을 연결할 수 있기 때문이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;3. 평가&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;메모리 상자들을 채우는 것이다. &lt;b&gt;JS 엔진&lt;/b&gt;은 함수 외부 코드인 &lt;b&gt;최상위 레벨 코드를 실행&lt;/b&gt;하여 이를 수행한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;혹시나 생길 수 있는 부작용 가능성(평가 도중에 모듈이 서버에 무언가를 요청하는 등..)때문에 &lt;b&gt;모듈은 한 번만 평가&lt;/b&gt;하도록 한다. 이것이 모듈 맵을 사용하는 다른 이유이기도 하다. &lt;b&gt;모듈&lt;/b&gt; &lt;b&gt;맵은&lt;/b&gt; &lt;b&gt;표준 URL로 모듈을 캐시&lt;/b&gt;하기 때문에 각 모듈에 대해 하나의 모듈 레코드만 있어 각 모듈이 한 번만 실행된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li id=&quot;es-modules-만화로-보는-심층-탐구&quot;&gt;&lt;a href=&quot;https://ui.toast.com/weekly-pick/ko_20180402&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ES modules: 만화로 보는 심층 탐구&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>JavaScript/그 외</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/151</guid>
      <comments>https://1two13.tistory.com/entry/ES-Module-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D#entry151comment</comments>
      <pubDate>Thu, 11 Jan 2024 16:33:16 +0900</pubDate>
    </item>
    <item>
      <title>문제를 근본적으로 해결하는 법</title>
      <link>https://1two13.tistory.com/entry/%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EA%B7%BC%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-%EB%B2%95</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;460&quot; data-origin-height=&quot;575&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/chSgIA/btsDhM4GbUu/Y14BjpT6zDQVsxU5pdXzrk/img.jpg&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/chSgIA/btsDhM4GbUu/Y14BjpT6zDQVsxU5pdXzrk/img.jpg&quot; data-alt=&quot;출처: 사진 속&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/chSgIA/btsDhM4GbUu/Y14BjpT6zDQVsxU5pdXzrk/img.jpg&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FchSgIA%2FbtsDhM4GbUu%2FY14BjpT6zDQVsxU5pdXzrk%2Fimg.jpg&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; data-origin-width=&quot;460&quot; data-origin-height=&quot;575&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: 사진 속&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;실제로 개발자로 일을 하면서 문제를 해결하는데에만 급급해, 근본적인 원인을 찾지 못해 누군가 이슈에 대해 깊이 있는 질문을 할 때 제대로 대답하지 못한다는 것에 대한 한계를 느꼈습니다. 그래서 문제를 근본적으로 해결하는 법에 대해 찾아보게 되었고, 좋은 글을 보게 되어 공유합니다. 실제로 저도 이를 직접 개발하면서 활용했고, 스스로도 성장을 많이 하게 되었다는 느낌을 받게 되었습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;문제를 근본적으로 해결하는 flow&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 문제가 &lt;b&gt;어떤 상황&lt;/b&gt;에서 발생하는지 파악하기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 문제가 어디에서 발생하고 있는지 파악하기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 적절한 &lt;b&gt;키워드로 검색&lt;/b&gt;해보기 (구체적 =&amp;gt; 포괄적)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 키워드로 검색해도 해결책을 찾을 수 없다면 &lt;b&gt;주먹구구식 방법&lt;/b&gt; 사용하기&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 문제의 원인과 해결방법 찾기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;6. 문제의 &lt;b&gt;근본적인 원인과 해결방법&lt;/b&gt;을 찾기 (왜에 대한 답을 찾기 위한 여정)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;주먹구구식 방법&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 문제의 원인으로 의심되는 점들을 리스트업&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 하나씩 시도해보기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://fe-developers.kakaoent.com/2023/230420-beyond-solving-problem-part-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;카카오 FE 기술블로그&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>etc/개발 세미나</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/150</guid>
      <comments>https://1two13.tistory.com/entry/%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EA%B7%BC%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-%EB%B2%95#entry150comment</comments>
      <pubDate>Wed, 10 Jan 2024 17:36:35 +0900</pubDate>
    </item>
    <item>
      <title>Svelte 파헤치기</title>
      <link>https://1two13.tistory.com/entry/Svelte-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0</link>
      <description>&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1. 날씬한 Svelte&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;먼저 스벨트는 2016년경에 Rich Harris가 개발한 자바스크립트 웹 애플리케이션 개발 &lt;u&gt;프레임워크&lt;/u&gt;입니다. 즉, 리액트, 뷰, 앵귤러와 같은 웹 프레임워크 대신 쓸 수 있습니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;실행하는 방법은 아주 간단합니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2524&quot; data-origin-height=&quot;976&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/DS9kX/btszUoSBRxG/2yGJK6UkSRh6OKOCqqHng0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/DS9kX/btszUoSBRxG/2yGJK6UkSRh6OKOCqqHng0/img.png&quot; data-alt=&quot;출처: svelte 공식문서&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/DS9kX/btszUoSBRxG/2yGJK6UkSRh6OKOCqqHng0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDS9kX%2FbtszUoSBRxG%2F2yGJK6UkSRh6OKOCqqHng0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;562&quot; height=&quot;217&quot; data-origin-width=&quot;2524&quot; data-origin-height=&quot;976&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: svelte 공식문서&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;2. 왜 Svelte를 써야할까?&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Svelte는 회사에서 사용하고 있어 이번에 처음으로 사용해보게 되었습니다. React를 많이 쓰는 이 시점에 왜 Svelte를 써야하는지 궁금했습니다. 몇 주간 직접 사용해보고, 구글링해본 결과 아래와 같은 근거로 인해 svelte를 사용한다고 생각했습니다. 개인적인 견해 + 공식적인 지표입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;1. 다른 프레임워크보다 더 적은 코드로 같은 기능을 구현할 수 있습니다.&lt;/b&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;아래의 지표를 보면 svelte의 코드 수는 매우 적은 것을 알 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2168&quot; data-origin-height=&quot;1568&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/c1FFmX/btszKEXluRF/OSkUsZmlZuKGmaZ4gS8xYk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/c1FFmX/btszKEXluRF/OSkUsZmlZuKGmaZ4gS8xYk/img.png&quot; data-alt=&quot;코드 라인 개수, 출처:https://www.freecodecamp.org/news/a-realworld-comparison-of-front-end-frameworks-with-benchmarks-2019-update-4be0d3c78075&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/c1FFmX/btszKEXluRF/OSkUsZmlZuKGmaZ4gS8xYk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc1FFmX%2FbtszKEXluRF%2FOSkUsZmlZuKGmaZ4gS8xYk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;690&quot; height=&quot;499&quot; data-origin-width=&quot;2168&quot; data-origin-height=&quot;1568&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;코드 라인 개수, 출처:https://www.freecodecamp.org/news/a-realworld-comparison-of-front-end-frameworks-with-benchmarks-2019-update-4be0d3c78075&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;2. svelte는 웹 애플리케이션 컴파일러입니다.&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;아까 전에 프레임워크라고 언급했었는데 공식문서에서는 &lt;u&gt;컴파일러&lt;/u&gt;라고 소개하고 있습니다. 그 이유는 코드를 런타임에 해석하지 않고, 컴파일 시 &lt;b&gt;미리 최적화된 JS 코드로 변환&lt;/b&gt;하기 때문입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;svelte는 컴파일을 했기 때문에 &lt;b&gt;라이브러리 코드가 거의 없습니다.&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React로 웹 서비스를 빌드, 제작 후 배포하면 유저가 웹 사이트에 들어올 때 애플리케이션을 구성하는 &lt;u&gt;개발자가 작성한 코드&lt;/u&gt;와 &lt;u&gt;react 코드&lt;/u&gt;, 이렇게 총 2가지 종류의 코드를 다운받아야 합니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 Svelte는 코딩 후 배포 시 &lt;b&gt;svelte가 알아서 코드를 분석&lt;/b&gt;하고, &lt;b&gt;브라우저가 바로 이해 가능한&lt;/b&gt; &lt;b&gt;JS 코드로 컴파일&lt;/b&gt;합니다. 즉, 브라우저에게 별도로&lt;b&gt; svelte가 무엇인지 설명할 필요가 없고&lt;/b&gt;, 유저가 애플리케이션 구성 코드 외에 &lt;b&gt;svelte 코드를 또 다운받을 필요가 없습니다&lt;/b&gt;.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이러한 이유로 인해 React는 기본적인 라이브러리 코드가 140kb이지만, svelte는 고작 3kb입니다. 그래서 svelte가 &lt;b&gt;라이브러리가 사라지는 프레임워크&lt;/b&gt;라는 말이 언급되는 것 같습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;3. 스벨트는 로드 시간이 짧습니다.&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;기존의 Angular, React, Vue는 모두 &lt;b&gt;런타임 환경&lt;/b&gt;에서 돌아가기 때문에 &lt;b&gt;해당 프레임워크를 돌리기 위한 &lt;u&gt;엔진&lt;/u&gt;&lt;/b&gt;이 항상 코드에 같이 있어야합니다. 그러다보면 &lt;u&gt;사용하지는 않지만 포함&lt;/u&gt;되어 있는 코드가 있을 수 있고, &lt;u&gt;1줄의 코드&lt;/u&gt; 적용을 위해서라도 반드시 &lt;u&gt;라이브러리&lt;/u&gt;가 전부 포함되어야 합니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 svelte는 &lt;b&gt;꼭 필요한 프레임워크만&lt;/b&gt; 코드에 포함시켜 &lt;b&gt;번들 크기가 작습니다.&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;좀 더 자세히 말하자면, .svelte 파일에 컴포넌트를 정의할 수 있고, 해당 파일에는 JS, HTML,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;CSS&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;등을 넣을 수 있습니다. svelte 컴파일러는 .svelte 파일을 JS와 CSS로 컴파일하고, 이 과정에서 컴파일러는&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;b&gt;꼭 사용하는 기능만&lt;/b&gt;을 코드에 포함시킵니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1776&quot; data-origin-height=&quot;1358&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/b5p8G5/btszK7ZrynJ/Gyvtkagc7aZoKan4TBcB61/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/b5p8G5/btszK7ZrynJ/Gyvtkagc7aZoKan4TBcB61/img.png&quot; data-alt=&quot;빌드 시간, 출처: https://www.freecodecamp.org/news/a-realworld-comparison-of-front-end-frameworks-with-benchmarks-2019-update-4be0d3c78075&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/b5p8G5/btszK7ZrynJ/Gyvtkagc7aZoKan4TBcB61/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb5p8G5%2FbtszK7ZrynJ%2FGyvtkagc7aZoKan4TBcB61%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;643&quot; height=&quot;492&quot; data-origin-width=&quot;1776&quot; data-origin-height=&quot;1358&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;빌드 시간, 출처: https://www.freecodecamp.org/news/a-realworld-comparison-of-front-end-frameworks-with-benchmarks-2019-update-4be0d3c78075&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;4. 가상돔 없이도 반응성을 제공해줍니다.&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이러한 동작이 가능한 이유는&amp;nbsp;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;최상위 수준의 컴포넌트 변수가 변경되는지 추적하고,&amp;nbsp;&lt;/li&gt;
&lt;li&gt;값이 변경되면, 전체 컴포넌트가 아닌 &lt;b&gt;영향을 받는 부분에 포함되는 DOM만 업데이트&lt;/b&gt; 하기 때문입니다.&amp;nbsp;&lt;/li&gt;
&lt;/ol&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;참고로, 1단계에서 &lt;b&gt;&lt;u&gt;함수 내부&lt;/u&gt;에만 있는 변수는 추적하지 않습니다.&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이처럼 다른 대부분의 프레임워크와 달리, &lt;b&gt;애플리케이션 상태와 DOM을 동기화하는 작업&lt;/b&gt;이 필요하지 않기 때문에 더 효율적으로 DOM을 관리할 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Svelte는 &lt;b&gt;변수 값 할당을 계측&lt;/b&gt;하여 돔을 업데이트합니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;=&lt;/b&gt; 연산자를 통해 트리거를 발생시키고, &lt;b&gt;$:&lt;/b&gt; 을 통해 센서를 감지하고, 최종적으로 코드를 통해 반응성 동작을 하게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2005&quot; data-origin-height=&quot;811&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/D7yvB/btszMcMyqzX/ZTNjtEOz2OIO9xPX5vO3H0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/D7yvB/btszMcMyqzX/ZTNjtEOz2OIO9xPX5vO3H0/img.png&quot; data-alt=&quot;출처: 가장 빨리 만나는 스벨트&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/D7yvB/btszMcMyqzX/ZTNjtEOz2OIO9xPX5vO3H0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FD7yvB%2FbtszMcMyqzX%2FZTNjtEOz2OIO9xPX5vO3H0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;734&quot; height=&quot;297&quot; data-origin-width=&quot;2005&quot; data-origin-height=&quot;811&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: 가장 빨리 만나는 스벨트&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2004&quot; data-origin-height=&quot;1745&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/rbdZd/btszMcNl0ub/3gNigjkgX29Zn4Ip8TrVQ0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/rbdZd/btszMcNl0ub/3gNigjkgX29Zn4Ip8TrVQ0/img.png&quot; data-alt=&quot;출처: 가장 빨리 만나는 스벨트&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/rbdZd/btszMcNl0ub/3gNigjkgX29Zn4Ip8TrVQ0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FrbdZd%2FbtszMcNl0ub%2F3gNigjkgX29Zn4Ip8TrVQ0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;746&quot; height=&quot;650&quot; data-origin-width=&quot;2004&quot; data-origin-height=&quot;1745&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: 가장 빨리 만나는 스벨트&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;1.&amp;nbsp;addCount&amp;nbsp;함수 내 &lt;b&gt;할당&lt;/b&gt; 연산으로 트리거가 발동하고,&lt;/li&gt;
&lt;li&gt;2. count의 변화가 센서($:)에 의해 감지되고,&lt;/li&gt;
&lt;li&gt;3. 센서 감지 후, 동작 코드에 따라 콘솔에 메시지를 출력합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;반응성을 사용할 때 주의할 점은 할당에 의해 트리거가 되기 때문에 자바스크립트 배열 메서드를 직접 사용하지 않고, &lt;b&gt;재할당&lt;/b&gt;을 해주는 방식을 사용해야 합니다. 자바스크립트 배열 메소드를 사용하면 Svelte가 변경을 감지하지 못해 &lt;b&gt;자동으로 업데이트가 발생하지 않기&lt;/b&gt; 때문입니다. 또한 배열 메소드를 직접 사용하면 &lt;b&gt;불필요한 렌더링&lt;/b&gt;이 발생되어 성능 저하가 발생할 수 있기 때문입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;5. 양방향 바인딩을 제공합니다.&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;.svelte 파일에 정의된 최상위 수준의 변수가 해당 컴포넌트에 대한 상태이고, 묶인 변수의 값이 변경되면, 연결된 폼의 내용이 업데이트됩니다. 양방향으로 데이터가 바인딩되기 때문에 폼 내용이 변경되면 연결된 변수의 값이 자동으로 변경됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2820&quot; data-origin-height=&quot;1272&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bvgh4o/btszLYOAlt9/ulFAKv4rUbQkt4Z3Mkwdbk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bvgh4o/btszLYOAlt9/ulFAKv4rUbQkt4Z3Mkwdbk/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bvgh4o/btszLYOAlt9/ulFAKv4rUbQkt4Z3Mkwdbk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbvgh4o%2FbtszLYOAlt9%2FulFAKv4rUbQkt4Z3Mkwdbk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;683&quot; height=&quot;308&quot; data-origin-width=&quot;2820&quot; data-origin-height=&quot;1272&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;3. Svelte는 어떻게 동작하는가&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2000&quot; data-origin-height=&quot;2084&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/oxljN/btszNR2ud6z/lIJUQrk3KPmZTgX0oyPJb1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/oxljN/btszNR2ud6z/lIJUQrk3KPmZTgX0oyPJb1/img.png&quot; data-alt=&quot;출처: 스벨트 앤 새퍼 인 액션&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/oxljN/btszNR2ud6z/lIJUQrk3KPmZTgX0oyPJb1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FoxljN%2FbtszNR2ud6z%2FlIJUQrk3KPmZTgX0oyPJb1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;729&quot; height=&quot;760&quot; data-origin-width=&quot;2000&quot; data-origin-height=&quot;2084&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: 스벨트 앤 새퍼 인 액션&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;.svelte 파일에 컴포넌트를 정의합니다. JS, HTML, CSS가 해당 파일 안에 있습니다.&lt;/li&gt;
&lt;li&gt;스벨트 컴파일러는 이러한 파일들을 모아서 bundle.js와 bundle.css 파일로 만듭니다. 각각은 JS 코드와 CSS 규칙만을 담고 있습니다.&lt;/li&gt;
&lt;li&gt;모든 컴포넌트에 영향을 미칠 수 있는 전역 스타일은 global.css 파일에 정의되고, index.html은 global.css 파일과 스벨트 컴파일러가 만든 2개의 번들 파일을 포함합니다.&lt;/li&gt;
&lt;li&gt;웹 브라우저는 HTML 파일을 불러와서 애플리케이션을 실행합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;4. 직접 사용해보면서 느낀 Svelte와 React의 차이점&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;1. 코드가 짧습니다.&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;앞에서도 언급했듯이 코드가 눈에 띄게 짧습니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1720&quot; data-origin-height=&quot;1588&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/uMrPI/btszLm9VBJH/JuxMaazwjxIO3KducEJKm0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/uMrPI/btszLm9VBJH/JuxMaazwjxIO3KducEJKm0/img.png&quot; data-alt=&quot;출처: https://velog.io/@jeonwon&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/uMrPI/btszLm9VBJH/JuxMaazwjxIO3KducEJKm0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FuMrPI%2FbtszLm9VBJH%2FJuxMaazwjxIO3KducEJKm0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;643&quot; height=&quot;594&quot; data-origin-width=&quot;1720&quot; data-origin-height=&quot;1588&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: https://velog.io/@jeonwon&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;2. 별도 라이브러리 없이 반응형 프로그래밍이 가능합니다.&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React에서는 반응형 state를 위해 useState를 사용해야하지만, Svelte는 그저 선언 후 사용하면 됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2139&quot; data-origin-height=&quot;1188&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/CByiy/btszMdknJoK/APcrFzoeYMIUG7ggdFZ1oK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/CByiy/btszMdknJoK/APcrFzoeYMIUG7ggdFZ1oK/img.png&quot; data-alt=&quot;React&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/CByiy/btszMdknJoK/APcrFzoeYMIUG7ggdFZ1oK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCByiy%2FbtszMdknJoK%2FAPcrFzoeYMIUG7ggdFZ1oK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;595&quot; height=&quot;330&quot; data-origin-width=&quot;2139&quot; data-origin-height=&quot;1188&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;React&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2540&quot; data-origin-height=&quot;1064&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bpaazZ/btszKEbY0sH/KnLxxH4IbOQVd5yRzmQNwK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bpaazZ/btszKEbY0sH/KnLxxH4IbOQVd5yRzmQNwK/img.png&quot; data-alt=&quot;Svelte&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bpaazZ/btszKEbY0sH/KnLxxH4IbOQVd5yRzmQNwK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbpaazZ%2FbtszKEbY0sH%2FKnLxxH4IbOQVd5yRzmQNwK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;588&quot; height=&quot;246&quot; data-origin-width=&quot;2540&quot; data-origin-height=&quot;1064&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;Svelte&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;3. 가독성이 높습니다.&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React에서는 반복되는 것을 보여줘야할 때 map을 작성하곤 했는데, svelte에서는 each 구문을 사용하면 됩니다. 개인적으로 key를 사용하지 않아도 되고, map을 사용하지 않아 조금 더 가독성이 좋다고 느껴졌습니다. map을 사용할 때 &lt;b&gt;key에 고유값을 주지 않았다&lt;/b&gt;거나 &lt;b&gt;key를 주지 않았다&lt;/b&gt;거나 하는 오류를 자주 볼 수 있었는데 그런 번거로움이 사라졌다고 생각합니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;531&quot; data-origin-height=&quot;273&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/yc6tY/btszM3hKmPs/5jV1tiI3gv3Me7s7BdLIB1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/yc6tY/btszM3hKmPs/5jV1tiI3gv3Me7s7BdLIB1/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/yc6tY/btszM3hKmPs/5jV1tiI3gv3Me7s7BdLIB1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fyc6tY%2FbtszM3hKmPs%2F5jV1tiI3gv3Me7s7BdLIB1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;611&quot; height=&quot;314&quot; data-origin-width=&quot;531&quot; data-origin-height=&quot;273&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;또한 기본적으로 작성해야하는 &lt;b&gt;보일러 플레이트&lt;/b&gt;가 적고, JS, HTML, CSS를 작성하는 부분이 &amp;lt;script&amp;gt;, &amp;lt;style&amp;gt; 태그 등으로 확실하게 명시되어 있어서 가독성이 좋다고 느꼈습니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;539&quot; data-origin-height=&quot;275&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bi1eeA/btszNS784u0/NByZ1PGphorKIr5GfVCx4K/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bi1eeA/btszNS784u0/NByZ1PGphorKIr5GfVCx4K/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bi1eeA/btszNS784u0/NByZ1PGphorKIr5GfVCx4K/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbi1eeA%2FbtszNS784u0%2FNByZ1PGphorKIr5GfVCx4K%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; data-origin-width=&quot;539&quot; data-origin-height=&quot;275&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;4. 모든건 .svlete 파일 하나로 끝낼 수 있다는 것도 매력적이였습니다. &lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;CSS를 지역 한정으로 쓸 수 있어 네이밍이라던가 CSS가 &lt;b&gt;중복&lt;/b&gt;되어 누락되는 등에 대한 고려를 하지 않아도 되서 좋았습니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;700&quot; data-origin-height=&quot;1434&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cLjZxP/btszUyncJMV/M4bFO1FWfhXrVxvLaBuoQ1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cLjZxP/btszUyncJMV/M4bFO1FWfhXrVxvLaBuoQ1/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cLjZxP/btszUyncJMV/M4bFO1FWfhXrVxvLaBuoQ1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcLjZxP%2FbtszUyncJMV%2FM4bFO1FWfhXrVxvLaBuoQ1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;152&quot; height=&quot;311&quot; data-origin-width=&quot;700&quot; data-origin-height=&quot;1434&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;5. props를 전달하는 과정이 매우 간단합니다.&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그저 export로 props를 전달받고 사용하면 됩니다. React에서 props를 넘겨주고 넘겨받는 코드를 작성해야했던 방식보다는 훨씬 간소화되었다고 생각했습니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2242&quot; data-origin-height=&quot;1266&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cgMXbq/btszUdp85g2/68BeV46DMOBZuoefofcad1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cgMXbq/btszUdp85g2/68BeV46DMOBZuoefofcad1/img.png&quot; data-alt=&quot;React&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cgMXbq/btszUdp85g2/68BeV46DMOBZuoefofcad1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcgMXbq%2FbtszUdp85g2%2F68BeV46DMOBZuoefofcad1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;606&quot; height=&quot;342&quot; data-origin-width=&quot;2242&quot; data-origin-height=&quot;1266&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;React&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1350&quot; data-origin-height=&quot;1272&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cD6CIx/btszLjSUtbr/cA5E5aQTL5d1t09fwAkwK1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cD6CIx/btszLjSUtbr/cA5E5aQTL5d1t09fwAkwK1/img.png&quot; data-alt=&quot;svelte&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cD6CIx/btszLjSUtbr/cA5E5aQTL5d1t09fwAkwK1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcD6CIx%2FbtszLjSUtbr%2FcA5E5aQTL5d1t09fwAkwK1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;579&quot; height=&quot;546&quot; data-origin-width=&quot;1350&quot; data-origin-height=&quot;1272&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;svelte&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;6. 전역 상태를 관리하는 store가 내장되어 있어 별도로 설치가 필요 없습니다.&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React의 경우 Redux와 같은 상태 관리 라이브러리를 설치하여 사용해야했지만, svelte는 자체적으로 store가 내장되어 있습니다. 하지만 더 큰 프로젝트나 관리해야하는 상태가 많은 경우에 RX라는 라이브러리와 같이 사용한다고 합니다. 실제로 svelte 공식문서에서도 RX와의 궁합이 좋다고 나와있더라구요.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;7. sveltekit을 활용하면 라우터 처리가 아주 쉽습니다.&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React에서는 라우터 처리를 위해 browserRouter로 제일 상위 컴포넌트를 감싸고, App 컴포넌트 내에서 Routes와 Route를 사용하여 path에 맞는 element를 보여주기 위한 코드를 작성해줘야 했습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 sveltekit을 활용하면 그저 src에 routes 폴더를 생성한 후 해당 폴더 안에서 경로에 맞는 파일을 작성해주면 됩니다. 또한 &lt;b&gt;+page.ts&lt;/b&gt;를 사용하면 필요한 데이터를 초기에 미리 가져오는 &lt;b&gt;preload&lt;/b&gt; 기능도 사용할 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;그럼에도 불구하고,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;hr data-ke-style=&quot;style5&quot; data-ke-type=&quot;horizontalRule&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이처럼 svelte의 장점이 많은데도 아직까지 이런 의문이 생기는 것 같습니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;1. svelte는 과연 대규모 앱에도 적합한가?&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;애플 뮤직과 이케아 svelte를 사용하고 있는 것을 확인할 수 있습니다. 하지만 아직까지 많은 큰 기업들은 svelte를 사용하고 있지 않습니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;3452&quot; data-origin-height=&quot;1692&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/6jX0d/btszSJDw57b/fWByX3d1x5HyGxCDjdu1Y0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/6jX0d/btszSJDw57b/fWByX3d1x5HyGxCDjdu1Y0/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/6jX0d/btszSJDw57b/fWByX3d1x5HyGxCDjdu1Y0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6jX0d%2FbtszSJDw57b%2FfWByX3d1x5HyGxCDjdu1Y0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;730&quot; height=&quot;358&quot; data-origin-width=&quot;3452&quot; data-origin-height=&quot;1692&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;2. 운영 주체가 기업이 아닌데, 안정적일까?&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;react&lt;/b&gt;는&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;페이스북&lt;/b&gt;이 지원하고 있고,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;기업 내&lt;/b&gt;에서 직접 사용할 목적으로 관리되고 있습니다. 그만큼 계속 유지 및 관리하기 위한 자금이 준비되어 있죠. 하지만 스벨트는&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;b&gt;커뮤니티&lt;/b&gt;&lt;/u&gt;에서 관리되고 있어 핵심 개발자들의 열정이 얼마나 오래갈지 보장할 수 없습니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;3128&quot; data-origin-height=&quot;1722&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/67IjL/btszXKVpULw/Mh31xjOY4QHQwSJfjx3MKK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/67IjL/btszXKVpULw/Mh31xjOY4QHQwSJfjx3MKK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/67IjL/btszXKVpULw/Mh31xjOY4QHQwSJfjx3MKK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F67IjL%2FbtszXKVpULw%2FMh31xjOY4QHQwSJfjx3MKK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;727&quot; height=&quot;400&quot; data-origin-width=&quot;3128&quot; data-origin-height=&quot;1722&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고 자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;가장&lt;span&gt; &lt;/span&gt;빨리&lt;span&gt; &lt;/span&gt;만나는&lt;span&gt; &lt;/span&gt;스벨트&lt;/li&gt;
&lt;li&gt;스벨트&lt;span&gt; &lt;/span&gt;앤&lt;span&gt; &lt;/span&gt;새퍼&lt;span&gt; &lt;/span&gt;인&lt;span&gt; &lt;/span&gt;액션&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.freecodecamp.org/news/a-realworld-comparison-of-front-end-frameworks-with-benchmarks-2019-update-4be0d3c78075&quot;&gt;https://www.freecodecamp.org/news/a-realworld-comparison-of-front-end-frameworks-with-benchmarks-2019-update-4be0d3c78075&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;a href=&quot;https://velog.io/@jeonwon&quot;&gt;https://velog.io/@jeonwon&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>Svelte</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/149</guid>
      <comments>https://1two13.tistory.com/entry/Svelte-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0#entry149comment</comments>
      <pubDate>Mon, 6 Nov 2023 18:45:05 +0900</pubDate>
    </item>
    <item>
      <title>Rest API method 관련 코드 utils로 생성하여 관리하기</title>
      <link>https://1two13.tistory.com/entry/Rest-API-method-%EA%B4%80%EB%A0%A8-%EC%BD%94%EB%93%9C-utils%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%98%EC%97%AC-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;제목 그대로 Rest API 관련 코드들을 method 별로 정리하여 관리하면 추후에 fetch를 통한 통신을 할 때 관리하기에 매우 유용하다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1698633775759&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;import { API_URLS } from '../constants/apis';

/* eslint-disable class-methods-use-this */
class FetchService {
  private baseUrl = API_URLS.BASE;

  private async handleResponse(response: Response) {
    if (!response.ok) {
      const message = await response.text();
      throw new Error(message);
    }
    return response.json();
  }

  async get&amp;lt;T&amp;gt;(endpoint: string): Promise&amp;lt;T&amp;gt; {
    const url = new URL(`${this.baseUrl}${endpoint}`);
    try {
      const response = await fetch(url.toString());
      return await this.handleResponse(response);
    } catch (error) {
      console.error(`Error in GET ${url}: `, error);
      throw error;
    }
  }

  async post&amp;lt;T&amp;gt;(endpoint: string, body?: T) {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      return await this.handleResponse(response);
    } catch (error) {
      console.error(`Error in POST ${this.baseUrl}${endpoint}: `, error);
      throw error;
    }
  }

  async patch&amp;lt;T&amp;gt;(endpoint: string, body?: T) {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      return await this.handleResponse(response);
    } catch (error) {
      console.error(`Error in PATCH ${this.baseUrl}${endpoint}: `, error);
      throw error;
    }
  }

  async delete&amp;lt;T&amp;gt;(endpoint: string, body?: T) {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      return await this.handleResponse(response);
    } catch (error) {
      console.error(`Error in DELETE ${this.baseUrl}${endpoint}: `, error);
      throw error;
    }
  }
}

export default FetchService;&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;다른 컴포넌트에서 사용할 때는 아래와 같은 방식으로 사용해주면 된다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1698633805371&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;import { API_URLS } from '../constants/apis';
import type { EventType } from '../types/Event';
import FetchService from '../utils/fetch';

const Fetch = new FetchService();

const getDetectedEvent = async (id?: number): Promise&amp;lt;EventType[]&amp;gt; =&amp;gt; {
  const result: EventType[] = await Fetch.get&amp;lt;EventType[]&amp;gt;(
    `${API_URLS.EVENT.DETECTION}${id ? `/${id}` : ''}`,
  );
  return result;
};

export default getDetectedEvent;&lt;/code&gt;&lt;/pre&gt;</description>
      <category>Svelte</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/148</guid>
      <comments>https://1two13.tistory.com/entry/Rest-API-method-%EA%B4%80%EB%A0%A8-%EC%BD%94%EB%93%9C-utils%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%98%EC%97%AC-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0#entry148comment</comments>
      <pubDate>Mon, 30 Oct 2023 13:21:16 +0900</pubDate>
    </item>
    <item>
      <title>[svelte] $app/stores에서 제공되는 Page 활용하기</title>
      <link>https://1two13.tistory.com/entry/svelte-appstores%EC%97%90%EC%84%9C-%EC%A0%9C%EA%B3%B5%EB%90%98%EB%8A%94-Page-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;회사에서는 svelte를 메인으로 가져가고 있어서 요 몇주간 사용했는데, react와 다르게 조금 더 편리성을 주는 것 같다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;예를 들어서 console.log로 &lt;b&gt;$page&lt;/b&gt;로 확인해보면 아래와 같은 정보를 가져올 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2044&quot; data-origin-height=&quot;366&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cwMjJQ/btszlt8DT7j/zESL2iWP6v81s0d7mFsSj1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cwMjJQ/btszlt8DT7j/zESL2iWP6v81s0d7mFsSj1/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cwMjJQ/btszlt8DT7j/zESL2iWP6v81s0d7mFsSj1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcwMjJQ%2Fbtszlt8DT7j%2FzESL2iWP6v81s0d7mFsSj1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;843&quot; height=&quot;151&quot; data-origin-width=&quot;2044&quot; data-origin-height=&quot;366&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1698631273937&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;
  import { page } from '$app/stores';

  console.log($page);

  $: isShowNavigation = $page.route.id !== '/camera/[id]';
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그래서 위와 같은 코드로 네비게이션의 유무를 관리할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;data, error, form, params, route, status, url&lt;/b&gt;&amp;nbsp; 등의 정보를 모두 쉽게 확인하고 이를 사용하여 코드를 작성할 수 있기 때문에 유용한거 같다!&lt;/p&gt;</description>
      <category>Svelte</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/147</guid>
      <comments>https://1two13.tistory.com/entry/svelte-appstores%EC%97%90%EC%84%9C-%EC%A0%9C%EA%B3%B5%EB%90%98%EB%8A%94-Page-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0#entry147comment</comments>
      <pubDate>Mon, 30 Oct 2023 11:04:56 +0900</pubDate>
    </item>
    <item>
      <title>[원티드 9월] 데스크탑 웹사이트 개발하기 - 사이트 최적화</title>
      <link>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-9%EC%9B%94-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1280&quot; data-origin-height=&quot;727&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/nJyHl/btst6oy4FMz/cYi6sRnvLlB1vkKEtIWxK0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/nJyHl/btst6oy4FMz/cYi6sRnvLlB1vkKEtIWxK0/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/nJyHl/btst6oy4FMz/cYi6sRnvLlB1vkKEtIWxK0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnJyHl%2Fbtst6oy4FMz%2FcYi6sRnvLlB1vkKEtIWxK0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;805&quot; height=&quot;458&quot; data-origin-width=&quot;1280&quot; data-origin-height=&quot;727&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;원티드에서 반응형 웹 사이트 관련된 강의가 있어서 참여하게 되었다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;평소에 반응형 웹 사이트에 관심이 많았기 때문에 아주 흥미로웠다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;브라우저 렌더링 원리&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. HTML을 파싱해서 &lt;b&gt;DOM 트리&lt;/b&gt;를 구축합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. CSS를 파싱해서 &lt;b&gt;CSSOM 트리&lt;/b&gt;를 구축합니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. DOM과 CSSOM을 결합해서 &lt;b&gt;Render Tree&lt;/b&gt;를 구축합니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. Viewport를 기반으로 Render Tree의 각 노드가 가지는 정확한 &lt;b&gt;위치&lt;/b&gt;와 &lt;b&gt;크기&lt;/b&gt;를 계산하는 &lt;b&gt;Layout 단계&lt;/b&gt;를 거칩니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 계산한 위치와 크기를 기반으로 &lt;b&gt;실제 pixel&lt;/b&gt;을 화면에 그리는 &lt;b&gt;Paint 단계&lt;/b&gt;를 거칩니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1194&quot; data-origin-height=&quot;494&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/rO1Iy/btsu0r8Bn0h/6kQ2M5AhkYl0vDF4MR86Ak/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/rO1Iy/btsu0r8Bn0h/6kQ2M5AhkYl0vDF4MR86Ak/img.png&quot; data-alt=&quot;출처: beomy.github.io&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/rO1Iy/btsu0r8Bn0h/6kQ2M5AhkYl0vDF4MR86Ak/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FrO1Iy%2Fbtsu0r8Bn0h%2F6kQ2M5AhkYl0vDF4MR86Ak%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;829&quot; height=&quot;343&quot; data-origin-width=&quot;1194&quot; data-origin-height=&quot;494&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: beomy.github.io&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;사이트 최적화&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이때, 사이트를 최적화하기 위해서는 위의 Layout과 Paint 단계, 즉 Reflow와 Repaint를 최소화시켜야 합니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Reflow는 아래와 같은 상황에서 발생합니다.&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;화면의 레이아웃이 변화 되었을 때&lt;/li&gt;
&lt;li&gt;DOM 노드의 추가, 제거, 위치, 박스 모델의 변경이 있을 때&lt;/li&gt;
&lt;li&gt;CSS3 애니메이션과 트랜지션이 발생했을 때&lt;/li&gt;
&lt;li&gt;폰트, 텍스트 내용이 변경되었을 때&lt;/li&gt;
&lt;li&gt;이미지 크기가 변경되었을 때&lt;/li&gt;
&lt;li&gt;offset, scrollTop, scrollLeft와 같은 계산된 스타일 정보를 요청할 때&lt;/li&gt;
&lt;li&gt;페이지를 초기 렌더링할 때&lt;/li&gt;
&lt;li&gt;윈도우를 리사이징&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Repaint는 아래와 같은 상황에서 발생합니다.&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;화면의 디자인이 변화되었을 때&lt;/li&gt;
&lt;li&gt;opacity, background-color, visibility, outline 등의 디자인 관련 스타일이 변경되었을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;정리하자면,&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 인라인 스타일을 사용하지 않기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. HTML 구조를 깊게 짜지 않기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. CSS 셀렉터를 짧게 사용하기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 렌더트리 생성 이후 박스 모델 변경하지 않기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 애니메이션이 있는 요소는 position: fixed | absolute, transfrom, opacity를 사용하고, will-change 지정하기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;6. JS로 스타일을 변경할 때는 display:none으로 숨긴 후 변경, 노출하기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;7. JS는 &amp;lt;/body&amp;gt; 바로 앞에 작성하기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;사이트 최적화 - preload&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;preload를 사용해 현재 페이지에서 사용할 소스를 미리 로딩할 수 있습니다.&lt;/span&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;단, 현재 페이지에서 3초 이내에 반드시 사용되는 리소스에만 사용해야하고, 남발하면 리퀘스트를 늘리기 때문에 오히려 악영향을 끼칠 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1695297839532&quot; class=&quot;html xml&quot; data-ke-language=&quot;html&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;&amp;lt;link rel='preload' as='script' href='preload.js'&amp;gt;
&amp;lt;link rel='preload' as='stlye' href='preload.css'&amp;gt;
&amp;lt;link rel='preload' as='document' href='preload.html'&amp;gt;
&amp;lt;link rel='preload' as='image' href='preload.png'&amp;gt;
&amp;lt;link rel='preload' as='font' crossorigin type='font/woff2'&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;사이트 최적화 - preconnect&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;현재 페이지에서 사용할 외부 도메인을 브라우저가 미리 준비해주는 것입니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;CPU에 부하를 줄 수 있다는 단점이 있습니다. 특히 https인 경우에는 더 많은 부하가 발생합니다. 또한 사용자가 10초 이상 보지 않는 짧은 내용의 콘텐츠에는 부적절합니다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1695297912822&quot; class=&quot;html xml&quot; data-ke-language=&quot;html&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;&amp;lt;link rel='preconnect' href='https://fonts.goggleapis.com'&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;사이트 최적화 - prefetch&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;지금 보는 콘텐츠가 아닌, 사용자가 &lt;b&gt;다음에 볼 콘텐츠&lt;/b&gt;에서 필요한 내용을 미리 로딩해줍니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1695298002427&quot; class=&quot;html xml&quot; data-ke-language=&quot;html&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;&amp;lt;link rel='prefetch' as='script' href='preload.js'&amp;gt;
&amp;lt;link rel='prefetch' as='stlye' href='preload.css'&amp;gt;
&amp;lt;link rel='prefetch' as='document' href='preload.html'&amp;gt;
&amp;lt;link rel='prefetch' as='image' href='preload.png'&amp;gt;
&amp;lt;link rel='prefetch' as='font' crossorigin type='font/woff2'&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;사이트 최적화 - async&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;JS 파일을 병렬 로딩하며, 로딩되면 html 파싱을 멈추고, JS를 먼저 실행한 후에 파싱을 이어서 진행합니다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;따라서, DOM에 영향을 주지 않는 JS 파일에 적합합니다. 예를 들어, jquery, Bootstrap과 같은 라이브러리가 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;단, 실행 순서가 보장되지 않기 때문에, 순서를 보장하기 위해서는 자바스크립트로 동적 코드를 삽입하고 값을 false로 설정해줘야 합니다. script.async = false&lt;/p&gt;
&lt;pre id=&quot;code_1695298183609&quot; class=&quot;html xml&quot; data-ke-language=&quot;html&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;&amp;lt;script src='async1.js' async&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;사이트 최적화 - defer&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;병렬 로딩을 하지만 &lt;b&gt;HTML 파싱이 끝난 후&lt;/b&gt;에 실행합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;defer는 &amp;lt;/body&amp;gt; 앞에 코드를 넣은 것과 같으나, 간혹 head 영역 안에 JS 관련 코드를 넣어야 하는 경우에 유용합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;주로, JS 파일의 용량이 크거나, 파싱 후 바로 실행시켜야 하는 경우에 사용합니다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1695298297080&quot; class=&quot;html xml&quot; data-ke-language=&quot;html&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;&amp;lt;script src='defer.js' defer&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://beomy.github.io/tech/browser/reflow-repaint/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://beomy.github.io/tech/browser/reflow-repaint/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>etc/개발 세미나</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/146</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-9%EC%9B%94-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94#entry146comment</comments>
      <pubDate>Thu, 21 Sep 2023 21:15:28 +0900</pubDate>
    </item>
    <item>
      <title>[원티드 9월] 태블릿 웹사이트 개발하기</title>
      <link>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-9%EC%9B%94-%ED%83%9C%EB%B8%94%EB%A6%BF-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1280&quot; data-origin-height=&quot;727&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/br8wbc/btsud0RkQP4/ygCxOJUiC7g0YfzTycnfD1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/br8wbc/btsud0RkQP4/ygCxOJUiC7g0YfzTycnfD1/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/br8wbc/btsud0RkQP4/ygCxOJUiC7g0YfzTycnfD1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbr8wbc%2Fbtsud0RkQP4%2FygCxOJUiC7g0YfzTycnfD1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;805&quot; height=&quot;458&quot; data-origin-width=&quot;1280&quot; data-origin-height=&quot;727&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;원티드에서 반응형 웹 사이트 관련된 강의가 있어서 참여하게 되었다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;평소에 반응형 웹 사이트에 관심이 많았기 때문에 아주 흥미로웠다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;미디어쿼리 기본&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. HTML link 태그로 사용&lt;/p&gt;
&lt;pre id=&quot;code_1694913475789&quot; class=&quot;html xml&quot; data-ke-language=&quot;html&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;&amp;lt;link rel='stylesheet' type='text/css' media='조건' href='style.css'&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. CSS @media 키워드로 사용&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;@media only all and (조건) and (조건) {}&lt;/blockquote&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;only: 특정 미디어에만 적용하는 경우, screen | print를 지정하는 경우&lt;/li&gt;
&lt;li&gt;all(&lt;b&gt;기본값&lt;/b&gt;, 생략 가능): 미디어 설정, screen | print 를 주로 사용&lt;/li&gt;
&lt;li&gt;and: 미디어쿼리의 조건은 모두 and 키워드로 연결&lt;/li&gt;
&lt;li&gt;조건
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;반드시 괄호 안에 조건을 입력해야 함&lt;/li&gt;
&lt;li&gt;min: 최소값이 일치할 때, &lt;b&gt;입력한 사이즈 &lt;u&gt;이상부터&lt;/u&gt;&lt;/b&gt; 적용(확장 개념)&lt;/li&gt;
&lt;li&gt;max: 최대값이 일치할 때, &lt;b&gt;입력한 사이즈 &lt;u&gt;이하까지&lt;/u&gt;&lt;/b&gt; 적용(축소 개념)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;미디어쿼리 분기&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1870&quot; data-origin-height=&quot;864&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/d48Bbh/btsuemUeipn/hHebhu62fAx7orBqdFt8K1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/d48Bbh/btsuemUeipn/hHebhu62fAx7orBqdFt8K1/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/d48Bbh/btsuemUeipn/hHebhu62fAx7orBqdFt8K1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd48Bbh%2FbtsuemUeipn%2FhHebhu62fAx7orBqdFt8K1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;845&quot; height=&quot;390&quot; data-origin-width=&quot;1870&quot; data-origin-height=&quot;864&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;미디어쿼리 활용&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 고해상도 디스플레이가 아닌 경우&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;@media screen and (-webkit-max-device-pixel-ratio: 1) {}&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 기기가 세로인 경우&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;@media screen and (orientation:portrait) {}&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 기기가 가로인 경우&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;@media screen and (orientation:landscape) {}&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 입력 방법이 hover을 지원하지 않는 경우, 오직 터치스크린&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;a href=&quot;https://codepen.io/marshall-ku/pen/jOGOdWa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codepen.io/marshall-ku/pen/jOGOdWa&lt;/a&gt;&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;@media (any-hover: none) {}&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;태블릿 구간 설정&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;@media (min-width: 768px) {}&lt;/blockquote&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;일반적으로 768px부터 적용(아이패드 세로 사이즈 기준)&lt;/li&gt;
&lt;li&gt;0 ~ 767px까지는 모바일, 768px부터 태블릿&lt;/li&gt;
&lt;li&gt;768px은 스마트폰 가로 사이즈 중복 구간이 발생되기 떄문에 정확히 태블릿에만 적용하기 위해서는 다른 조건을 추가 해야함&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;s&gt;강의를 들으면서 느끼는건데, 이전에 했던 프로젝트에서 반응형을 적용하지 않았던 프로젝트를 반응형으로 구축을 해볼 예정이다.&lt;/s&gt;&lt;/p&gt;</description>
      <category>etc/개발 세미나</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/145</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-9%EC%9B%94-%ED%83%9C%EB%B8%94%EB%A6%BF-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0#entry145comment</comments>
      <pubDate>Sun, 17 Sep 2023 15:24:01 +0900</pubDate>
    </item>
    <item>
      <title>[원티드 9월] 모바일 웹사이트 개발하기</title>
      <link>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-9%EC%9B%94-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1280&quot; data-origin-height=&quot;727&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/mEJdE/btstXy0NoN6/oeFqNc7JIpELLUKOS2kKn0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/mEJdE/btstXy0NoN6/oeFqNc7JIpELLUKOS2kKn0/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/mEJdE/btstXy0NoN6/oeFqNc7JIpELLUKOS2kKn0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmEJdE%2FbtstXy0NoN6%2FoeFqNc7JIpELLUKOS2kKn0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;805&quot; height=&quot;458&quot; data-origin-width=&quot;1280&quot; data-origin-height=&quot;727&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;원티드에서 반응형 웹 사이트 관련된 강의가 있어서 참여하게 되었다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;평소에 반응형 웹 사이트에 관심이 많았기 때문에 아주 흥미로웠다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Mobile first&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;데스크탑부터 작업을 하게 되면 오버라이딩이 많이 발생되고, 복잡한 구조를 줄이기 보다 단순한 구조를 늘리는 것이 쉽기 때문에 모바일을 먼저 만드는 것을 추천한다고 합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;참고로 오버라이딩은 객체 지향 프로그래밍에서 사용되는 개념으로, 상속 관계에 있는 클래스들 간의 메서드를 재정의하는 과정입니다. 주로 부모 클래스에서 정의된 메서드를 자식 클래스에서 동일한 메서드명으로 다시 구현하면, 자식 클래스에서의 메서드가 부모 클래스의 메서드를 오버라이딩하게 됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;viewport&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1920&quot; data-origin-height=&quot;700&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/NjUYV/btstNAsvdF8/Kq0OPh0IDDPDRhSIsSZvUK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/NjUYV/btstNAsvdF8/Kq0OPh0IDDPDRhSIsSZvUK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/NjUYV/btstNAsvdF8/Kq0OPh0IDDPDRhSIsSZvUK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FNjUYV%2FbtstNAsvdF8%2FKq0OPh0IDDPDRhSIsSZvUK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;844&quot; height=&quot;308&quot; data-origin-width=&quot;1920&quot; data-origin-height=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;위의 코드는 VSCode에서 !를 통해 자동 생성되는 HTML 기본 코드입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;viewport는 &lt;b&gt;모바일 브라우저&lt;/b&gt;가 웹 페이지를 어떻게 렌더링 해야 하는지 설정해줍니다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;width는 &lt;b&gt;렌더링 영역의 크기&lt;/b&gt;를 설정하고, 보통은 &lt;b&gt;device-width&lt;/b&gt;로 설정합니다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;initial-scale은 웹 페이지가 &lt;b&gt;처음 로딩&lt;/b&gt;될 때 &lt;b&gt;줌 레벨&lt;/b&gt;을 제어해줍니다. 하지만 최근에는 브라우저가 무시를 한다고 합니다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;웹 표준&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;World Wide Web과 관련된 기술의 표준 문법을 지키는 웹 개발 기법입니다. 즉, HTML, CSS, JS의 표준 문법을 지켜서 코드를 작성하는 것입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;웹 접근성과 함께 사용되는 경우가 많지만 서로 다른 개념입니다. 하지만 웹 표준을 잘 지키면 웹 접근성은 90% 정도는 지켜진다고 합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;block 요소와 inline 요소, 그리고 inline-block&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1336&quot; data-origin-height=&quot;413&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/t7F7Y/btstRKalk9w/Y22lBNFp7kroXvBUuENYOK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/t7F7Y/btstRKalk9w/Y22lBNFp7kroXvBUuENYOK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/t7F7Y/btstRKalk9w/Y22lBNFp7kroXvBUuENYOK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Ft7F7Y%2FbtstRKalk9w%2FY22lBNFp7kroXvBUuENYOK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;850&quot; height=&quot;263&quot; data-origin-width=&quot;1336&quot; data-origin-height=&quot;413&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;추가로 display: inline-block;은 콘텐츠 안에 생성되면서 공간도 생성이 가능합니다. 따라서 padding, margin, height 속성을 줄 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;박스 모델&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;722&quot; data-origin-height=&quot;285&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bTI0qt/btstXBDo52t/HUVLpb3EzMlnxonXBcQP31/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bTI0qt/btstXBDo52t/HUVLpb3EzMlnxonXBcQP31/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bTI0qt/btstXBDo52t/HUVLpb3EzMlnxonXBcQP31/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbTI0qt%2FbtstXBDo52t%2FHUVLpb3EzMlnxonXBcQP31%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; data-origin-width=&quot;722&quot; data-origin-height=&quot;285&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;박스가 content-box일 때, Child containder의 전체 박스 크기는 부모 컨테이너의 넓이인 200px에 border(10px * 2)와 padding(5px * 2)를 모두 더한 값인 230px이 됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;724&quot; data-origin-height=&quot;287&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/kFlx5/btstM2phqm0/rWIkkKCQpkOIH44ZgvmVnK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/kFlx5/btstM2phqm0/rWIkkKCQpkOIH44ZgvmVnK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/kFlx5/btstM2phqm0/rWIkkKCQpkOIH44ZgvmVnK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkFlx5%2FbtstM2phqm0%2FrWIkkKCQpkOIH44ZgvmVnK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; data-origin-width=&quot;724&quot; data-origin-height=&quot;287&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;반대로, 박스가border-box일 때, Child containder의 width 크기는 부모 컨테이너의 넓이인 200px에서 border와 padding을 제외해야하기 때문에 border(10px * 2)와 padding(5px * 2)를 모두 뺀 값인 170px이 됩니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;참고로 input 요소들은 border-box로 되어있습니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Reset CSS&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;코드를 작성하면서 필요한 부분의 reset css만 구성해서 사용하는 것을 추천한다고 합니다. 특히 전체 선택자는 필요없는 곳에 영향을 줄 수 있기 때문에 지양하는 것이 좋다고 합니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;font-size를 설정할 때 보통 62.5%로 설정하는데, 그 이유는 rem 단위로 설정하기 위해서 입니다. rem은 최상위 요소의 폰트 사이즈를 기준으로 크기를 결정하는데, 62.5%로 설정하면 1rem은 10px이기 때문에, 이후에 폰트 사이즈를 설정할 때 1.2rem은 12px, 1.5rem은 15px... 과 같은 방식으로 쉽게 작성할 수 있기 때문입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Float을 해제하는 방법&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;float 속성은 &lt;b&gt;float이 지정되길 원하는 &lt;u&gt;자식 요소&lt;/u&gt;&lt;/b&gt;들에게 주면 됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;float을 사용했다면 &lt;b&gt;문서의 흐름&lt;/b&gt;(왼쪽에서 오른쪽, 위에서 아래)이 깨지기 때문에 float을 해제해야하는데, 해지하는 방법으로는 크게 5가지가 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;1. clear: both;&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이때, &lt;b&gt;float을 적용한 요소가 끝나는 지점&lt;/b&gt;에서 적용을 해야 float이 해제됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imagegridblock&quot;&gt;
  &lt;div class=&quot;image-container&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bJW5gF/btstRIjnRt8/K6T7FfmD6C42S7Gt8Ca311/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bJW5gF/btstRIjnRt8/K6T7FfmD6C42S7Gt8Ca311/img.png&quot; data-origin-width=&quot;889&quot; data-origin-height=&quot;611&quot; data-is-animation=&quot;false&quot; style=&quot;width: 47.2122%; margin-right: 10px;&quot; data-widthpercent=&quot;47.77&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bJW5gF/btstRIjnRt8/K6T7FfmD6C42S7Gt8Ca311/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbJW5gF%2FbtstRIjnRt8%2FK6T7FfmD6C42S7Gt8Ca311%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot;/&gt;&lt;/span&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bFn2wE/btstNBSEcmI/mnJUNHkh4oURkLYqkZboj0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bFn2wE/btstNBSEcmI/mnJUNHkh4oURkLYqkZboj0/img.png&quot; data-origin-width=&quot;1836&quot; data-origin-height=&quot;1154&quot; data-is-animation=&quot;false&quot; style=&quot;width: 51.625%;&quot; data-widthpercent=&quot;52.23&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bFn2wE/btstNBSEcmI/mnJUNHkh4oURkLYqkZboj0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbFn2wE%2FbtstNBSEcmI%2FmnJUNHkh4oURkLYqkZboj0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;왼쪽은 이미지가 깨지는 것을 확인할 수 있고, 오른쪽은 background-color가 정상적으로 적용된 것을 확인할 수 있습니다. 하지만 빈 태그를 사용해야한다는 단점이 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;2. :after 와 clear:both; 같이 주기&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;위에서 언급한 단점을 해결하기 위해서는 :after를 같이 사용해주면 됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1159&quot; data-origin-height=&quot;361&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/dqk3hw/btstTruI1Ir/mpsnjkKEzbA1CIK5KTuvXK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/dqk3hw/btstTruI1Ir/mpsnjkKEzbA1CIK5KTuvXK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/dqk3hw/btstTruI1Ir/mpsnjkKEzbA1CIK5KTuvXK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdqk3hw%2FbtstTruI1Ir%2FmpsnjkKEzbA1CIK5KTuvXK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;838&quot; height=&quot;261&quot; data-origin-width=&quot;1159&quot; data-origin-height=&quot;361&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;3. overflow:auto; 또는 overflow:hidden;&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;overflow:auto;를 더 지향합니다. 그 이유는 hidden을 사용했을 때 원하는 속성이 잘려서 보이게 되는 케이스가 발생할 수 있기 때문입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;4. float과 width: 100%; 같이 주기&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;float이 해제된 것처럼 보이게 할 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;876&quot; data-origin-height=&quot;360&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/biTykT/btstOgubuYU/8fi7h8BLFOpOMKFBya84Yk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/biTykT/btstOgubuYU/8fi7h8BLFOpOMKFBya84Yk/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/biTykT/btstOgubuYU/8fi7h8BLFOpOMKFBya84Yk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbiTykT%2FbtstOgubuYU%2F8fi7h8BLFOpOMKFBya84Yk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;831&quot; height=&quot;342&quot; data-origin-width=&quot;876&quot; data-origin-height=&quot;360&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;5. display: flow-root;&lt;/blockquote&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;870&quot; data-origin-height=&quot;355&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cpf32b/btstX0JTRvt/j7v6EzDy9NH1X0hvF7DMaK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cpf32b/btstX0JTRvt/j7v6EzDy9NH1X0hvF7DMaK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cpf32b/btstX0JTRvt/j7v6EzDy9NH1X0hvF7DMaK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcpf32b%2FbtstX0JTRvt%2Fj7v6EzDy9NH1X0hvF7DMaK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;838&quot; height=&quot;342&quot; data-origin-width=&quot;870&quot; data-origin-height=&quot;355&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Position&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;관련 속성: top, left, bottom, right, z-index&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%; height: 108px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot; data-ke-style=&quot;style12&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;문서 흐름&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;관련 속성&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;스크롤&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;기준&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;static(기본)&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;O&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;X&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;O&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;relative&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;&lt;b&gt;O&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;O&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;O&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 19px;&quot;&gt;&lt;b&gt;자신&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 17px;&quot;&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;absolute&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;X&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;O&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;O&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;&lt;b&gt;상위(단, &lt;u&gt;position을 가지고 있는 가장 가까운&lt;/u&gt;, 없다면 body 기준)&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 17px;&quot;&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;fixed&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;X&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;O&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;X&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;&lt;b&gt;body&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 17px;&quot;&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;sticky(relative + fixed)&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;⃤&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;O&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;⃤&lt;/td&gt;
&lt;td style=&quot;width: 20%; text-align: center; height: 17px;&quot;&gt;&lt;b&gt;자신&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;단, sticky는 &lt;b&gt;부모요소에 overflow 속성이 적용되어 있으면 작동하지 않고&lt;/b&gt;, &lt;b&gt;부모요소의 &lt;u&gt;height&lt;/u&gt;&lt;/b&gt; 값이 정해져야 합니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Flex &amp;amp; Grid&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;float &amp;amp; position과 다른 점은 &lt;u&gt;&lt;b&gt;부모 요소&lt;/b&gt;&lt;/u&gt;에서 제어한다는 점입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;Flex&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;justify: 메인축을 설정합니다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;align: 크로스축 설정&lt;/li&gt;
&lt;li&gt;flex-direction: row 또는 column에 따라 메인축과 크로스축이 바뀜&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-filename=&quot;blob&quot; data-origin-width=&quot;1946&quot; data-origin-height=&quot;668&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bd1062/btstX99sQiI/jn9kGnHpZpNsZ82mx4gvPk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bd1062/btstX99sQiI/jn9kGnHpZpNsZ82mx4gvPk/img.png&quot; data-alt=&quot;출처: 1분코딩&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bd1062/btstX99sQiI/jn9kGnHpZpNsZ82mx4gvPk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbd1062%2FbtstX99sQiI%2Fjn9kGnHpZpNsZ82mx4gvPk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;839&quot; height=&quot;288&quot; data-filename=&quot;blob&quot; data-origin-width=&quot;1946&quot; data-origin-height=&quot;668&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: 1분코딩&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;Grid&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;바둑판&lt;/b&gt;을 연상하면 됩니다. 그래서 바둑판과 같은 구조를 잡을 때는 Grid를, 그 외에는Flex를 사용하면 됩니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Grid는 두 방향(가로-세로)으로 이루어진 2차원 레이아웃 시스템이고, Flex는 한 방향(가로 또는 세로)으로 이루어진 1차원 레이아웃 시스템이기 때문입니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1444&quot; data-origin-height=&quot;1098&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/qfAEV/btst0v47QUl/toHmrQ06tFKK6KFVklcN71/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/qfAEV/btst0v47QUl/toHmrQ06tFKK6KFVklcN71/img.png&quot; data-alt=&quot;출처: 1분코딩&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/qfAEV/btst0v47QUl/toHmrQ06tFKK6KFVklcN71/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqfAEV%2Fbtst0v47QUl%2FtoHmrQ06tFKK6KFVklcN71%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;816&quot; height=&quot;620&quot; data-origin-width=&quot;1444&quot; data-origin-height=&quot;1098&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: 1분코딩&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;유용한 사이트&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codecademy.com/catalog/language/html-css&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;codecademy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.khanacademy.org/computing/computer-programming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;khanacademy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;css-tricks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://studiomeal.com/archives/533&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1분코딩 Grid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>etc/개발 세미나</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/144</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-9%EC%9B%94-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0#entry144comment</comments>
      <pubDate>Fri, 15 Sep 2023 11:52:02 +0900</pubDate>
    </item>
    <item>
      <title>구름톤 챌린지 4주차 학습 일기 v2 - Set과 Array의 시간복잡도 비교</title>
      <link>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-4%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0-v2-Set%EA%B3%BC-Array%EC%9D%98-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B9%84%EA%B5%90</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bLg8yH/btstkqXqoXV/4aAzVKv1ay1TloY7PXLhy0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bLg8yH/btstkqXqoXV/4aAzVKv1ay1TloY7PXLhy0/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bLg8yH/btstkqXqoXV/4aAzVKv1ay1TloY7PXLhy0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbLg8yH%2FbtstkqXqoXV%2F4aAzVKv1ay1TloY7PXLhy0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;839&quot; height=&quot;470&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;궁금한 점&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;알고리즘을 풀 때, 특정 값을 찾기 위해서 배열을 주로 사용하는데, 시간복잡도가 최악의 경우 배열의 길이만큼 걸릴 수 있기 때문에 비효율적이라는 생각이 들었다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그래서 이걸 Set으로 관리하면 시간 복잡도가 줄어들지 않을까?라는 생각이 들었고, 내 생각이 맞는지 &lt;span style=&quot;font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Apple SD Gothic Neo', Arial, sans-serif; letter-spacing: 0px;&quot;&gt;알아보기 위해 정리하게 되었다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Set&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Set은 중복되지 않는 값을 저장하는 자료구조이다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Set은 &lt;b&gt;내부적으로 해시 테이블과 같은 자료구조&lt;/b&gt;를 사용해서 값을 저장한다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;값을 찾을 때 &lt;b&gt;O(1)&lt;/b&gt;의 시간복잡도로 검색할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Array&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;순서대로 값을 저장하는 자료구조이다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;중복 여부에 대한 제약은 없다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;배열의 각 요소를 순회하며 값을 찾아야 하기 때문에, &lt;b&gt;최악의 경우&lt;/b&gt; 배열의 길이에 비례하는 &lt;b&gt;O(n)&lt;/b&gt;이 소요된다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;결론&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;정리하자면, Set은 값의 존재 여부를 빠르게 파악할 수 있고, 해시 테이블을 사용해서 중복을 허용하지 않고 데이터를 저장한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 배열은 배열의 길이가 커질수록 그 길이만큼 검색 시간이 증가하기 때문에 Set보다 더 많은 시간 복잡도가 소요된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;s&gt;결론적으로 내 생각이 맞았다!&lt;/s&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;</description>
      <category>etc/[구름] 구름톤 챌린지</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/143</guid>
      <comments>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-4%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0-v2-Set%EA%B3%BC-Array%EC%9D%98-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B9%84%EA%B5%90#entry143comment</comments>
      <pubDate>Sun, 10 Sep 2023 19:21:31 +0900</pubDate>
    </item>
    <item>
      <title>[원티드 9월] 반응형 웹사이트 기초</title>
      <link>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-9%EC%9B%94-%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B8%B0%EC%B4%88</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2494&quot; data-origin-height=&quot;1418&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/Usjqr/btstkU5GCcz/kCJbUxsHEWCeLmyHAnLd4K/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/Usjqr/btstkU5GCcz/kCJbUxsHEWCeLmyHAnLd4K/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/Usjqr/btstkU5GCcz/kCJbUxsHEWCeLmyHAnLd4K/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUsjqr%2FbtstkU5GCcz%2FkCJbUxsHEWCeLmyHAnLd4K%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;805&quot; height=&quot;458&quot; data-origin-width=&quot;2494&quot; data-origin-height=&quot;1418&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;원티드에서 반응형 웹 사이트 관련된 강의가 있어서 참여하게 되었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;평소에 반응형 웹 사이트에 관심이 많았기 때문에 아주 흥미로웠다.&amp;nbsp;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;반응형 웹 사이트&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;반응형 웹사이트는, 기기의 화면의 크기 맞춰 &lt;b&gt;자동&lt;/b&gt;으로 레이아웃 및 콘텐츠 구성하는 개발방법이다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;아래와 같은 이유로 중요성이 증가했다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 스마트폰의 대중화로 인해 중요성 인식&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 인터넷에 접속되는 기기가 다양해지면서 더 다양한 스크린에 대응해야 하는 이슈&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp; &amp;nbsp; ex. 스마트폰, 랩탑, PC, 워치, 티비, 자동차, 냉장고&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&amp;nbsp;&lt;/h3&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;반응형 웹 사이트 범위&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. 화면 크기(viewport)&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1282&quot; data-origin-height=&quot;438&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/nsmsz/btstqFfj9M6/2BGzk32roKI3kdGlDS55nK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/nsmsz/btstqFfj9M6/2BGzk32roKI3kdGlDS55nK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/nsmsz/btstqFfj9M6/2BGzk32roKI3kdGlDS55nK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fnsmsz%2FbtstqFfj9M6%2F2BGzk32roKI3kdGlDS55nK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;404&quot; data-origin-width=&quot;1282&quot; data-origin-height=&quot;438&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 화면 방향&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1574&quot; data-origin-height=&quot;292&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/D2JUM/btstksasMZS/WyCag8LdKgp3KITPkU0BbK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/D2JUM/btstksasMZS/WyCag8LdKgp3KITPkU0BbK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/D2JUM/btstksasMZS/WyCag8LdKgp3KITPkU0BbK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FD2JUM%2FbtstksasMZS%2FWyCag8LdKgp3KITPkU0BbK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;447&quot; height=&quot;83&quot; data-origin-width=&quot;1574&quot; data-origin-height=&quot;292&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 픽셀 밀도(해상도)&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1580&quot; data-origin-height=&quot;310&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/FIe3n/btstljqDO9B/PdDaZjolZAlGpEfLkmjoA0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/FIe3n/btstljqDO9B/PdDaZjolZAlGpEfLkmjoA0/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/FIe3n/btstljqDO9B/PdDaZjolZAlGpEfLkmjoA0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FFIe3n%2FbtstljqDO9B%2FPdDaZjolZAlGpEfLkmjoA0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;524&quot; height=&quot;103&quot; data-origin-width=&quot;1580&quot; data-origin-height=&quot;310&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 화면 비율&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1564&quot; data-origin-height=&quot;380&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bO4vkp/btstqZ5Ke5l/Z7jo1OQzqOkJdANy1MP050/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bO4vkp/btstqZ5Ke5l/Z7jo1OQzqOkJdANy1MP050/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bO4vkp/btstqZ5Ke5l/Z7jo1OQzqOkJdANy1MP050/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbO4vkp%2FbtstqZ5Ke5l%2FZ7jo1OQzqOkJdANy1MP050%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;498&quot; height=&quot;121&quot; data-origin-width=&quot;1564&quot; data-origin-height=&quot;380&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 마우스 포인터&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2170&quot; data-origin-height=&quot;364&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/NRLF2/btstfd6fHnM/uzcRZu4V8NadXrPO9RxSs1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/NRLF2/btstfd6fHnM/uzcRZu4V8NadXrPO9RxSs1/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/NRLF2/btstfd6fHnM/uzcRZu4V8NadXrPO9RxSs1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FNRLF2%2Fbtstfd6fHnM%2FuzcRZu4V8NadXrPO9RxSs1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;699&quot; height=&quot;117&quot; data-origin-width=&quot;2170&quot; data-origin-height=&quot;364&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;6. 프린트 장치&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1672&quot; data-origin-height=&quot;672&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/mRAfH/btstkU5IciZ/ksa5JtJvqVOjprac1XYnV1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/mRAfH/btstkU5IciZ/ksa5JtJvqVOjprac1XYnV1/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/mRAfH/btstkU5IciZ/ksa5JtJvqVOjprac1XYnV1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmRAfH%2FbtstkU5IciZ%2Fksa5JtJvqVOjprac1XYnV1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;559&quot; data-origin-width=&quot;1672&quot; data-origin-height=&quot;672&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;7. 컬러 &amp;amp; 컬러모드&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1792&quot; data-origin-height=&quot;446&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/coEtlC/btstkqcFmIp/zowKGygYrjUioo1vSZRGg0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/coEtlC/btstkqcFmIp/zowKGygYrjUioo1vSZRGg0/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/coEtlC/btstkqcFmIp/zowKGygYrjUioo1vSZRGg0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcoEtlC%2FbtstkqcFmIp%2FzowKGygYrjUioo1vSZRGg0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;619&quot; height=&quot;154&quot; data-origin-width=&quot;1792&quot; data-origin-height=&quot;446&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;8. 주변 광도(최신 기술이라서 안되는 웹사이트도 있음)&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1564&quot; data-origin-height=&quot;374&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/lTXS6/btstlg1LMCs/fFAKr51x1tX4oaPDtE2CX0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/lTXS6/btstlg1LMCs/fFAKr51x1tX4oaPDtE2CX0/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/lTXS6/btstlg1LMCs/fFAKr51x1tX4oaPDtE2CX0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlTXS6%2Fbtstlg1LMCs%2FfFAKr51x1tX4oaPDtE2CX0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;568&quot; height=&quot;136&quot; data-origin-width=&quot;1564&quot; data-origin-height=&quot;374&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;9. 고대비 모드&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1394&quot; data-origin-height=&quot;324&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/o15Ww/btstk3nZJJ8/qF8sBRMM2LpEy48GIPRdM1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/o15Ww/btstk3nZJJ8/qF8sBRMM2LpEy48GIPRdM1/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/o15Ww/btstk3nZJJ8/qF8sBRMM2LpEy48GIPRdM1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fo15Ww%2Fbtstk3nZJJ8%2FqF8sBRMM2LpEy48GIPRdM1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;491&quot; height=&quot;114&quot; data-origin-width=&quot;1394&quot; data-origin-height=&quot;324&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;10. 애니메이션 &amp;amp; 투명도&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1964&quot; data-origin-height=&quot;300&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bAhc6Z/btstqX7VBrR/aZZtKhSPY0iFIK0yzIk2xK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bAhc6Z/btstqX7VBrR/aZZtKhSPY0iFIK0yzIk2xK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bAhc6Z/btstqX7VBrR/aZZtKhSPY0iFIK0yzIk2xK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAhc6Z%2FbtstqX7VBrR%2FaZZtKhSPY0iFIK0yzIk2xK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;682&quot; height=&quot;104&quot; data-origin-width=&quot;1964&quot; data-origin-height=&quot;300&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이렇게나 조작할 것이 많았다니,, 알고 안쓰는거랑 모르고 못쓰는거랑은 천지차이인데 많이 배웠다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;비트맵과 벡터의 차이&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;비트맵&lt;/b&gt;은 점(픽셀)을 모아서 그래픽을 만듭니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 확대하면 깨지고,&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 용량이 크지만,&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 복잡한 이미지 표현이 가능합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;예를 들어 jpg, png, gif가 있습니다.&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;421&quot; data-origin-height=&quot;374&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bKY09k/btsteTsyw14/PlZqsKvkkkIUOPgBFbEqwk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bKY09k/btsteTsyw14/PlZqsKvkkkIUOPgBFbEqwk/img.png&quot; data-alt=&quot;비트맵&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bKY09k/btsteTsyw14/PlZqsKvkkkIUOPgBFbEqwk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbKY09k%2FbtsteTsyw14%2FPlZqsKvkkkIUOPgBFbEqwk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;194&quot; height=&quot;172&quot; data-origin-width=&quot;421&quot; data-origin-height=&quot;374&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;비트맵&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;벡터&lt;/b&gt;는 좌표를 계산해서 그래픽을 만듭니다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. &lt;b&gt;확대해도 깨지지 않고&lt;/b&gt;,&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. 용량이 작지만,&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;3. 복잡한 이미지 표현은 어렵습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;예를 들어 ai, &lt;b&gt;svg&lt;/b&gt;, pdf가 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignLeft&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;459&quot; data-origin-height=&quot;377&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/d04jdN/btstcPcYHEJ/B7XPY7bXDoNPysnxnHmvSK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/d04jdN/btstcPcYHEJ/B7XPY7bXDoNPysnxnHmvSK/img.png&quot; data-alt=&quot;벡터&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/d04jdN/btstcPcYHEJ/B7XPY7bXDoNPysnxnHmvSK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd04jdN%2FbtstcPcYHEJ%2FB7XPY7bXDoNPysnxnHmvSK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;224&quot; height=&quot;184&quot; data-origin-width=&quot;459&quot; data-origin-height=&quot;377&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;벡터&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;팁으로 이미지를 2배 4배 로 크게 다운받아서 적용하면 해상도가 깨지지 않습니다. svg와 같이 깨지지 않는 벡터 이미지는 그냥 다운받아도 됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;해상도와 밀도&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;실제 기기의 디스플레이 픽셀과 CSS에서 인식하는 픽셀이 다릅니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;그 이유는 DPR 때문입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;DPR Device Pixel Ratio의 약자로 아래와 같은 공식으로 나타낼 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;DPR = 디바이스 픽셀 / css 픽셀&lt;/b&gt;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;디바이스 픽셀&lt;br /&gt;디바이스 화면에 실제로 표시되는 물리적 픽셀 수입니다. 예를 들어, 1920x1080 픽셀 해상도의 모니터는 1920개의 가로 픽셀과 1080개의 세로 픽셀을 가지고 있습니다.&lt;/li&gt;
&lt;li&gt;css 픽셀&lt;br /&gt;웹 페이지 렌더링 및 디자인에 사용되는 가상 픽셀 단위입니다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1178&quot; data-origin-height=&quot;934&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/FLv9O/btstmFNKezR/MXtuhRhiMOJX67PMRPoKq1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/FLv9O/btstmFNKezR/MXtuhRhiMOJX67PMRPoKq1/img.png&quot; data-alt=&quot;출처: https://tomroth.com.au/dpr/&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/FLv9O/btstmFNKezR/MXtuhRhiMOJX67PMRPoKq1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FFLv9O%2FbtstmFNKezR%2FMXtuhRhiMOJX67PMRPoKq1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;460&quot; height=&quot;365&quot; data-origin-width=&quot;1178&quot; data-origin-height=&quot;934&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: https://tomroth.com.au/dpr/&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;즉,&amp;nbsp;한 개의 픽셀 안에 몇개의 화소를 넣었는지 나타냅니다.&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;b&gt;DPR이 클 수록 고해상도&lt;/b&gt;입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;device-pixel-ratio&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;CSS 미디어쿼리에서 DPR을 구분하는 값입니다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;참고할만한 유용한 사이트입니다.&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://screensiz.es/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;기기별 사이즈 확인&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blisk.io/devices&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;기기별 사이즈 확인&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yesviz.com/viewport/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;기기별 사이즈 확인&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.mydevice.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;내 기기 사이즈 확인&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;사이즈의 종류&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2342&quot; data-origin-height=&quot;972&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bQTzOJ/btstlgAK4Cn/bzFG3X0ha7mOd8oDABhd21/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bQTzOJ/btstlgAK4Cn/bzFG3X0ha7mOd8oDABhd21/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bQTzOJ/btstlgAK4Cn/bzFG3X0ha7mOd8oDABhd21/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbQTzOJ%2FbtstlgAK4Cn%2FbzFG3X0ha7mOd8oDABhd21%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;848&quot; height=&quot;352&quot; data-origin-width=&quot;2342&quot; data-origin-height=&quot;972&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;하지만 반응형이라고 PX을 사용하지 않는 것은 아닙니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;이미지를 저장할 때&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;이미지는 저장 후 꼭 최적화 과정을 거쳐야합니다. 변환기를 사용할 수도 있고, 이미지 스프라이트나 이미지 슬라이스 기법을 사용하면 된다고 한다. 변환기를 사용해본 경험은 있지만 기법은 처음 들어보고, 사용해보지도 않았다. 이후 강의에서 설명해주신다고 해서 기대가 된다!&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;간단하게 찾아보니깐 이미지 스프라이트 기법은 각각의 이미지를 개별적으로 다운받는 게 아니라, 하나로 뭉친 차일을 다운 받아서 필요한 부분만 잘라서 사용하는거라고 한다. 실제로 네이버 메인페이지에서도 사용되는 기법이다! 많은 이미지 파일을 관리하지 않아도 된다는 장점과 서버로의 요청 횟수를 줄여 사이트 로딩 속도를 줄여준다는 장점이 있어서 사용한다고 한다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;생각해보면 아무 생각 없이 이미지 맘대로 적용하고, 웹에서 썼는데 허허 머쓱하다. 지금부터라도 인지하고, 최적화시켜야겠다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;유용한 사이트&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://giona.net/tools/css3-mediaquery-generator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;미디어 쿼리 자동 코드 작성&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://browserleaks.com/css&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;현재 웹 사이트의 미디어 쿼리 확인&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mediaqueriestest.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;미디어 쿼리 테스트&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.toptal.com/developers/css/sprite-generator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;이미지 스프라이트&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&amp;nbsp;&lt;/h3&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;원티드 9월&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=fKyLCIqWjIY&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;이미지 스프라이트 기법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;진짜 알차게 흡수한 꿀팁이였다. 포폴 관련 팁까지! 완벽했다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;전혀 고민해보지 않았던 부분까지 기본기를 다질 수 있는 시간이였다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;다음 코스부터는 코드로 직접 설명해주신다고 하는데, 쏙쏙 가져가야지&lt;/p&gt;</description>
      <category>etc/개발 세미나</category>
      <category>반응형</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/142</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-9%EC%9B%94-%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B8%B0%EC%B4%88#entry142comment</comments>
      <pubDate>Fri, 8 Sep 2023 13:49:45 +0900</pubDate>
    </item>
    <item>
      <title>[모던 자바스크립트 딥다이브] 1장 ~ 6장</title>
      <link>https://1two13.tistory.com/entry/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%94%A5%EB%8B%A4%EC%9D%B4%EB%B8%8C-1%EC%9E%A5-6%EC%9E%A5</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;983&quot; data-origin-height=&quot;1200&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cAxxEp/btstmIC12Bv/kvTwXzS4DiIJHUxpOTlGt1/img.jpg&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cAxxEp/btstmIC12Bv/kvTwXzS4DiIJHUxpOTlGt1/img.jpg&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cAxxEp/btstmIC12Bv/kvTwXzS4DiIJHUxpOTlGt1/img.jpg&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcAxxEp%2FbtstmIC12Bv%2FkvTwXzS4DiIJHUxpOTlGt1%2Fimg.jpg&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;255&quot; height=&quot;311&quot; data-origin-width=&quot;983&quot; data-origin-height=&quot;1200&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;위 서적을 읽고 중요하다고 생각되거나 모르는 부분을 정리했습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1. 프로그래밍&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. &lt;b&gt;사람이 이해&lt;/b&gt;할 수 있는 &lt;b&gt;자연어&lt;/b&gt;로 구성된 &lt;b&gt;프로그래밍 언어&lt;/b&gt;를 사용해 프로그램을 작성한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 컴퓨터가 이해할 수 있는 기계어로 변환하는 &lt;b&gt;번역기&lt;/b&gt;인 &lt;b&gt;컴파일러&lt;/b&gt;(혹은 &lt;b&gt;인터프리터&lt;/b&gt;)를 이용한다.&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. &lt;b&gt;컴퓨터가 이해&lt;/b&gt;할 수 있는 &lt;b&gt;기계어&lt;/b&gt;로 변환된다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;2. 자바스크립트란?&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;2-1. Ajax(Asynchronous Javascript And XMLHttpRequest)&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;Ajax는 &lt;u&gt;&lt;b&gt;자바스크립트&lt;/b&gt;&lt;/u&gt;를 이용해 &lt;b&gt;서버&lt;/b&gt;와 &lt;b&gt;브라우저&lt;/b&gt;가 &lt;u&gt;&lt;b&gt;비동기 방식&lt;/b&gt;&lt;/u&gt;으로 &lt;b&gt;데이터를 교환&lt;/b&gt;할 수 있는 &lt;b&gt;통신 기능&lt;/b&gt;입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;&lt;b&gt;이전의 웹 페이지는&lt;/b&gt;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;완전한 HTML 코드를 서버로부터 전송받아 웹 페이지 전체를 렌더링하는 방식으로 동작했습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;그래서 아래와 같은 단점이 있었습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 불필요한 데이터 통신이 발생합니다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;변경할 필요가 없는 부분까지 포함된 HTML 코드를 서버로부터 다시 전송받기 때문입니다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 성능이 좋지 않습니다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;변경할 필요가 없는 부분까지 처음부터 다시 렌더링해야하기 때문입니다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 화면이 전환될 때 깜박이는 현상이 발생됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;b&gt;Ajax 등장 이후의 웹 페이지는&lt;/b&gt;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. 변경이 필요한 부분만 렌더링합니다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 렌더링합니다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 부드러운 화면 전환이 가능합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;2-2. Node.js&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;구글 &lt;b&gt;v8 자바스크립트 엔진&lt;/b&gt;으로 빌드된 &lt;b&gt;자바스크립트 &lt;u&gt;런타임 환경&lt;/u&gt;&lt;/b&gt;입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;Node.js는 자바스크립트 엔진에서만 동작하던 자바스크립트를 &lt;b&gt;브라우저 이외의 환경&lt;/b&gt;에서도 동작할 수 있도록 한 자바스크립트 실행 환경입니다. 주로 &lt;b&gt;서버 사이드 애플리케이션&lt;/b&gt; 개발에 주로 사용되고, CPU 사용률이 높은 애플리케이션에는 권장되지 않습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. &lt;b&gt;비동기 I/O&lt;/b&gt;를 지원합니다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;데이터를 &lt;b&gt;실시간&lt;/b&gt;으로 처리하기 위해 I/O가 빈번하게 발생하는 &lt;b&gt;SPA&lt;/b&gt;에 적합합니다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. &lt;b&gt;&lt;u&gt;단일 스레드&lt;/u&gt; &lt;u&gt;이벤트 루프&lt;/u&gt;&lt;/b&gt; 기반으로 동작합니다. =&amp;gt; 요청 처리 성능이 좋습니다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;3. DOM API가 제공되지 않습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;4. 파일을 생성하고 수정할 수 있는 파일 시스템이 제공됩니다.&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;(+ 브라우저에서는 파일 시스템이 제공되지 않지만, Web API인 FileReader 객체를 사용해 사용자가 지정한 파일을 읽어들일 수는 있습니다.)&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;2-3. SPA(Single Page Application)&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;SPA는 &lt;b&gt;CBD&lt;/b&gt;(Component Based Development) 방법론을 기반으로 하는 &lt;b&gt;프레임워크&lt;/b&gt;입니다. &lt;b&gt;React&lt;/b&gt;, &lt;b&gt;Vue.js&lt;/b&gt; 등이 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;SPA는 &lt;u&gt;&lt;b&gt;최초 한 번&lt;/b&gt;&lt;/u&gt; &lt;u&gt;&lt;b&gt;페이지 전체&lt;/b&gt;&lt;/u&gt;를 로딩한 이후에,&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;서버&lt;/b&gt;로부터 페이지 갱신에&amp;nbsp;&lt;u&gt;&lt;b&gt;필요한 데이터만&lt;/b&gt;&lt;/u&gt; &lt;b&gt;비동기적&lt;/b&gt;으로 받아와,&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;그 정보를 기준으로 현재 페이지를 업데이트하는 방식입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;초기 로딩 이후에는 로딩 속도가 빠르기 때문에 사용자 경험을 향상시킬 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;2-4. 자바스크립트의 특징&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. 웹 브라우저에서 동작하는 유일한 프로그래밍 언어&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. &lt;b&gt;인터프리터&lt;/b&gt; 언어&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;3. &lt;b&gt;싱글 스레&lt;/b&gt;드이면서 &lt;b&gt;논 블로킹&lt;/b&gt; 언어&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;스레드가 하나밖에 존재하지 않아, 한 번에 하나의 작업만 할 수 있지만,&lt;/li&gt;
&lt;li&gt;비동기 처리를 통해 동시에 다른 작업을 수행할 수 있습니다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;4. 멀티 패러다임 프로그래밍 언어&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;- 명령형 프로그래밍: 컴퓨터가 어떻게 작업을 수행해야 하는지 명령하는 방식으로 코드를 작성하는 프로그래밍 패러다임&lt;br /&gt;- 함수형 프로그래밍: 함수를 &lt;b&gt;일급 객체&lt;/b&gt;로 취급하고, &lt;b&gt;함수의 조합&lt;/b&gt;을 통해 프로그래밍을 작성하는 프로그래밍 패러다임&lt;br /&gt;- 프로토타입 기반 객체지향 프로그래밍: 객체를 생성하기 위해 다른 객체를 기반으로 만드는 방식으로 &lt;b&gt;객체를 다루는&lt;/b&gt; 프로그래밍 패러다임&lt;br /&gt;&lt;br /&gt;일급 객체 특징&lt;br /&gt;1. &lt;b&gt;변수&lt;/b&gt;에 할당할 수 있고,&amp;nbsp;&lt;br /&gt;2. 함수의 &lt;b&gt;매개변수&lt;/b&gt;로 전달할 수 있고,&amp;nbsp;&lt;br /&gt;3. 함수의 &lt;b&gt;반환값&lt;/b&gt;으로 사용될 수 있습니다. (2, 3 중 하나 이상을 만족하는 함수의 경우 고차함수라고 합니다.)&lt;/blockquote&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1216&quot; data-origin-height=&quot;944&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cnuHLV/btss723zDgE/qZRvSUfGqSAMDma1hffkH0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cnuHLV/btss723zDgE/qZRvSUfGqSAMDma1hffkH0/img.png&quot; data-alt=&quot;프로토타입 기반 객체지향 프로그래밍 예시&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cnuHLV/btss723zDgE/qZRvSUfGqSAMDma1hffkH0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcnuHLV%2Fbtss723zDgE%2FqZRvSUfGqSAMDma1hffkH0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;630&quot; height=&quot;489&quot; data-origin-width=&quot;1216&quot; data-origin-height=&quot;944&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;프로토타입 기반 객체지향 프로그래밍 예시&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;컴파일러 언어 vs 인터프리터 언어&lt;/b&gt;&lt;/h4&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%; height: 110px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 20px;&quot;&gt;
&lt;td style=&quot;width: 50%; text-align: center; height: 20px;&quot;&gt;컴파일러 언어&lt;/td&gt;
&lt;td style=&quot;width: 50%; text-align: center; height: 20px;&quot;&gt;인터프리터 언어&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 18px;&quot;&gt;
&lt;td style=&quot;width: 50%; text-align: justify; height: 18px;&quot;&gt;&lt;span style=&quot;background-color: #f6e199;&quot;&gt;&lt;b&gt;컴파일 타임&lt;/b&gt;&lt;/span&gt;(코드가 실행되기 전 단계)에 &lt;span style=&quot;background-color: #f6e199;&quot;&gt;&lt;b&gt;소스코드 전체&lt;/b&gt;&lt;/span&gt;를 한번에 &lt;span style=&quot;background-color: #f6e199;&quot;&gt;&lt;b&gt;머신코드&lt;/b&gt;&lt;/span&gt;로 변환 후 실행합니다.&lt;/td&gt;
&lt;td style=&quot;width: 50%; text-align: justify; height: 18px;&quot;&gt;&lt;span&gt;&lt;span style=&quot;background-color: #f6e199;&quot;&gt;&lt;b&gt;런타임&lt;/b&gt;&lt;/span&gt;(코드가 실행되는 단계)에&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;&lt;span style=&quot;background-color: #f6e199;&quot;&gt;&lt;u&gt;한 줄&lt;/u&gt;씩&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: #f6e199;&quot;&gt;&lt;u&gt;중간코드&lt;/u&gt;&lt;/span&gt;&lt;/b&gt;(바이트 코드)로 변환&lt;span&gt;&amp;nbsp;&lt;/span&gt;후 &lt;span style=&quot;background-color: #f6e199;&quot;&gt;&lt;b&gt;즉시&lt;/b&gt;&lt;/span&gt; 실행합니다.&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 18px;&quot;&gt;
&lt;td style=&quot;width: 50%; text-align: justify; height: 18px;&quot;&gt;&lt;span style=&quot;background-color: #f6e199;&quot;&gt;실행 파일&lt;/span&gt;을 생성합니다.&lt;/td&gt;
&lt;td style=&quot;width: 50%; text-align: justify; height: 18px;&quot;&gt;&lt;span&gt;실행 파일을 생성하지 않습니다.&amp;nbsp;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 18px;&quot;&gt;
&lt;td style=&quot;width: 50%; text-align: justify; height: 18px;&quot;&gt;컴파일 단계와 실행 단계가 &lt;span style=&quot;background-color: #f6e199;&quot;&gt;분리&lt;/span&gt;되어 있습니다.&lt;/td&gt;
&lt;td style=&quot;width: 50%; text-align: justify; height: 18px;&quot;&gt;&lt;span&gt;인터프리터 단계와 실행 단계가 분리되어 있지 않습니다.&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 18px;&quot;&gt;
&lt;td style=&quot;width: 50%; text-align: justify; height: 18px;&quot;&gt;&lt;u&gt;컴파일&lt;/u&gt;을 &lt;span style=&quot;background-color: #f6e199;&quot;&gt;한 번&lt;/span&gt;만 수행됩니다.&lt;/td&gt;
&lt;td style=&quot;width: 50%; text-align: justify; height: 18px;&quot;&gt;코드가 실행될 때마다 &lt;u&gt;인터프리트&lt;/u&gt; 과정이 &lt;span style=&quot;background-color: #f6e199;&quot;&gt;반복&lt;/span&gt; 수행됩니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 18px;&quot;&gt;
&lt;td style=&quot;width: 50%; text-align: justify; height: 18px;&quot;&gt;코드 실행 속도가 빠릅니다.&lt;/td&gt;
&lt;td style=&quot;width: 50%; text-align: justify; height: 18px;&quot;&gt;코드 실행 속도가 컴파일러 언어보다 느립니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;3. 자바스크립트 개발 환경과 실행 방법&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;3-1. npm(&lt;u&gt;Node&lt;/u&gt; &lt;u&gt;Package&lt;/u&gt; Manager)&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;npm은 자바스크립트 패키지 매니저입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. &lt;b&gt;Node.js&lt;/b&gt;에서 사용할 수 있는 &lt;b&gt;모듈&lt;/b&gt;들을 &lt;b&gt;패키지화&lt;/b&gt;해서 모아둔 &lt;u&gt;&lt;b&gt;저장소&lt;/b&gt;&lt;/u&gt; 역할과&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. 패키지 설치 및 관리를 위한 &lt;b&gt;CLI&lt;/b&gt;(Command Line Interface)를 제공합니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;4. 변수&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;h4 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;4-1. 변수랑 무엇인가? 왜 필요한가?&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억합니다.&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;메모리: 데이터를 저장할 수 있는 메모리 셀의 집합체입니다. 메모리에 저장되는 모든 값은 2진수로 저장됩니다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;셀: 1바이트(8비트)이고, 고유의 메모리 주소를 갖습니다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;다시 질문으로 돌아가서 변수가 왜 필요하냐면,&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 가능성이 매우 높고,&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. 메모리 주소는 코드가 실행될 때마다 변경되기 때문에, 코드가 실행되기 이전에는 값이 저장된 메모리 주소를 알 수 없기 때문입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;따라서,&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;변수는 하나의 값을 저장하기 위해 확보한&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;&lt;u&gt;메모리 공간을 식별&lt;/u&gt;하기 위해 붙인&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;u&gt;이름&lt;/u&gt;&lt;/b&gt;입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;4-2. 식별자&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;식별자는 &lt;u&gt;&lt;b&gt;메모리 주소&lt;/b&gt;&lt;/u&gt;&lt;b&gt;에 붙인 &lt;u&gt;이름&lt;/u&gt;&lt;/b&gt;입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;4-3. 변수 선언&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;변수 선언은 변수를 &lt;b&gt;생성&lt;/b&gt;하는 것입니다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;좀 더 자세히 말하자면, 메모리 공간을 확보하고, 식별자와 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;변수 선언에 의해 확보된 메모리 공간은 해제되기 전까지는 누구도 사용할 수 없습니다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;자바스크립트 엔진은 변수 선언을 2단계에 거쳐서 수행합니다.&amp;nbsp;&lt;/b&gt;&lt;/h4&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. 선언 단계&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알립니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. 초기화 단계&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;값을 저장하기 위한 메모리 공간을 확보하고, 암묵적으로 undefined를 할당해 초기화합니다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;var 키워드&lt;/b&gt;&lt;/h4&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;b&gt;함수 레벨 스코프&lt;/b&gt;를 지원해 의도치 않게 전역 변수로 선언된다는 단점이 있습니다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;선언과 초기화 단계가 동시에 진행됩니다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;var score; 라는 코드가 있을 때,&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. &lt;b&gt;식별자&lt;/b&gt; score를 &lt;b&gt;실행 컨텍스트&lt;/b&gt;에 등록합니다. - 선언 단계&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 값을 저장할 &lt;b&gt;메모리 공간&lt;/b&gt;을 확보합니다. - 초기화 단계&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 확보된 메모리 공간에 &lt;b&gt;undefined&lt;/b&gt; 값이 할당되어 초기화됩니다. - 초기화 단계&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;실행 컨텍스트&lt;br /&gt;- 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경입니다. &lt;br /&gt;- 자바스크립트 엔진은 실행 컨텍스트를 통해서 식별자와 스코프(변수와 함수의 유효범위)를 관리합니다. &lt;br /&gt;- 변수명과 변수값은 실행 컨텍스트 내에 키/값 형식인 객체로 등록되어 관리됩니다.&amp;nbsp;&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;4-4. 변수 선언의 실행 시점과 변수 호이스팅&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;변수 선언&lt;/b&gt;은 &lt;u&gt;&lt;b&gt;컴파일 타임&lt;/b&gt;&lt;/u&gt;에 먼저 실행됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;그 이유는,&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기 전에, 소스코드의 &lt;b&gt;평가 과정&lt;/b&gt;을 거치면서 &lt;b&gt;준비&lt;/b&gt;를 합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. 소스코드의 평가 과정에서 자바스크립트 엔진은 &lt;b&gt;모든 선언문&lt;/b&gt;을 소스 코드에서 찾아서 &lt;b&gt;먼저 실행&lt;/b&gt;합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;3. 평가 과정이 끝난 후, &lt;b&gt;모든 선언문을 제외&lt;/b&gt;한 소스코드를 한줄씩 순차적으로 실행하기 때문입니다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;다시 말해, 자바스크립트 엔진은 소스코드 위치와 상관없이 변수 선언을 가장 먼저 실행합니다. 따라서 어디서든지 변수를 참조할 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;이처럼 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징을 호이스팅이라고 합니다.&amp;nbsp;var, let, const, function, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;4-5. 값의 할당&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;변수 선언과 값의 할당은 실행 시점이 다릅니다. &lt;/b&gt;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;변수 선언은 컴파일 타임에 실행되고, 값의 할당은 런타임에 실행됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고, 값을 새로 저장하는 것이 아니라,&amp;nbsp;새로운 메모리 공간을 확보하고, 그 공간에 값을 할당합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;b&gt;그럼 사용하지 않는 값은 어떻게 될까?&lt;/b&gt;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가비지컬렉터에 의해서 메모리에서 자동 해제됩니다. 단, 메모리에서 언제 해제될지는 예측할 수 없습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가비지컬렉터란,&amp;nbsp;애플리케이션이 할당한 메모리 공간을 주기적으로 검사해, 어떤 식별자도 참조하지 않는 메모리 공간의 경우 해제하는 기능입니다. 이를 통해 메모리 누수를 방지할 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;5. 표현식과 문&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;h4 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;5-1. 값&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;값은 식이 평가되어 생성된 결과입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;모든 값은 &lt;b&gt;데이터 타입&lt;/b&gt;을 가지고, 메모리에&lt;b&gt; 2진수&lt;/b&gt;, 즉 &lt;b&gt;비트&lt;/b&gt;의 나열로 저장됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;5-2. 리터럴&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;리터럴은 &lt;b&gt;사람이 이해할 수 있는 문자&lt;/b&gt; 또는 &lt;b&gt;약속된 기호&lt;/b&gt;를 사용해 값을 표기하는&lt;b&gt; 표기법&lt;/b&gt;입니다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;자바스크립트 엔진은 런타임에 리터럴을 평가해 값을 생성합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;예를 들어&lt;span&gt; ,&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. 3은 숫자 리터럴이고, 이를 코드에 기술하면&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. 자바스크립트 엔진은 이를 평가해서,&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;3. 숫자 값 3을 생성합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;5-3. 표현식&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;표현식은 &lt;b&gt;값으로 평가될 수 있는 문&lt;/b&gt;입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;표현식 여부를 확인하는 가장 쉬운 방법은 개발자 도구를 이용하면 됩니다. 개발자 도구에서 표현식이 아닌 문을 실행하면 undefined를 출력합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;5-4. 문&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위입니다. 명령문이라고도 부릅니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;문은 여러 토큰으로 구성되는데, 토큰은 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;예를 들어, var sum = 1 + 2; 구문이 있을 때 var, sum, =, 1, +, 2, ; 모두 토큰입니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;6. 데이터 타입&lt;/b&gt;&lt;/h3&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;자바스크립트는 8개의 데이터 타입을 제공합니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 원시 타입(7개): number, string, boolean, undefined, null, symbol, BigInt&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 참조 타입(1개): 객체, 배열, 함수&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;BigInt&lt;br /&gt;- 숫자값을 안정적으로 나타낼 수 있는 최대치(2^53 - 1)보다 큰 정수를 표현할 수 있는 새로운 원시값입니다.&amp;nbsp;&lt;br /&gt;- 10n 또는 BigInt(10)와 같이 사용할 수 있습니다.&amp;nbsp;&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;6-1. undefined 타입&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환됩니다. 즉, &lt;b&gt;자바스크립트 엔진&lt;/b&gt;이 &lt;b&gt;변수를 초기화&lt;/b&gt;할 때 사용하는 값이기 때문에 개발자가 의도적으로 undefined를 변수에 할당하는 것은 지양됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;6-2. symbol 타입&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;다른 값과 중복되지 않는 유일무이한 값입니다. 주로 객체의 키를 만들기 위해 사용합니다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;symbol은 symbol 함수를 호출해 생성합니다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1693910876182&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;var key = Symbol('key');
console.log(typeof key); // symbol&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;6-3. 데이터 타입의 필요성&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;데이터 타입이 필요한 이유는 데이터 타입 종류에 따라 정해진 크기의 메모리 공간의 크기가 결정되기 때문입니다.&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;다시 말해,&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. 값을 &lt;u&gt;&lt;b&gt;저장&lt;/b&gt;&lt;/u&gt;할 때 &lt;b&gt;확보해야 하는 메모리 공간의 크기&lt;/b&gt;를 결정하기 위해서,&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. 값을 &lt;u&gt;&lt;b&gt;참조&lt;/b&gt;&lt;/u&gt;할 때 &lt;b&gt;한 번에 읽어 들여야 할&lt;/b&gt; 메모리 공간의 크기를 결정하기 위해서,&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;3. 메모리에서 읽어 들인 2진수를 어떻게 &lt;u&gt;&lt;b&gt;해석&lt;/b&gt;&lt;/u&gt;할지 결정하기 위해서 필요합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;&lt;b&gt;6-4. 동적 타이핑&lt;/b&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않고, &lt;b&gt;값을 할당하는 시점&lt;/b&gt;에 변수의 타입이 &lt;b&gt;동적&lt;/b&gt;으로 결정되고, &lt;b&gt;변수의 타입 변경이 가능&lt;/b&gt;합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;따라서, 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어지기 때문에&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. 변수는 제한적으로 사용하는 것이 좋습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. 변수의 유효 범위(스코프)는 최대한 좁게 만들어야 합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;3. 전역 변수는 최대한 사용하지 않도록 해야합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;4. 변수보다는 상수를 사용하는 것이 좋습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;5. 변수는 목적이나 의미를 파악할 수 있도록 네이밍합니다.&amp;nbsp;&lt;/p&gt;</description>
      <category>etc/개발 서적</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/141</guid>
      <comments>https://1two13.tistory.com/entry/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%94%A5%EB%8B%A4%EC%9D%B4%EB%B8%8C-1%EC%9E%A5-6%EC%9E%A5#entry141comment</comments>
      <pubDate>Thu, 7 Sep 2023 09:47:41 +0900</pubDate>
    </item>
    <item>
      <title>구름톤 챌린지 4주차 학습 일기 - BFS(모든 섬 방문하는 문제)</title>
      <link>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-4%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0-BFS%EB%AA%A8%EB%93%A0-%EC%84%AC-%EB%B0%A9%EB%AC%B8%ED%95%98%EB%8A%94-%EB%AC%B8%EC%A0%9C</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/dzeVKS/btstbcMyBCC/bRvYAgLKQaidfZTiFjXaBK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/dzeVKS/btstbcMyBCC/bRvYAgLKQaidfZTiFjXaBK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/dzeVKS/btstbcMyBCC/bRvYAgLKQaidfZTiFjXaBK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdzeVKS%2FbtstbcMyBCC%2FbRvYAgLKQaidfZTiFjXaBK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;835&quot; height=&quot;468&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;모든 섬을 방문해야하는 문제이기 때문에, BFS로 문제를 해결할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 그래프 입력&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;자바스크립트에서 그래프를 선언할 때는 인접 리스트 방식으로 그래프를 선언하고,&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이때 사용하는 자료구조는 객체이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 연합의 개수 세기 위한 visited 변수 사용&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;visited는 섬의 방문 여부, 어떤 연합에 속해 있는지 확인할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;1. visited = Array(N + 1).fill(0); 로 visited의 모든 요소를 0으로 초기화 한다.&amp;nbsp;&lt;br /&gt;2. visited[Node]의 값이 0이면, 그 섬은 어떤 연합에도 포함되지 않은 섬이다.&amp;nbsp;&lt;br /&gt;3. 연합에 속하지 않는 섬에서, 새로운 연합을 만들었을 때 이를 i번 연합이라고 한다.&amp;nbsp;&lt;br /&gt;4. i번 연합에 속한 섬들은 visited[Node] = i로 갱신한다.&amp;nbsp;&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 조건대로 탐색하기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;탐색의 조건은 아래와 같기 때문에 아래 조건을 동시에 확인하면 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 방문하지 않은 노드&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 돌아오는 간선이 있는 노드&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. Timeout 에러가 난다면 최적화하기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;정답코드&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;처음에는 해결하지 못한 문제여서, 정답을 보고 난 후, 익일 다시 한 번 풀어보았다! 재도전했을 때는 정답이였다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그래프를 만드는 것 까지는 이전에도 했었지만,&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 간선 여부를 나타내는 배열과&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 방문 여부를 확인하는 배열&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;을 만드는 것이 포인트였다고 생각한다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1693984537152&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;const readline = require('readline');
let rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

let input = [];

rl.on('line', (line) =&amp;gt; {
  input.push(line);
});

rl.on('close', () =&amp;gt; {
  const [N, M] = input[0].split(' ').map(Number);
  const toFromArr = input.slice(1).map((el) =&amp;gt; el.split(' ').map(Number));
  let check = Array.from(Array(N + 1), () =&amp;gt; Array(N + 1).fill(false)); // 간선 여부를 나타내는 배열
  let visited = Array(N + 1).fill(0); // 방문 여부 확인하는 배열
  let obj = {};
  let count = 1;

  for (let i = 0; i &amp;lt; toFromArr.length; i++) {
    const [to, from] = toFromArr[i];

    if (!obj[to]) obj[to] = [];
    obj[to].push(from);
    check[to][from] = true;
  }

  for (let i = 1; i &amp;lt;= N; i++) {
    // 아직 방문하지 않았고,
    if (visited[i] === 0) {
      let q = [i];
      // 큐에 값이 없을 때까지 반복
      while (q.length &amp;gt; 0) {
        const currentNode = q.shift();
        // 방문했음을 표시
        visited[currentNode] = count;
        //* || [] 왜 하는거지? =&amp;gt; 하지 않으면 runtime 에러 발생
        for (const nextNode of obj[currentNode] || []) {
          // 양방향 간선인지 확인 &amp;amp;&amp;amp; 방문여부 확인
          if (check[nextNode][currentNode] &amp;amp;&amp;amp; visited[nextNode] === 0) {
            // 조건에 만족한다면 다음 탐색 후보에 추가
            q.push(nextNode);
          }
        }
      }
      // 모든 연결된 노드 방문 후, 하나의 컴포넌트 완성되었으므로 count++
      count++;
    }
  }

  console.log(count - 1);

  rl.close();
});&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc; color: #555555; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li style=&quot;list-style-type: disc; color: #666666;&quot;&gt;구름톤 프로젝트 매니징 자료&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>etc/[구름] 구름톤 챌린지</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/140</guid>
      <comments>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-4%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0-BFS%EB%AA%A8%EB%93%A0-%EC%84%AC-%EB%B0%A9%EB%AC%B8%ED%95%98%EB%8A%94-%EB%AC%B8%EC%A0%9C#entry140comment</comments>
      <pubDate>Wed, 6 Sep 2023 16:19:07 +0900</pubDate>
    </item>
    <item>
      <title>구름톤 챌린지 3주차 학습 일기 - DP(동적 계획법)</title>
      <link>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-3%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0-DP%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cV7GEv/btssBqDfKIf/n5AeWosBCtoKF1kgKssp40/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cV7GEv/btssBqDfKIf/n5AeWosBCtoKF1kgKssp40/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cV7GEv/btssBqDfKIf/n5AeWosBCtoKF1kgKssp40/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcV7GEv%2FbtssBqDfKIf%2Fn5AeWosBCtoKF1kgKssp40%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;845&quot; height=&quot;474&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;DP, 다이나믹 프로그래밍, 동적 계획법 이라고 불리는 기법은 이전에 구했던 답을 재활용하는 방식이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;다시 말해, 이전에 구한 값을 저장해두고 다시 사용하므로써 불필요한 중복 계산을 최대한 줄이는 방법이다.(메모이제이션)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;예를 들어서, 피보나치 수열을 재귀로 구현해보면 아래와 같다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;참고로 피보나치 수열은 처음 두개의 값이 0과 1이고, 이 다음 값은 맨 끝의 두 값을 더해서 만들어진다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #333333;&quot; data-token-index=&quot;0&quot;&gt;0, 1, 1, 2, 3, 5, 8, 13, 21, ...&lt;/span&gt;&lt;/p&gt;
&lt;pre id=&quot;code_1693319509404&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;function fibo(N){
  //첫 두값을 종단점으로 잡아줍니다.
  if (N === 0) return 0;
  if (N === 1) return 1;
  // N 번째 피보나치수는 N - 1번째, N - 2번째 피보나치수의 합이므로 재귀로 호출합니다.
  return fibo(N - 1) + fibo(N - 2);
}


console.log(fibo(8)); // 21
console.log(fibo(40)); // 102334155&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이때, fibo(8)에 비해서 fibo(40)은 상대적으로 오랜 시간에 걸려서 출력이 된다. 왜냐하면 중복으로 호출되는 함수가 N이 커짐에 따라 빠르게 증가하기 때문이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;예를 들어서, fibo(4)를 호출하면, fibo(3)과 fibo(2)를 각각 호출하고,&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;fibo(3)은 fibo(2)와 fibo(1)을 호출한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이때, fibo(2)가 중복되는 것을 확인할 수 있고, N이 커질수록 중복으로 호출되는 횟수는 더욱 많아진다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이를 개선하기 위해 동적 프로그래밍을 사용하면 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;N을 기준으로 0, 1 방향으로 내려가지 않고, 0, 1에서 N을 향해 올라가면 된다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1693319792600&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;const N = 40;
// 0번째 값이 0, 1번째 값이 1입니다. N에 대해 구하기 위해서는 N + 1칸의 배열을 선언해야합니다.
const fibo = new Array(N + 1).fill(0);
// 1번째 값을 1로 설정합니다.
fibo[1] = 1;

// 0, 1번째 값은 알고 있으므로 2번 값부터 N번 값까지 구하면 됩니다.
for (let i = 2; i &amp;lt;= N; i++) {
  fibo[i] = fibo[i - 1] + fibo[i - 2];
}

console.log(fibo[40]); // 102334155&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc; color: #555555; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li style=&quot;list-style-type: disc; color: #666666;&quot;&gt;구름톤 프로젝트 매니징 자료&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>etc/[구름] 구름톤 챌린지</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/139</guid>
      <comments>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-3%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0-DP%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95#entry139comment</comments>
      <pubDate>Tue, 29 Aug 2023 23:53:58 +0900</pubDate>
    </item>
    <item>
      <title>자료구조 시간복잡도 정리(평균, 최악)</title>
      <link>https://1two13.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%A0%95%EB%A6%AC%ED%8F%89%EA%B7%A0-%EC%B5%9C%EC%95%85</link>
      <description>&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;자료구조의 평균 시간 복잡도&lt;/b&gt;&lt;/h4&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%; height: 140px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot; data-ke-style=&quot;style12&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 20px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;자료구조&lt;/td&gt;
&lt;td style=&quot;width: 19.8837%; height: 20px;&quot;&gt;접근&lt;/td&gt;
&lt;td style=&quot;width: 20.1163%; height: 20px;&quot;&gt;탐색&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;삽입&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;삭제&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 20px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;배열&lt;/td&gt;
&lt;td style=&quot;width: 19.8837%; height: 20px;&quot;&gt;O(1)&lt;/td&gt;
&lt;td style=&quot;width: 20.1163%; height: 20px;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 20px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;스택&lt;/td&gt;
&lt;td style=&quot;width: 19.8837%; height: 20px;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;width: 20.1163%; height: 20px;&quot;&gt;&lt;span style=&quot;background-color: #f9f9f9; color: #333333; text-align: start;&quot;&gt;O(n)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;&lt;span style=&quot;background-color: #f9f9f9; color: #333333; text-align: start;&quot;&gt;O(1)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;&lt;span style=&quot;background-color: #f9f9f9; color: #333333; text-align: start;&quot;&gt;O(1)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 20px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;큐&lt;/td&gt;
&lt;td style=&quot;width: 19.8837%; height: 20px;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;width: 20.1163%; height: 20px;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;O(1)&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 20px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;이중 연결 리스트&lt;/td&gt;
&lt;td style=&quot;width: 19.8837%; height: 20px;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;width: 20.1163%; height: 20px;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;O(1)&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 20px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;해시 테이블&lt;/td&gt;
&lt;td style=&quot;width: 19.8837%; height: 20px;&quot;&gt;O(1)&lt;/td&gt;
&lt;td style=&quot;width: 20.1163%; height: 20px;&quot;&gt;O(1)&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;O(1)&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 20px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;이진 탐색 트리&lt;/td&gt;
&lt;td style=&quot;width: 19.8837%; height: 20px;&quot;&gt;O(logn)&lt;/td&gt;
&lt;td style=&quot;width: 20.1163%; height: 20px;&quot;&gt;&lt;span style=&quot;background-color: #f9f9f9; color: #333333; text-align: start;&quot;&gt;O(logn)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;&lt;span style=&quot;background-color: #f9f9f9; color: #333333; text-align: start;&quot;&gt;O(logn)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;width: 20%; height: 20px;&quot;&gt;&lt;span style=&quot;background-color: #f9f9f9; color: #333333; text-align: start;&quot;&gt;O(logn)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #000000;&quot; data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;자료구조 최악의 시간 복잡도&lt;/b&gt;&lt;/h4&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%; height: 140px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot; data-ke-style=&quot;style12&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;background-color: #9b9b9b; color: #ffffff;&quot;&gt;자료구조&lt;/td&gt;
&lt;td style=&quot;background-color: #9b9b9b; color: #ffffff;&quot;&gt;접근&lt;/td&gt;
&lt;td style=&quot;background-color: #9b9b9b; color: #ffffff;&quot;&gt;탐색&lt;/td&gt;
&lt;td style=&quot;background-color: #9b9b9b; color: #ffffff;&quot;&gt;삽입&lt;/td&gt;
&lt;td style=&quot;background-color: #9b9b9b; color: #ffffff;&quot;&gt;삭제&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;background-color: #efefef;&quot;&gt;배열&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;background-color: #efefef;&quot;&gt;스택&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;&lt;span style=&quot;background-color: #f9f9f9; color: #333333; text-align: start;&quot;&gt;O(n)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;&lt;span style=&quot;background-color: #f9f9f9; color: #333333; text-align: start;&quot;&gt;O(1)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;&lt;span style=&quot;background-color: #f9f9f9; color: #333333; text-align: start;&quot;&gt;O(1)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;background-color: #efefef;&quot;&gt;큐&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;background-color: #efefef;&quot;&gt;이중 연결 리스트&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;O(1)&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;background-color: #efefef;&quot;&gt;해시 테이블&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;background-color: #efefef;&quot;&gt;이진 탐색 트리&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;background-color: #f9f9f9;&quot;&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;해시 테이블과 이진 탐색 트리만 상이하다.&amp;nbsp;&lt;/p&gt;</description>
      <category>알고리즘/자료구조</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/138</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%A0%95%EB%A6%AC%ED%8F%89%EA%B7%A0-%EC%B5%9C%EC%95%85#entry138comment</comments>
      <pubDate>Mon, 28 Aug 2023 18:55:13 +0900</pubDate>
    </item>
    <item>
      <title>그리디 알고리즘</title>
      <link>https://1two13.tistory.com/entry/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</link>
      <description>&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;그리디 알고리즘이란?&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그리디 알고리즘은 보통 탐욕법이라고 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;말 그대로 문제를 해결할 때 &lt;b&gt;현재 경우만 고려&lt;/b&gt;해서 &lt;b&gt;최적의 상황을 선택&lt;/b&gt;하는 방법이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;그리디 알고리즘 성립 조건 2가지&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 당연하게도 항상 사용할 수 있는 방법은 아니기 때문에 아래의 2가지 조건이 성립된다면 그리디 알고리즘을 기계적으로 적용할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;1. 현재의 최적의 선택이 &lt;u&gt;다음 선택&lt;/u&gt;에 영향을 미치지 않는다.&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;2. 현재의 선택이 &lt;u&gt;최종 선택&lt;/u&gt;의 최적 해결 방법에 포함된다.&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;그리디 알고리즘 문제를 해결하는 방법&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 현재 상태에서의 최적의 해답을 선택한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 선택된 해가 문제의 조건을 만족하는지 검사한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 1번으로 돌아가 위의 과정을 반복한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;그리디 알고리즘 예시&lt;/b&gt;&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;일반적인 코딩 테스트 정도의 레벨에서 나오는 유형은 한정되어 있기 때문에 자주 나오는 몇 가지 상황에 대해 그리디로 해결할 수 있음을 알고 있는 것이 좋다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;예를 들어, &lt;b&gt;물건 가격이 4040원이고, 5000원을 지불했을 때, 거스름돈으로 동전 개수를 최소한으로 거슬러 받는 문제&lt;/b&gt;가 있다.&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;거스름돈은 960원&lt;/li&gt;
&lt;li&gt;500원 1개, 100원 4개, 50원 1개, 10원 1개&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;1. &lt;span style=&quot;letter-spacing: 0px; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Apple SD Gothic Neo', Arial, sans-serif;&quot;&gt;거스름돈의 동전 개수를 줄이기 위해 현재 가장 가치가 높은 동전을 우선 선택한다.&lt;br /&gt;&lt;/span&gt;2. 1번 과정을 통해 선택된 동전들의 합이 거슬러 줄 금액을 &lt;b&gt;초과하는지 검사&lt;/b&gt;하고,&amp;nbsp;&lt;br /&gt;만약 초과한다면 가장 &lt;b&gt;마지막에 선택한 동전을 삭제&lt;/b&gt;하고,&amp;nbsp;&lt;br /&gt;1번으로 돌아가 &lt;b&gt;한 단계 작은 동전을 선택&lt;/b&gt;한다.&amp;nbsp;&lt;br /&gt;3. 선택된 동전들의 합이 거슬러 줄 금액과 일치하는지 검사하고,&amp;nbsp;&lt;br /&gt;일치하지 않으면 1번 과정부터 다시 반복한다.&amp;nbsp;&lt;/blockquote&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%83%90%EC%9A%95%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-greedy-algorithm/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;블로그&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>알고리즘/자료구조</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/137</guid>
      <comments>https://1two13.tistory.com/entry/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98#entry137comment</comments>
      <pubDate>Mon, 28 Aug 2023 11:43:33 +0900</pubDate>
    </item>
    <item>
      <title>구름톤 챌린지 2주차 학습 일기 v2 (2차원 배열 완전 탐색, dx/dy 기법)</title>
      <link>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-2%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0-v2-2%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4-%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89-dxdy-%EA%B8%B0%EB%B2%95</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/PUvbS/btsr3d5ycsK/15Xi7Yy9jKGQ2CIH42PRW0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/PUvbS/btsr3d5ycsK/15Xi7Yy9jKGQ2CIH42PRW0/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/PUvbS/btsr3d5ycsK/15Xi7Yy9jKGQ2CIH42PRW0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPUvbS%2Fbtsr3d5ycsK%2F15Xi7Yy9jKGQ2CIH42PRW0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;842&quot; height=&quot;472&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2차원 배열에서 자주 사용되는 기법인 dx/dy 기법에 정리하려고 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;dx/dy 기법은 &lt;b&gt;현재 내 위치에서&lt;/b&gt; 상화좌우, 대각선 방향으로 이동이나 탐색을 구현할 때 사용한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;예를 들어 arr[1][1]의 상하좌우 값은 arr[0][1], arr[2][1], arr[1][0], arr[1][2] 다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이를 인덱스로 표현한다면 아래와 같다.&lt;/p&gt;
&lt;pre id=&quot;code_1692766223498&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;dx = [0, 0, -1, 1] // 열
dy = [-1, 1, 0, 0] // 행&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이를 코드로 적용해보면 아래와 같다.&lt;/p&gt;
&lt;pre id=&quot;code_1692766725910&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;let dx = [0, 0, -1, 1];
let dy = [-1, 1, 0, 0];

// 시작 위치 설정
let x = 1;
let y = 1;

// 4방향 탐색
for (let i = 0; i &amp;lt; 4; i++) {
  let nx = x + dx[i];
  let ny = y + dy[i];
  console.log(nx, ny);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;추가로 구름톤 문제에서는 대각선 방향도 포함하고 있고, 탐색을 할 때 올바른 탐색 위치인지도 확인해야 한다. 배열 밖을 나가는 탐색이 있을 수 있기 때문이다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1692767018014&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;// 상하좌우 + 대각선
let dx = [-1, -1, -1, 0, 0, 1, 1, 1]; // 열
let dy = [-1, 0, 1, -1, 1, -1, 0, 1]; // 행

// 시작 위치 설정
let x = 1;
let y = 1;

// 8방향 탐색
for (let i = 0; i &amp;lt; 8; i++) {
  let nx = x + dx[i];
  let ny = y + dy[i];
  //올바른 탐색 범위인지 확인. 배열 밖으로 나가는 탐색은 오류
  if (nx &amp;gt;= 0 &amp;amp;&amp;amp; nx &amp;lt; N &amp;amp;&amp;amp; ny &amp;gt;= 0 &amp;amp;&amp;amp; ny &amp;lt; N) {
    console.log(nx, ny);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc; color: #555555; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li style=&quot;list-style-type: disc; color: #666666;&quot;&gt;구름톤 프로젝트 매니징 자료&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>etc/[구름] 구름톤 챌린지</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/136</guid>
      <comments>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-2%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0-v2-2%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4-%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89-dxdy-%EA%B8%B0%EB%B2%95#entry136comment</comments>
      <pubDate>Wed, 23 Aug 2023 14:24:27 +0900</pubDate>
    </item>
    <item>
      <title>구름톤 챌린지 2주차 학습 일기</title>
      <link>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-2%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/PBXeA/btsrNAncqum/93gdjl6egeWVroorSiKBnk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/PBXeA/btsrNAncqum/93gdjl6egeWVroorSiKBnk/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/PBXeA/btsrNAncqum/93gdjl6egeWVroorSiKBnk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPBXeA%2FbtsrNAncqum%2F93gdjl6egeWVroorSiKBnk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;846&quot; height=&quot;474&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;문제&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;길이가 N인 문자열 S를 3개의 문자열로 나눈 후, 주어진 조건에 따라 점수를 계산하는 문제다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;점수는 문자열의 모든 부분 문자열의 순서에 따라서 결정된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;나눌 수 있는 모든 경우의 수 중에서 최대 점수를 얻을 수 있는 문자열을 찾는 문제이다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;문자열의 길이의 최대 100 정도로 짧기 때문에 가능한 모든 부분 문자열을 확인하는 &lt;u&gt;&lt;b&gt;완전 탐색&lt;/b&gt;&lt;/u&gt;으로 문제를 해결할 수 있습니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;나의 접근 방식&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 3개의 부분 문자열을 만들어서 배열에 push&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 각각의 배열을 다시 배열에 push(2차원 배열 생성)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. Set 함수 생성하여 중복 제거 후 모든 문자열 사전순으로 나열&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 2차원 배열을 순회하면서 사전순으로 몇 번째 인덱스인지 확인 후 해당 인덱스 모두 더하기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 더한 인덱스 값이 가장 큰 값이 정답&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;나의 코드&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;pre id=&quot;code_1692677818301&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;const readline = require('readline');
let rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
let input = [];

rl.on('line', (line) =&amp;gt; {
  input.push(line);
});

rl.on('close', () =&amp;gt; {
  // 3개의 부분 문자열을 만들어서 []에 push
  function getAllSubstrings(input) {
    const substrings = [];

    for (let i = 1; i &amp;lt; input.length - 1; i++) {
      for (let j = i + 1; j &amp;lt; input.length; j++) {
        substrings.push([input.slice(0, i), input.slice(i, j), input.slice(j)]);
      }
    }

    return substrings;
  }

  const combinations = getAllSubstrings(input[1]);
  let list = [];

  // list에 모든 값 push
  for (let i = 0; i &amp;lt; combinations.length; i++) {
    list.push(...combinations[i]);
  }

  // P: arr에서 중복 제거 후 모든 문자열 사전순으로 정렬
  let sortedList = [...new Set(list)].sort();
  let scoreArr = [];

  // arr을 순회하면서 각각의 배열 안에 있는 값의 인덱스를 모두 더하기
  for (let i = 0; i &amp;lt; combinations.length; i++) {
    let score = 0;

    for (let j = 0; j &amp;lt; 3; j++) {
      score += sortedList.indexOf(combinations[i][j]) + 1;
    }
    scoreArr.push(score);
  }

  // 문자열을 나눠서 얻을 수 있는 최대 점수
  console.log(Math.max(...scoreArr));

  rl.close();
});&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;알아두면 좋은 팁&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc; color: #555555; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;1. 조합을 사용하기&lt;/ul&gt;
&lt;ul style=&quot;list-style-type: disc; color: #555555; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;조합은 순서를 고려하지 않고, 집합에서 일부 원소를 선택하는 방법이다.&amp;nbsp;&lt;/ul&gt;
&lt;ul style=&quot;list-style-type: disc; color: #555555; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;예륻 들어 [1, 2, 3]에서 2개를 고른다면, [[1, 2], [1, 3], [2, 3]]을 고를 수 있다.&amp;nbsp;&lt;/ul&gt;
&lt;ul style=&quot;list-style-type: disc; color: #555555; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;보통 조합은 재귀함수로 구하지만, 해당 문제에서는 크기가 작기 때문에 반복문으로 해결할 수 있다.&amp;nbsp;&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc; color: #555555; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li style=&quot;list-style-type: disc; color: #666666;&quot;&gt;구름톤 프로젝트 매니징 자료&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>etc/[구름] 구름톤 챌린지</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/135</guid>
      <comments>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-2%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0#entry135comment</comments>
      <pubDate>Tue, 22 Aug 2023 18:37:06 +0900</pubDate>
    </item>
    <item>
      <title>구름톤 챌린지 1주차 학습 일기 v2</title>
      <link>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-1%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0-v2</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cBcWMu/btsrDKwb57Q/t6OKIqehV5F6B56stMfmiK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cBcWMu/btsrDKwb57Q/t6OKIqehV5F6B56stMfmiK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cBcWMu/btsrDKwb57Q/t6OKIqehV5F6B56stMfmiK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcBcWMu%2FbtsrDKwb57Q%2Ft6OKIqehV5F6B56stMfmiK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;829&quot; height=&quot;465&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5일차 문제에서 알아두면 좋은 코드가 있어서 정리했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;배열안에 여러 개의 배열들이 있고, 각 배열의 두 번째 값을 기준으로 내림차순 정렬하는데, 만약 두 번째 값이 같은 값인 경우에 각 배열의 첫 번째 값을 기준으로 내림차순 정렬을 하고 싶었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이를 해결하기 위한 아주 간단한 방법이 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;예를 들어 arr이 아래와 같을 때, sort를 사용하여 정렬시키면 원하는 결과값을 가져올 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1692498408468&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;let arr = [
  [ 1, 1 ], [ 2, 1 ],
  [ 3, 2 ], [ 4, 1 ],
  [ 5, 2 ], [ 6, 2 ],
  [ 7, 3 ], [ 8, 1 ]
]

arr.sort((a, b) =&amp;gt; b[1] - a[1] || b[0] - a[0]);

console.log(arr) /* [
  [ 7, 3 ], [ 6, 2 ],
  [ 5, 2 ], [ 3, 2 ],
  [ 8, 1 ], [ 4, 1 ],
  [ 2, 1 ], [ 1, 1 ]
] */&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;arr.sort((a, b) =&amp;gt; b[1] - a[1] || b[0] - a[0]); 식은 아래와 동일하다.&lt;/p&gt;
&lt;pre id=&quot;code_1692498389880&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;if(b[0] - a[0] !== 0) {
  return b[0] - a[0];
} else {
  return b[1] - a[1];
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li style=&quot;list-style-type: disc; color: #666666;&quot;&gt;구름톤 프로젝트 매니징 자료&lt;/li&gt;
&lt;/ul&gt;</description>
      <category>etc/[구름] 구름톤 챌린지</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/134</guid>
      <comments>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-1%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0-v2#entry134comment</comments>
      <pubDate>Sun, 20 Aug 2023 11:27:22 +0900</pubDate>
    </item>
    <item>
      <title>구름톤 챌린지 1주차 학습 일기</title>
      <link>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-1%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/UtG1Z/btsrdk6DUWT/jaVa5tOk2TnSu7kXf82wC1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/UtG1Z/btsrdk6DUWT/jaVa5tOk2TnSu7kXf82wC1/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/UtG1Z/btsrdk6DUWT/jaVa5tOk2TnSu7kXf82wC1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUtG1Z%2Fbtsrdk6DUWT%2FjaVa5tOk2TnSu7kXf82wC1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;831&quot; height=&quot;466&quot; data-origin-width=&quot;994&quot; data-origin-height=&quot;557&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;구름톤 챌린지는 구름에서 진행하는 챌린지이다!&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;매일 오전 10시에 알고리즘 문제가 주어지고 주어진 시간 내에 문제를 수행하면 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;48시간 내에 주어진 문제를 해결하면 블록을 얻을 수 있는데, 모두 모으면 오프라인 챌린지까지 참여할 수 있는 기회가 생겨서 참여하게 되었다. 물론 랜덤으로 뽑히는 거 같긴하지만 그래도 뽑히면 완전 좋으니깐!&lt;/p&gt;
&lt;figure id=&quot;og_1692155618439&quot; contenteditable=&quot;false&quot; data-ke-type=&quot;opengraph&quot; data-ke-align=&quot;alignCenter&quot; data-og-type=&quot;website&quot; data-og-title=&quot;구름톤 챌린지&quot; data-og-description=&quot;구름LEVEL 알고리즘 먼데이 챌린지가 구름톤 챌린지로 새롭게 찾아왔습니다. 온라인 알고리즘 문제 풀이와 오프라인 팀 챌린지를 모두 즐길 수 있는 구름톤 챌린지와 4주 동안 매일 꾸준히 성장&quot; data-og-host=&quot;9oormthonchallenge.oopy.io&quot; data-og-source-url=&quot;https://9oormthonchallenge.oopy.io/?_gl=1*1pmjs1m*_gcl_au*MTMyNDkxNjY2OS4xNjkyMDA3MTI2&quot; data-og-url=&quot;https://9oormthonchallenge.oopy.io&quot; data-og-image=&quot;https://scrap.kakaocdn.net/dn/DJldh/hyTCBlPIYL/qZmx0KMqYzUIGGQlkeFTU1/img.png?width=2000&amp;amp;height=1292&amp;amp;face=0_0_2000_1292,https://scrap.kakaocdn.net/dn/bX8Ffx/hyTCLvb5sK/bKug5HcRgOVu2o7rLzNJhK/img.png?width=2000&amp;amp;height=1292&amp;amp;face=0_0_2000_1292,https://scrap.kakaocdn.net/dn/baUsEw/hyTFa1cvTD/qU2MO5jNraAixaBU5Q16d0/img.png?width=2000&amp;amp;height=1323&amp;amp;face=0_0_2000_1323&quot;&gt;&lt;a href=&quot;https://9oormthonchallenge.oopy.io/?_gl=1*1pmjs1m*_gcl_au*MTMyNDkxNjY2OS4xNjkyMDA3MTI2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-source-url=&quot;https://9oormthonchallenge.oopy.io/?_gl=1*1pmjs1m*_gcl_au*MTMyNDkxNjY2OS4xNjkyMDA3MTI2&quot;&gt;
&lt;div class=&quot;og-image&quot; style=&quot;background-image: url('https://scrap.kakaocdn.net/dn/DJldh/hyTCBlPIYL/qZmx0KMqYzUIGGQlkeFTU1/img.png?width=2000&amp;amp;height=1292&amp;amp;face=0_0_2000_1292,https://scrap.kakaocdn.net/dn/bX8Ffx/hyTCLvb5sK/bKug5HcRgOVu2o7rLzNJhK/img.png?width=2000&amp;amp;height=1292&amp;amp;face=0_0_2000_1292,https://scrap.kakaocdn.net/dn/baUsEw/hyTFa1cvTD/qU2MO5jNraAixaBU5Q16d0/img.png?width=2000&amp;amp;height=1323&amp;amp;face=0_0_2000_1323');&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;og-text&quot;&gt;
&lt;p class=&quot;og-title&quot; data-ke-size=&quot;size16&quot;&gt;구름톤 챌린지&lt;/p&gt;
&lt;p class=&quot;og-desc&quot; data-ke-size=&quot;size16&quot;&gt;구름LEVEL 알고리즘 먼데이 챌린지가 구름톤 챌린지로 새롭게 찾아왔습니다. 온라인 알고리즘 문제 풀이와 오프라인 팀 챌린지를 모두 즐길 수 있는 구름톤 챌린지와 4주 동안 매일 꾸준히 성장&lt;/p&gt;
&lt;p class=&quot;og-host&quot; data-ke-size=&quot;size16&quot;&gt;9oormthonchallenge.oopy.io&lt;/p&gt;
&lt;/div&gt;
&lt;/a&gt;&lt;/figure&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;알고리즘에 취약하기도 하고, 아직 취준생이라 피할 수 없는 코딩 테스트를 준비하기 위한 나를 위한 챌린지가 아닐까라고 생각했다. 아직 3개의 문제만 풀어서, 난이도는 쉽다 ~ 중간 정도로 느끼고 있는데 점점 어려워질 거 같다..&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;미션을 해결하지 못해도 다음날 오전 10시에 해설지가 제공이 되는데 무지 친절하다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;해설지도 되게 도움이 많이 될거 같은 기분이 들었다!&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;나는 시간 계산과 같은 수학적인 계산에 되게 약한데, 구름톤 챌린지에서 제공해준 해설지를 기억해두면 좋을 것 같아서 학습일기를 남긴다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2일차 문제는 아래와 같다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;PM이 된 플레이어는 현재 시간에서 &lt;span style=&quot;color: #eb5757;&quot; data-token-index=&quot;1&quot;&gt;N개&lt;/span&gt;의 기능 개발에 필요한 시간을 정리하고 있다. 기능 개발에 필요한 시간은 모두 &lt;span style=&quot;color: #eb5757;&quot; data-token-index=&quot;3&quot;&gt;분&lt;/span&gt; 으로 제공되고 모든 기능이 완성되었을 때, 현재 시간이 몇 시인지 알아내면 되는 문제였다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;입력값은 아래와 같다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1692155868064&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;3 // 기능 개수
10 10 // 현재 시각
50 // 기능을 개발하는데 드는 시간
22 // 기능을 개발하는데 드는 시간
23 // 기능을 개발하는데 드는 시간&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;참고로 한 기능 개발이 끝나야 다음 기능 개발이 가능하다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;내가 문제를 해결했던 코드는 아래와 같다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1692155911131&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;const readline = require('readline');
let rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
let input = [];

rl.on('line', (line) =&amp;gt; {
  input.push(line);
});

rl.on('close', () =&amp;gt; {
  let [N, start] = input;
  let [T, M] = start.split(' ');
  N = Number(N);
  T = Number(T);
  M = Number(M);

  for (let i = 2; i &amp;lt; 2 + N; i++) {
    M += Number(input[i]);

    T += Math.floor(M / 60);
    M = M % 60;

    if (T &amp;gt;= 24) T -= 24;
  }

  console.log(T + ' ' + M);

  rl.close();
});&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 해설을 보았을 때, 해당 접근방법이 더 깔끔한 거 같아서 가져왔다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;완전한 코드를 올려도 되는지 모르겠어서 일부만 발췌했다ㅠ&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;포인트는 분은 분끼리 더한 후 50으로 나눈 나머지가 현재 분이되고,&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;시는 분을 시로 나눈 뒤, 시끼리 더한 후 24로 나눈 나머지가 현재 시가 된다는 점이였다.&lt;/p&gt;
&lt;pre id=&quot;code_1692156096853&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;// 현재 분에서, 비용 분만큼 더한 후, 60으로 나눈 나머지가 결과 분이다.
let tempMinute = currentMinute + costMinute;
let resultMinute = tempMinute % 60;
// 현재 시에서, 비용 분을 60으로 나는 몫만큼 더한 후, 24로 나눈 나머지가 결과 시이다.
let resultHour = (currentHour + Math.floor(tempMinute/60)) % 24;&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;구름톤 프로젝트 매니징 자료&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>etc/[구름] 구름톤 챌린지</category>
      <category>구름톤챌린지</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/133</guid>
      <comments>https://1two13.tistory.com/entry/%EA%B5%AC%EB%A6%84%ED%86%A4-%EC%B1%8C%EB%A6%B0%EC%A7%80-1%EC%A3%BC%EC%B0%A8-%ED%95%99%EC%8A%B5-%EC%9D%BC%EA%B8%B0#entry133comment</comments>
      <pubDate>Wed, 16 Aug 2023 12:28:31 +0900</pubDate>
    </item>
    <item>
      <title>이미지와 데이터 서버로 같이 전송하는 법 - FormData 생성 및 사용법</title>
      <link>https://1two13.tistory.com/entry/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%84%9C%EB%B2%84%EB%A1%9C-%EA%B0%99%EC%9D%B4-%EC%A0%84%EC%86%A1%ED%95%98%EB%8A%94-%EB%B2%95-FormData-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%82%AC</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;원래 코드상에서 이미지 정보 1번, 작성된 데이터 1번&amp;nbsp;이렇게 총 2번 서버로 전송하는 방식이었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;한 페이지에서 사용되는 정보들을 굳이 2번 나누어서 전송해야 하는 불필요함을 해결하기 위해 찾아보다가 FormData를 생성해서 사용하면 되는 것을 확인하고, 코드에 적용해 봤다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;FormData란?&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;먼저 FormData는 &lt;b&gt;form&lt;/b&gt; 데이터를 &lt;b&gt;동적&lt;/b&gt;으로 생성하고, 조작할 수 있게 해줍니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;사용되는 메서드들&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/FormData/append&quot;&gt;FormData.append()&lt;/a&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;FormData 객체 안에 이미 키가 존재하면 그 키에 새로운 값을 추가하고, 키가 없으면 추가합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;첫 번째 인자로 key를 두 번째 인자로 값을 설정할 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/FormData/delete&quot;&gt;FormData.delete()&lt;/a&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;FormData 객체로부터 키/밸류 쌍을 삭제합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/FormData/entries&quot;&gt;FormData.entries()&lt;/a&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이 객체에 담긴 모든 키/밸류 쌍을 순회할 수 있는&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a style=&quot;color: #000000;&quot; href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;iterator&lt;/a&gt;를 반환합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/FormData/get&quot;&gt;FormData.get()&lt;/a&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;FormData&lt;span&gt;&amp;nbsp;&lt;/span&gt;객체 내의 값들 중 주어진 키와 연관된 첫 번째 값을 반환합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/FormData/getAll&quot;&gt;FormData.getAll()&lt;/a&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;FormData&lt;span&gt;&amp;nbsp;&lt;/span&gt;객체 내의 값들 중 주어진 키와 연관된 모든 값이 담긴 배열을 반환합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/FormData/has&quot;&gt;FormData.has()&lt;/a&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;FormData&lt;span&gt;&amp;nbsp;&lt;/span&gt;객체에 특정 키가 포함되어 있는지 여부를 나타내는 boolean 을 반환합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/FormData/keys&quot;&gt;FormData.keys()&lt;/a&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이 객체에 담긴 모든 키/벨류 쌍들의 모든 키들을 순회할 수 있는&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a style=&quot;color: #000000;&quot; href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;iterator&lt;/a&gt;를 반환합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/FormData/set&quot;&gt;FormData.set()&lt;/a&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;FormData&lt;span&gt;&amp;nbsp;&lt;/span&gt;객체 내에 있는 기존 키에 새 값을 설정하거나, 존재하지 않을 경우 키/밸류 쌍을 추가합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/FormData/values&quot;&gt;FormData.values()&lt;/a&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이 객체에 포함된 모든 밸류를 통과하는&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a style=&quot;color: #000000;&quot; href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;iterator&lt;/a&gt;를 반환합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;직접 적용한 코드&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1008&quot; data-origin-height=&quot;410&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/b8j72p/btsq2QKeedf/v8wUuzvkcHSOqNBCnT253k/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/b8j72p/btsq2QKeedf/v8wUuzvkcHSOqNBCnT253k/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/b8j72p/btsq2QKeedf/v8wUuzvkcHSOqNBCnT253k/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb8j72p%2Fbtsq2QKeedf%2Fv8wUuzvkcHSOqNBCnT253k%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;816&quot; height=&quot;332&quot; data-origin-width=&quot;1008&quot; data-origin-height=&quot;410&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;저는 append 메소드를 사용했습니다.&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;1. FormData 객체를 생성합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;2. append 메서드를 사용해서 키와 값을 설정합니다. (데이터, 이미지 설정)&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;3. 그리고 fetch를 사용해서 서버로 전송할 때 생성한 FormData 객체를 전송합니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>프로젝트</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/132</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%84%9C%EB%B2%84%EB%A1%9C-%EA%B0%99%EC%9D%B4-%EC%A0%84%EC%86%A1%ED%95%98%EB%8A%94-%EB%B2%95-FormData-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%82%AC#entry132comment</comments>
      <pubDate>Sat, 12 Aug 2023 17:13:28 +0900</pubDate>
    </item>
    <item>
      <title>[프로그래머스/더 맵게] - JS로 힙 직접 구현해보기</title>
      <link>https://1two13.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EB%8D%94-%EB%A7%B5%EA%B2%8C-JS%EB%A1%9C-%ED%9E%99-%EC%A7%81%EC%A0%91-%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EA%B8%B0</link>
      <description>&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;&lt;b&gt;문제 설명&lt;/b&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;figure id=&quot;og_1691485179579&quot; contenteditable=&quot;false&quot; data-ke-type=&quot;opengraph&quot; data-ke-align=&quot;alignCenter&quot; data-og-type=&quot;website&quot; data-og-title=&quot;프로그래머스&quot; data-og-description=&quot;코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요.&quot; data-og-host=&quot;programmers.co.kr&quot; data-og-source-url=&quot;https://school.programmers.co.kr/learn/courses/30/lessons/42626&quot; data-og-url=&quot;https://programmers.co.kr/&quot; data-og-image=&quot;&quot;&gt;&lt;a href=&quot;https://school.programmers.co.kr/learn/courses/30/lessons/42626&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-source-url=&quot;https://school.programmers.co.kr/learn/courses/30/lessons/42626&quot;&gt;
&lt;div class=&quot;og-image&quot; style=&quot;background-image: url();&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;og-text&quot;&gt;
&lt;p class=&quot;og-title&quot; data-ke-size=&quot;size16&quot;&gt;프로그래머스&lt;/p&gt;
&lt;p class=&quot;og-desc&quot; data-ke-size=&quot;size16&quot;&gt;코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요.&lt;/p&gt;
&lt;p class=&quot;og-host&quot; data-ke-size=&quot;size16&quot;&gt;programmers.co.kr&lt;/p&gt;
&lt;/div&gt;
&lt;/a&gt;&lt;/figure&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;시간 복잡도&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;힙을 사용하지 않고, 코드를 구현했었는데, 효율성까지 통과해야하는 문제였기 때문에 힙을 사용해서 구현을 해야만 효율성을 모두 통과할 수 있었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;처음에는 힙을 사용하지 않고 배열을 매번 정렬했었기에 nlogn의 시간복잡도가 걸렸지만, 힙을 사용함으로써 logn으로 시간복잡도를 줄일 수 있었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;알고리즘 설계&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #000000;&quot; data-ke-size=&quot;size16&quot;&gt;처음 작성한 코드는 아래와 같다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1691485877116&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;function solution(scoville, K) {
    let answer = 0; // 섞어야 하는 최소 횟수
    
    // 모든 값이 K 이상인지 확인하기
    while(true) {
        // 순차정렬
        scoville = scoville.sort((a, b) =&amp;gt; a - b);
        // 섞은 음식의 스코빌 지수
        let newScoville = scoville[0] + (scoville[1] * 2);
        // 첫 번째 값과 두 번째 값 제거
        scoville.splice(0, 2);
        // 계산한 값 맨 앞에 추가
        scoville.unshift(newScoville);
        answer++;
        
        // 모든 값이 K 이상인 경우
        if(scoville.filter((el) =&amp;gt; el &amp;gt;= K).length === scoville.length) break;
        // 배열의 길이가 1 이하인 경우 종료
        if(scoville.length &amp;lt;= 1) break;
    }
    
    // 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우: -1
    for (let el of scoville) {
        if (el &amp;lt; K) {
            answer = -1;
            break;
        }
    }   
    
    return answer;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 style=&quot;color: #000000;&quot; data-ke-size=&quot;size26&quot;&gt;&amp;nbsp;&lt;/h2&gt;
&lt;h2 style=&quot;color: #000000;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;틀린 부분&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #000000;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;1. &lt;span style=&quot;font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Apple SD Gothic Neo', Arial, sans-serif; letter-spacing: 0px;&quot;&gt;순차정렬이 아닌 우선순위 큐 사용하기&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #000000;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;span style=&quot;font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Apple SD Gothic Neo', Arial, sans-serif; letter-spacing: 0px;&quot;&gt;배열을 매번 정렬하는 대신 힙을 사용하면 nlogn의 시간복잡도를 logn으로 줄일 수 있다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #000000;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #000000;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Apple SD Gothic Neo', Arial, sans-serif; letter-spacing: 0px;&quot;&gt;2. 조건 확인 최적화하기&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #000000;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Apple SD Gothic Neo', Arial, sans-serif; letter-spacing: 0px;&quot;&gt;배열 전체를 순회하지 않고, 섞은 결과로 생긴 새로운 음식의 스코빌 지수가 K이상인 경우 나머지도 K이상임이 보장된다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000;&quot; data-ke-size=&quot;size26&quot;&gt;&amp;nbsp;&lt;/h2&gt;
&lt;h2 style=&quot;color: #000000;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;다른 풀이&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;pre id=&quot;code_1691486883732&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;class MinHeap {
  constructor() {
    this.heap = [];
  }

  size() {
    return this.heap.length;
  }

  swap(idx1, idx2) {
    [this.heap[idx1], this.heap[idx2]] = [this.heap[idx2], this.heap[idx1]];
    return this.heap;
  }

  getParentIdx(childIdx) {
    return Math.floor((childIdx - 1) / 2);
  }

  getLeftChildIdx(parentIdx) {
    return parentIdx * 2 + 1;
  }

  getRightChildIdx(parentIdx) {
    return parentIdx * 2 + 2;
  }

  heapPop() {
    const heapSize = this.size();
    if (!heapSize) return null;
    if (heapSize === 1) return this.heap.pop();

    const value = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown();
    return value;
  }

  heapPush(value) {
    this.heap.push(value);
    this.bubbleUp();

    return this.heap;
  }

  bubbleUp() {
    let child = this.size() - 1;
    let parent = this.getParentIdx(child);

    while (this.heap[child] &amp;lt; this.heap[parent]) {
      this.swap(child, parent);
      child = parent;
      parent = this.getParentIdx(parent);
    }
  }

  bubbleDown() {
    let parent = 0;
    let leftChild = this.getLeftChildIdx(parent);
    let rightChild = this.getRightChildIdx(parent);

    while (
      (leftChild &amp;lt;= this.size() - 1 &amp;amp;&amp;amp; this.heap[leftChild] &amp;lt; this.heap[parent]) ||
      (rightChild &amp;lt;= this.size() - 1 &amp;amp;&amp;amp; this.heap[rightChild] &amp;lt; this.heap[parent])
    ) {
      if (rightChild &amp;lt;= this.size() - 1 &amp;amp;&amp;amp; this.heap[leftChild] &amp;gt; this.heap[rightChild]) {
        this.swap(parent, rightChild);
        parent = rightChild;
      } else {
        this.swap(parent, leftChild);
        parent = leftChild;
      }
      leftChild = this.getLeftChildIdx(parent);
      rightChild = this.getRightChildIdx(parent);
    }
  }
}

function solution(scoville, K) {
  let count = 0;
  const heap = new MinHeap();
  scoville.forEach((el) =&amp;gt; heap.heapPush(el));

  while (heap.heap[0] &amp;lt; K &amp;amp;&amp;amp; heap.size() &amp;gt; 1) {
    count++;
    heap.heapPush(heap.heapPop() + heap.heapPop() * 2);
  }
  return heap.heap[0] &amp;gt;= K ? count : -1;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>알고리즘/프로그래머스</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/131</guid>
      <comments>https://1two13.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EB%8D%94-%EB%A7%B5%EA%B2%8C-JS%EB%A1%9C-%ED%9E%99-%EC%A7%81%EC%A0%91-%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EA%B8%B0#entry131comment</comments>
      <pubDate>Tue, 8 Aug 2023 18:29:42 +0900</pubDate>
    </item>
    <item>
      <title>react-query의 useQuery 언제 사용할까?</title>
      <link>https://1two13.tistory.com/entry/react-query%EC%9D%98-useQuery-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;react에서 &lt;b&gt;비동기 로직을 리엑트스럽게&lt;/b&gt; 다루게 해주는 라이브러리다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;기존에 isLoading, isError, refetch, 데이터 캐싱 등 개발자가 직접 구현하기엔 다소 까다롭거나 귀찮은 기능을 제공해준다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;따라서 위와 같은 코드를 구현 할 때 사용한다면 그 매력에 빠지게 될 것이다!&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;기존 fetch 방식은 어땠을까?&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;기존 fetch 방식부터 살펴보자!&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이 귀찮은 작업들을 React Query를 사용하면 자동으로 실행되게끔 코드를 작성할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1689132713382&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;const [coins, setCoins] = useState&amp;lt;ICoin[]&amp;gt;([]);
const [loading, setLoading] = useState(true);
useEffect(() =&amp;gt; {
  (async () =&amp;gt; {
    const response = await fetch(&quot;https://api.coinpaprika.com/v1/coins&quot;);
    const json = await response.json();
    setCoins(json.slice(0, 100));
    setLoading(false);
  })(); // 함수를 바로 실행할 수 있는 팁! ()()
}, []);&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;React Query를 사용한 방식&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;pre id=&quot;code_1689133350548&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;// useQuery는 fetchCoins 라는 fetcher 함수를 부르고, 
// fetcher 함수가 로딩중이라면 isLoading에서 알려줄 것이고,
// fetcher 함수가 끝났다면 fetchCoins의 json을 data에 넣을 것이다.
const { isLoading, data } = useQuery(&quot;allCoins&quot;, fetchCoins);&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;위에서 작성한 fetch 방식을 이 한줄로 대체할 수 있다. 엄청나다!&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그럼 이제 어떻게 사용하는지 알아보자!&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;React Query 사용방법&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. React Query를 사용하기 위해서는 &lt;span style=&quot;background-color: #dddddd;&quot;&gt;QueryClientProvider&lt;/span&gt;를 애플리케이션의 최상단에 작성해줘야한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 그리고 쿼리 인스턴스를 생성하고(&lt;span style=&quot;background-color: #dddddd;&quot;&gt;new QueryClient()&lt;/span&gt;) &lt;span style=&quot;background-color: #dddddd;&quot;&gt;client={queryClient}&lt;/span&gt;를 작성해준다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1689133031279&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;import { QueryClient, QueryClientProvider } from &quot;react-query&quot;;

const queryClient = new QueryClient();

export default function App() {
  return (
    &amp;lt;QueryClientProvider client={queryClient}&amp;gt;
      &amp;lt;Home /&amp;gt;
    &amp;lt;/QueryClientProvider&amp;gt;
  );
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 이제 useQuery를 추가적으로 import하여 사용하면 된다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1689133089689&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;import { useQuery } from &quot;react-query&quot;;
// 주로 사용되는 3가지 return 값 외에도 더 많은 return 값들이 있다. 
const { data, isLoading, error } = useQuery(queryKey, queryFn, options)&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;간단하게 위의 코드를 설명하자면 아래와 같다.&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;1. useQuery는 queryFn 함수를 부르고,&amp;nbsp;&lt;/li&gt;
&lt;li&gt;2. 해당 함수가 로딩중이라면 isLoading에서 알려줄 것이고, =&amp;gt; 기존 fetch 방식에서의 loading state 대체&lt;/li&gt;
&lt;li&gt;3. 해당 함수가 종료되었다면 그 함수의 json을 data에 넣어준다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;React Query hook 더 알아보기&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;queryKey&lt;/b&gt;&lt;/h4&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;queryKey를 기반으로 &lt;b&gt;데이터 캐싱&lt;/b&gt;을 관리한다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;문자열 or 배열로 지정할 수 있다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;queryFn&lt;/b&gt;&lt;/h4&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;b&gt;promise&lt;/b&gt;를 반환하는 함수를 넣어줘야한다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;options&lt;/b&gt;&lt;/h4&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;옵션값은 너무너무 다양해서 필요할 때마다 직접 찾아서 사용하면 됩니다. 하단의 참고링크를 보면 다양한 옵션과 옵션에 대한 설명이 적혀있습니다!&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;정리하기&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React Query는&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 훨씬 편리한 방식으로 데이터를 fetch할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 데이터를 &lt;b&gt;캐시&lt;/b&gt;에 저장해주기 때문에 데이터를 유지할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그래서 react-query의 useQuery 언제 사용할까?에 대한 답변은..&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;데이터를 가져오고 관리할 때 사용하면 된다!&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;보다 짧은 코드로 직관적으로 사용할 수 있기 때문에 엄청 매력적이다! 기본으로 제공해주는 여러 처리들과 옵션들도 아주 매력적이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;가장 큰 장점으로는 아래와 같은 것들이 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 데이터 가져오기&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 데이터 캐싱 및 자동 업데이트&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;데이터를 캐싱하여 이전 결과를 재사용하고, 자동으로 해당 값을 기반으로 업데이트된다. 따라서 데이터를 효율적으로 관리할 수 있고, 자동으로 최신 데이터를 사용할 수 있다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 데이터 의존성 처리&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;한 쿼리가 다른 쿼리의 결과에 의존하는 경우, 의존하는 쿼리가 업데이트될 때 자동으로 재쿼리하여 관련된 데이터를 가져올 수 있다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 로딩 및 에러 처리&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 데이터 변환 및 가공&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;queryFn과 option을 사용하여 데이터를 변환하고 가공할 수 있다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;단점으로는..&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. Promise 기반의 비동기 작업을 수행하는 함수와 사용해야 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 성능 고려&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;캐싱 및 자동 업데이트를 제공하기 때문에 데이터가 많은 경우, 빈번한 업데이트가 있는 경우에는 성능에 영향을 줄 수 있기 때문에 쿼리 옵션을 조정하는 등의 관리를 통해 최적의 성능을 유지해야 한다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://tanstack.com/query/latest/docs/react/reference/useQuery?from=reactQueryV3&amp;amp;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Freference%2FuseQuery&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;useQuery 옵션들&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>React</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/130</guid>
      <comments>https://1two13.tistory.com/entry/react-query%EC%9D%98-useQuery-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C#entry130comment</comments>
      <pubDate>Wed, 12 Jul 2023 12:58:16 +0900</pubDate>
    </item>
    <item>
      <title>[원티드] 프리온보딩 프론트엔드 챌린지 1-1주차 정리</title>
      <link>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-%ED%94%84%EB%A6%AC%EC%98%A8%EB%B3%B4%EB%94%A9-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%B1%8C%EB%A6%B0%EC%A7%80-1-1%EC%A3%BC%EC%B0%A8-%EC%A0%95%EB%A6%AC</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1200&quot; data-origin-height=&quot;305&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/HeF8c/btsm8PIAcvW/2BVrHmOy3u05VnJEfAPPj1/img.webp&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/HeF8c/btsm8PIAcvW/2BVrHmOy3u05VnJEfAPPj1/img.webp&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/HeF8c/btsm8PIAcvW/2BVrHmOy3u05VnJEfAPPj1/img.webp&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHeF8c%2Fbtsm8PIAcvW%2F2BVrHmOy3u05VnJEfAPPj1%2Fimg.webp&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;825&quot; height=&quot;210&quot; data-origin-width=&quot;1200&quot; data-origin-height=&quot;305&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;강의를 듣고 정리한 내용입니다.&amp;nbsp;&lt;/p&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&amp;nbsp;&lt;/h3&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;MPA를 활용한 사이트의 특징과 장단점은 무엇인가요?&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;MPA는 Multi Page Application으로 여러 개의 HTML 파일로 웹 애플리케이션을 구성하는 방식입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;라우팅에 필요한 라이브러리나 번들링에 필요한 여러 자바스크립트 툴체인이 필요 없고,&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;정적 페이지를 그대로 서빙하기 때문에 SEO나 페이지 로딩 속도 측면에서 장점이 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 새로고침 시 새로운 내용이 반영된 HTML 페이지를 가져오는데까지의 시간이 소요되기 때문에 유저가 빈 화면을 보게 된다는 단점이 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;추가로 MPA의 통신 상황은 아래와 같습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 유저가 서버의 GET 요청을 보내고, blog.html을 받습니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 유저는 브라우저에서 blog.html을 열어 웹 사이트를 이용합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. blog.html 페이지 내에 있는 form 태그의 input의 유저의 정보를 담아 서버로 POST 요청을 보냅니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 서버는 새로운 blog.html을 만듭니다. 이때 유저가 가지고 있는 blog.html에서는 이 사실을 알지 못합니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 유저는 화면을 새로고침하여 서버에 새로운 blog.html을 받아와 이용합니다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;자바스크립트를 사용하지 않고 클라이언트에서 서버로 유저가 입력한 데이터를 전송하려면 어떻게 해야 할까요?&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;사용자 요청을 받은 뒤 php 등의 언어를 사용하여 &lt;b&gt;미리 준비된 템플릿을 기반&lt;/b&gt;으로 페이지를 HTML로 &lt;b&gt;그때 그때&lt;/b&gt; 구워내 응답하면 됩니다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;Form 태그의 method 속성에는 어떤 값이 올 수 있나요?&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;string과 undefined가 올 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1150&quot; data-origin-height=&quot;487&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/c0aIfF/btsm1U5gnBV/JqCl21rUzncGTvgri0f7b0/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/c0aIfF/btsm1U5gnBV/JqCl21rUzncGTvgri0f7b0/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/c0aIfF/btsm1U5gnBV/JqCl21rUzncGTvgri0f7b0/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc0aIfF%2Fbtsm1U5gnBV%2FJqCl21rUzncGTvgri0f7b0%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;770&quot; height=&quot;326&quot; data-origin-width=&quot;1150&quot; data-origin-height=&quot;487&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;AJAX란 무엇인가요?&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Asynchronous Javascript And XML의 약자로, 페이지를 &lt;b&gt;새로고침하지 않고도&lt;/b&gt; 서버와 통신을 할 수 있게 도와주는 프로그래밍 방식입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;AJAX를 사용하면 사용자 동작에 따라 필요한 부분만 동적으로 업데이트할 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 사용자 action&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 페이지가 정상 동작 + 서버에 새로운 정보 요청&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 서버한테서 정보를 받아오면 화면을 새로운 정보로 대체&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;SPA with CSR이 무엇인지 설명하고, 장단점에 대해 설명해주세요.&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;SPA 방식으로 CSR을 구현한 웹 서비스는 최초 통신을 할 때 화면 그리기에 필요한 모든 재료들을 브라우저에 가져다 놓고, 그려야 하는 화면에 맞춰 재료를 알맞게 조립하는 방식입니다. 추가로 필요한 재료가 있을 경우 필요한 시점에 필요한 만큼 서버에서 받아오게 됩니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;기존에 비해 페이지 전환이 부드럽고, 기존 방식에 비해 훨씬 동적이라는 장점이 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;단점으로는 초기 로딩 속도가 느릴 수 있기 때문에 사용자 경험에 부정적인 영향을 줄 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;JavaScript로 직접 CSR을 구현하지 않고 React를 사용하는 이유에 대해 설명해주세요.&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;대규모 앱의 상태를 관리하고, 퍼포먼스를 보장하기 위해서는 React를 사용하는 것이 효과적이기 때문입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;조금 더 자세히 말하자면, React는 변화가 있을 때마다 실제 DOM을 업데이트하지 않고, 메모리에 올려둔 가상 DOM을 업데이트 합니다. 또한 이러한 변화가 잦을 것을 대비하여 변화를 반영하는 타이밍을 스케줄러를 통해 관리하고, 변화는 스케줄러에 의해 배치로 모아진 다음 적절한 타이밍에 비동기적으로 한꺼번에 처리되기 때문입니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>etc/개발 세미나</category>
      <category>CSR</category>
      <category>MPA</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/129</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-%ED%94%84%EB%A6%AC%EC%98%A8%EB%B3%B4%EB%94%A9-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%B1%8C%EB%A6%B0%EC%A7%80-1-1%EC%A3%BC%EC%B0%A8-%EC%A0%95%EB%A6%AC#entry129comment</comments>
      <pubDate>Mon, 10 Jul 2023 15:10:36 +0900</pubDate>
    </item>
    <item>
      <title>[원티드] 프리온보딩 프론트엔드 챌린지 7월 - 사전과제</title>
      <link>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-%ED%94%84%EB%A6%AC%EC%98%A8%EB%B3%B4%EB%94%A9-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%B1%8C%EB%A6%B0%EC%A7%80-7%EC%9B%94-%EC%82%AC%EC%A0%84%EA%B3%BC%EC%A0%9C</link>
      <description>&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1200&quot; data-origin-height=&quot;305&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/tkD76/btsmGgO0G6P/rTzy6ieHs7dPs12VfAiza1/img.webp&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/tkD76/btsmGgO0G6P/rTzy6ieHs7dPs12VfAiza1/img.webp&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/tkD76/btsmGgO0G6P/rTzy6ieHs7dPs12VfAiza1/img.webp&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtkD76%2FbtsmGgO0G6P%2FrTzy6ieHs7dPs12VfAiza1%2Fimg.webp&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;707&quot; height=&quot;180&quot; data-origin-width=&quot;1200&quot; data-origin-height=&quot;305&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;원티드 7월 챌린지에 참여하게 된 이유는 Next.js에 대해 공부해보고 싶어서였다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2주동안 주2회 3시간씩 진행이 되는 실시간 강의이다보니깐 깊게 배우지는 못해도 얻어가는 게 분명히 있을거라고 생각했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;사전과제는 총 3개였다.&amp;nbsp;&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;1. CSR(Client-side Rendering)이란 무엇이며, 그것의 장단점에 대하여 설명해주세요.&lt;br /&gt;2. SPA(Single Page Application)로 구성된 웹 앱에서 SSR(Server-side Rendering)이 필요한 이유에 대하여 설명해주세요.&lt;br /&gt;3. Next.js 프로젝트에서 yarn start(or npm run start) 스크립트를 실행했을 때 실행되는 코드를 Next.js Github 레포지토리에서 찾은 뒤, 해당 파일에 대한 간단한 설명을 첨부해주세요.&lt;/blockquote&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;1. &lt;span style=&quot;text-align: left;&quot;&gt;CSR(Client-side Rendering)이란 무엇이며, 그것의 장단점에 대하여 설명해주세요.&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;span style=&quot;text-align: left;&quot;&gt;이 질문에 대해서는 면접 스터디를 준비하면서 정리해 둔게 있었다. &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;span style=&quot;text-align: left;&quot;&gt;CSR은 &lt;b&gt;최초 로드&lt;/b&gt; 시 필요한 파일들을 &lt;b&gt;전부&lt;/b&gt; 받고, 사용자 인터렉션에 따라 클라이언트 단에서 &lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;필요한 데이터를 서버로부터 비동기적으로 받아와&lt;/span&gt; 렌더링해주는 방식이다. &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;초반에 뼈대만 다운받기 때문에, 즉 초기 로딩 시 HTML 파일이 비어있기 때문에, 검색 엔진 크롤러(SEO)에게 적절한 컨텐츠를 제공하는 것이 어렵다는 단점과 초기 화면의 렌더링 속도가 느리다는 단점이 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 필요한 데이터만 가져와서 업데이트할 수 있기 때문에 사용자 경험이 향상될 수 있고, 초기 렌더링 이후에는 클라이언트 측에서 대부분의 작업을 처리하기 때문에 서버 부하가 감소한다는 장점이 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;&lt;span style=&quot;color: #000000;&quot;&gt;2. &lt;span style=&quot;text-align: left;&quot;&gt;SPA(Single Page Application)로 구성된 웹 앱에서 SSR(Server-side Rendering)이 필요한 이유에 대하여 설명해주세요.&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;span style=&quot;text-align: left;&quot;&gt;먼저 SSR은 서버가 완전하게 만들어진 HTML 파일을 받아서 렌더링하는 방식으로 CSR의 단점을 극복할 수 있다.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;span style=&quot;text-align: left;&quot;&gt;하지만 서버에서 페이지를 렌더링하기 때문에 서버의 부하가 증가한다는 단점이 있다. 그리고 SSR은 초기 렌더링만 처리하기 때문에, 클라이언트 측에서 추가적인 상호작용을 위한 JS 코드를 작성해야 할 수 있다.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;SPA&lt;/b&gt;로 구성된 웹 앱들은 기본적으로 &lt;b&gt;CSR&lt;/b&gt;이기 때문에 CSR의 단점을 극복하기 위해 SSR이 필요하다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;SSR을 사용하면 &lt;b&gt;검색 엔진 최적화&lt;/b&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;와&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;b&gt;초기 로딩 속도 개선&lt;/b&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;span&gt;에 이점이 있다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;&lt;b&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;span&gt;1. 검색 엔진 최적화&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;span&gt;이는 결국 사용자 경험을 개선하는데 도움을 준다.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;&lt;b&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;span&gt;2. 초기 로딩 속도 개선&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;span&gt;SPA는 기본적으로 CSR이기 때문에 자바스크립트를 로드하면서 사용자가 이탈되지 않도록 해야한다.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;&lt;span style=&quot;text-align: left;&quot;&gt;3. Next.js 프로젝트에서 yarn start(or npm run start) 스크립트를 실행했을 때 실행되는 코드를 Next.js Github 레포지토리에서 찾은 뒤, 해당 파일에 대한 간단한 설명을 첨부해주세요.&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul style=&quot;list-style-type: disc; background-color: #f8f9fa; color: #212529; text-align: left;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://nextjs.org/docs/getting-started&quot;&gt;https://nextjs.org/docs/getting-started&lt;/a&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;(Next.js 세팅 가이드)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vercel/next.js/&quot;&gt;https://github.com/vercel/next.js/&lt;/a&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;(Next.js Github 레포지토리)&lt;/li&gt;
&lt;li&gt;_document.js,&lt;span&gt;&amp;nbsp;&lt;/span&gt;_app.js,&lt;span&gt;&amp;nbsp;&lt;/span&gt;getServerSideProps&lt;span&gt;&amp;nbsp;&lt;/span&gt;같은 요소들에 대해 설명을 요구하는 과제가 아닙니다. 오히려 Next.js 코드 베이스 내부를 살펴보라는 의미입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;span style=&quot;text-align: left;&quot;&gt;1. Next.js를 먼저 설치했다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;dsconfig&quot; style=&quot;color: #000000; text-align: left;&quot;&gt;&lt;code&gt;npx create-next-app my-app&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;264&quot; data-origin-height=&quot;309&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/cpdoQe/btsmJCiqDlk/PLyKOZaKiAuO0qiahgedD1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/cpdoQe/btsmJCiqDlk/PLyKOZaKiAuO0qiahgedD1/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cpdoQe/btsmJCiqDlk/PLyKOZaKiAuO0qiahgedD1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcpdoQe%2FbtsmJCiqDlk%2FPLyKOZaKiAuO0qiahgedD1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;225&quot; height=&quot;263&quot; data-origin-width=&quot;264&quot; data-origin-height=&quot;309&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;span style=&quot;text-align: left;&quot;&gt;2. npm run start 명령어로 실행되는 코드를 &lt;a href=&quot;https://github.com/vercel/next.js/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Next.js 깃헙 레포&lt;/a&gt;에서 찾아봤다.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;span style=&quot;text-align: left;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;next-start.ts 파일이고, packages &amp;gt; next &amp;gt; src &amp;gt; cli &amp;gt; next-start.ts 경로를 통해 확인할 수 있다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;pre id=&quot;code_1688668936724&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;#!/usr/bin/env node

import arg from 'next/dist/compiled/arg/index.js'
import { startServer } from '../server/lib/start-server'
import { getPort, printAndExit } from '../server/lib/utils'
import isError from '../lib/is-error'
import { getProjectDir } from '../lib/get-project-dir'
import { CliCommand } from '../lib/commands'
import { resolve } from 'path'
import { PHASE_PRODUCTION_SERVER } from '../shared/lib/constants'
import loadConfig from '../server/config'

const nextStart: CliCommand = async (argv) =&amp;gt; {
  const validArgs: arg.Spec = {
    // Types
    '--help': Boolean,
    '--port': Number,
    '--hostname': String,
    '--keepAliveTimeout': Number,

    // Aliases
    '-h': '--help',
    '-p': '--port',
    '-H': '--hostname',
  }
  let args: arg.Result&amp;lt;arg.Spec&amp;gt;
  try {
    args = arg(validArgs, { argv })
  } catch (error) {
    if (isError(error) &amp;amp;&amp;amp; error.code === 'ARG_UNKNOWN_OPTION') {
      return printAndExit(error.message, 1)
    }
    throw error
  }
  if (args['--help']) {
    console.log(`
      Description
        Starts the application in production mode.
        The application should be compiled with \`next build\` first.

      Usage
        $ next start &amp;lt;dir&amp;gt; -p &amp;lt;port&amp;gt;

      &amp;lt;dir&amp;gt; represents the directory of the Next.js application.
      If no directory is provided, the current directory will be used.

      Options
        --port, -p          A port number on which to start the application
        --hostname, -H      Hostname on which to start the application (default: 0.0.0.0)
        --keepAliveTimeout  Max milliseconds to wait before closing inactive connections
        --help, -h          Displays this message
    `)
    process.exit(0)
  }

  const dir = getProjectDir(args._[0])
  const host = args['--hostname']
  const port = getPort(args)

  const keepAliveTimeoutArg: number | undefined = args['--keepAliveTimeout']
  if (
    typeof keepAliveTimeoutArg !== 'undefined' &amp;amp;&amp;amp;
    (Number.isNaN(keepAliveTimeoutArg) ||
      !Number.isFinite(keepAliveTimeoutArg) ||
      keepAliveTimeoutArg &amp;lt; 0)
  ) {
    printAndExit(
      `Invalid --keepAliveTimeout, expected a non negative number but received &quot;${keepAliveTimeoutArg}&quot;`,
      1
    )
  }

  const keepAliveTimeout = keepAliveTimeoutArg
    ? Math.ceil(keepAliveTimeoutArg)
    : undefined

  const config = await loadConfig(
    PHASE_PRODUCTION_SERVER,
    resolve(dir || '.'),
    undefined,
    undefined,
    true
  )

  await startServer({
    dir,
    isDev: false,
    hostname: host,
    port,
    keepAliveTimeout,
    useWorkers: !!config.experimental.appDir,
  })
}

export { nextStart }&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;코드를 보면 --help와 같은 옵션에 대한 실행 내용이 있고, 옵션을 줄여 쓰기 위해 alias 설정까지 하나하나 해주는 것을 확인할 수 있다.&lt;/p&gt;
&lt;p style=&quot;background-color: #ffffff; color: #212529; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;그리고 import를 보면&lt;span&gt;&amp;nbsp;&lt;/span&gt;{ startServer }&lt;span&gt;&amp;nbsp;&lt;/span&gt;객체를 가져와 적용하는 것을 확인할 수 있다.&lt;/p&gt;
&lt;p style=&quot;background-color: #ffffff; color: #212529; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;즉, startServer 함수를 실행하기 위해 여러 값들을 설정하고, 해당 함수로 넘겨주고 있는 것이다.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;background-color: #ffffff; color: #212529; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;3. startServer 객체를 import 해오는 파일로 가보면(packages &amp;gt; next &amp;gt; src &amp;gt; server &amp;gt; lib &amp;gt; start-server.ts) createServer 메서드를 사용하여 서버를 활성화해준다는 것을 알 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-filename=&quot;blob&quot; data-origin-width=&quot;486&quot; data-origin-height=&quot;308&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/S4tGu/btsmKVhM0pO/KWrh9kavUxiF2BPMytGbRk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/S4tGu/btsmKVhM0pO/KWrh9kavUxiF2BPMytGbRk/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/S4tGu/btsmKVhM0pO/KWrh9kavUxiF2BPMytGbRk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FS4tGu%2FbtsmKVhM0pO%2FKWrh9kavUxiF2BPMytGbRk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; data-filename=&quot;blob&quot; data-origin-width=&quot;486&quot; data-origin-height=&quot;308&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;npm start 명령어를 실행했을 때 실행되는 파일들을 살펴볼 수 있는 계기가 되었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그리고 Next.js는 단순히 소스코드만 작성되어 있는 것이 아닌, 서버까지 구동시키는 풀스택 앱이라는 것을 알게 되었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Next.js를 직접 사용해보면 이 매력을 더 알 수 있게 되지 않을까라고 생각한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>etc/개발 세미나</category>
      <category>CSR</category>
      <category>Next.js</category>
      <category>spa</category>
      <category>SSR</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/128</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-%ED%94%84%EB%A6%AC%EC%98%A8%EB%B3%B4%EB%94%A9-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%B1%8C%EB%A6%B0%EC%A7%80-7%EC%9B%94-%EC%82%AC%EC%A0%84%EA%B3%BC%EC%A0%9C#entry128comment</comments>
      <pubDate>Fri, 7 Jul 2023 08:43:38 +0900</pubDate>
    </item>
    <item>
      <title>자료구조 - 연결 리스트</title>
      <link>https://1two13.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;연결 리스트는 배열과 마찬가지로 항목의 리스트를 표현하는 자료 구조다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;메모리에 곳곳에 흩어진 연결된 데이터를 &lt;b&gt;노드&lt;/b&gt;라고 부르고, 각 노드는 &lt;b&gt;다음 노드의 메모리 주소&lt;/b&gt;도 포함한다. 이를 &lt;b&gt;링크&lt;/b&gt;라고 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;노드와 연결리스트를 직접 코드로 구현해봤다. 여기서 length는 노드의 개수이고, head는 첫 노드의 주소이다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1688526073781&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;class Node {
  next = null;
  constructor(data) {
    this.data = data;
  }
}

class LinkedList {
  length = 0;
  head = null;    
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;데이터를 추가, 검색, 삭제하는 메소드도 추가로 구현해보았다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1688526188804&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;class Node {
  next = null;
  constructor(data) {
    this.data = data;
  }
}

class LinkedList {
  length = 0;
  head = null;

  add(value) {
    const node = new Node(value);
    let current = this.head;
    if (!current) { // 현재 아무 노드도 없으면
      this.head = node; // head에 새 노드를 추가합니다.
      this.length++;
      return node;
    } else { // 이미 노드가 있으면
      while (current.next) { // 마지막 노드를 찾고.
        current = current.next;
      }
      current.next = node; // 마지막 위치에 노드를 추가합니다.
      this.length++;
      return node;
    }
  }
  
  search(position) {
    let current = this.head;
    let count = 0;
    while (count &amp;lt; position) { // position 위치만큼 이동합니다.
      current = current.next;
      count++;
    }
    return current?.data; // data가 없으면 undefined
  }
  
  remove(position) {
    let current = this.head;
    let before;
    let remove;
    let count = 0;
    if (position == 0) { // 맨 처음 노드를 삭제하면
      remove = this.head;
      this.head = this.head.next; // head를 두 번째 노드로 교체
      this.length--;
      return remove;
    }
    // 그 외의 다른 노드를 삭제하면
    while (count &amp;lt; position) {
      before = current;
      count++;
      current = current.next;
    }
    remove = current;
    before.next = remove.next;
    // remove 메모리 정리
    this.length--;
    return remove;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;위는 한 쪽 방향으로만 이동하는 연결 리스트이기 때문에 뒤로 가기는 불편하다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이걸 해결한 리스트가 바로 이중 연결 리스트이다. 다음 노드를 가리키는 next 외의 this.prev를 넣어 이전 노드를 가리키도록 해주면 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;또한 위는 하나의 데이터씩만 연결되어 있지만 한 노드에서 여러 노드를 연결하는 다중 연결 리스트도 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;this.next를 노드들의 배열로 만들면 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;시간복잡도&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;b&gt;맨 앞 추가 =&amp;gt; O(1)&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;맨 뒤 추가 =&amp;gt; O(n)&lt;/li&gt;
&lt;li&gt;검색 =&amp;gt; O(n)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;맨 앞 삭제&lt;span style=&quot;color: #333333; text-align: left;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;=&amp;gt; &lt;span&gt;&lt;/span&gt;&lt;/span&gt;O(1)&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;맨 뒤 삭제 =&amp;gt; O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;연결 리스트가 배열보다 강력한 장점을 보이는 연산은 바로 맨 앞에 삽입, 삭제하는 경우이다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;맨 앞에 데이터를 추가, 삭제할 때 배열의 경우 O(n)의 시간복잡도가 소요되지만, 연결 리스트의 경우 O(1)의 시간 복잡도가 소요되기 때문이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;배열과 연결 리스트 비교&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%; height: 94px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot; data-ke-style=&quot;style13&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 20px;&quot;&gt;
&lt;td style=&quot;width: 33.3333%; height: 20px; text-align: center;&quot;&gt;연산&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%; height: 20px; text-align: center;&quot;&gt;배열&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%; height: 20px; text-align: center;&quot;&gt;연결 리스트&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 20px;&quot;&gt;
&lt;td style=&quot;width: 33.3333%; height: 20px; text-align: center;&quot;&gt;읽기&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%; height: 20px; text-align: center;&quot;&gt;&lt;b&gt;O(1)&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%; height: 20px; text-align: center;&quot;&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 18px;&quot;&gt;
&lt;td style=&quot;width: 33.3333%; height: 18px; text-align: center;&quot;&gt;검색&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%; height: 18px; text-align: center;&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%; height: 18px; text-align: center;&quot;&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 18px;&quot;&gt;
&lt;td style=&quot;width: 33.3333%; height: 18px; text-align: center;&quot;&gt;삽입&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%; height: 18px; text-align: center;&quot;&gt;O(n) - 끝에서는 O(1)&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%; height: 18px; text-align: center;&quot;&gt;O(n) - 앞에서는 O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 18px;&quot;&gt;
&lt;td style=&quot;width: 33.3333%; height: 18px; text-align: center;&quot;&gt;삭제&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%; height: 18px; text-align: center;&quot;&gt;O(n) - 끝에서는 O(1)&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%; height: 18px; text-align: center;&quot;&gt;O(n) - 앞에서는 O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zerocho.com/category/Algorithm/post/58008a628475ed00152d6c4d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;제로초 블로그&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problemset?sort=ac_desc&amp;amp;algo=154&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;백준 문제 모음&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=dvKuG3gfLFQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;유튜브&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>알고리즘/자료구조</category>
      <category>Linked list</category>
      <category>연결리스트</category>
      <category>자료구조</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/127</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8#entry127comment</comments>
      <pubDate>Fri, 7 Jul 2023 01:31:07 +0900</pubDate>
    </item>
    <item>
      <title>[백준/연결리스트/JS] 에디터</title>
      <link>https://1two13.tistory.com/entry/%EB%B0%B1%EC%A4%80%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8JS-%EC%97%90%EB%94%94%ED%84%B0</link>
      <description>&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;&lt;b&gt;문제 설명&lt;/b&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;figure id=&quot;og_1688633348834&quot; contenteditable=&quot;false&quot; data-ke-type=&quot;opengraph&quot; data-ke-align=&quot;alignCenter&quot; data-og-type=&quot;website&quot; data-og-title=&quot;1406번: 에디터&quot; data-og-description=&quot;첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수&quot; data-og-host=&quot;www.acmicpc.net&quot; data-og-source-url=&quot;https://www.acmicpc.net/problem/1406&quot; data-og-url=&quot;https://www.acmicpc.net/problem/1406&quot; data-og-image=&quot;https://scrap.kakaocdn.net/dn/SGFu8/hyTfqwswc3/IeiyMCWTv7NzNFDaj3yMOk/img.png?width=2834&amp;amp;height=1480&amp;amp;face=0_0_2834_1480&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1406&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-source-url=&quot;https://www.acmicpc.net/problem/1406&quot;&gt;
&lt;div class=&quot;og-image&quot; style=&quot;background-image: url('https://scrap.kakaocdn.net/dn/SGFu8/hyTfqwswc3/IeiyMCWTv7NzNFDaj3yMOk/img.png?width=2834&amp;amp;height=1480&amp;amp;face=0_0_2834_1480');&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;og-text&quot;&gt;
&lt;p class=&quot;og-title&quot; data-ke-size=&quot;size16&quot;&gt;1406번: 에디터&lt;/p&gt;
&lt;p class=&quot;og-desc&quot; data-ke-size=&quot;size16&quot;&gt;첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수&lt;/p&gt;
&lt;p class=&quot;og-host&quot; data-ke-size=&quot;size16&quot;&gt;www.acmicpc.net&lt;/p&gt;
&lt;/div&gt;
&lt;/a&gt;&lt;/figure&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;소문자만, 600000글자까지&lt;/li&gt;
&lt;li&gt;커서 위치: 문장 맨 앞, 문장 맨 뒤, 문자 사이&lt;/li&gt;
&lt;li&gt;맨 처음에 커서는 맨 뒤에 위치&lt;/li&gt;
&lt;li&gt;L: 왼쪽으로 한칸&lt;/li&gt;
&lt;li&gt;D: 오른쪽으로 한칸&lt;/li&gt;
&lt;li&gt;B: 왼쪽에 있는 문자 삭제&lt;/li&gt;
&lt;li&gt;P$: $를 커서 왼쪽에 추가&lt;/li&gt;
&lt;/ul&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;입력값: 문자열, 명령어 개수, 명령어들&lt;/li&gt;
&lt;li&gt;출력값: 입력값에 모든 명령어 수행한 후의 결과값&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;시간 복잡도&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;arr.splice()&lt;/b&gt;&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;삭제하려는 요소의 위치, 배열 개수에 따라서 시간 복잡도가 달라진다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;삭제하려는 요소가 배열의 맨 끝에 위치할 경우 =&amp;gt; O(1)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그 외 =&amp;gt; O(n)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;arr.slice()&lt;/b&gt;&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;자르는 요소의 개수에 따라 시간 복잡도가 달라진다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;자르는 요소를 k개라고 할 때 O(k)의 시간복잡도를 가진다.&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&amp;nbsp;&lt;/h2&gt;
&lt;h2 style=&quot;color: #000000;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;틀린 부분&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;pre id=&quot;code_1688633234696&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;let [str, n, ...list] = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
list = list.map((el) =&amp;gt; el.split(' '));
str = str.split('');

// 처음 커서 위치
let cursor = str.length;

for (let i = 0; i &amp;lt; Number(n); i++) {
  let el = list[i];
  // list에 따른 커서 위치 이동
  if (el[0] === 'P') {
    // str에 값 추가
    // str = [...str.slice(0, cursor), el[1], ...str.slice(cursor)];
    str.splice(cursor, 0, el[1]);
    // 커서 위치 이동
    cursor++;
  } else if (el[0] === 'L' &amp;amp;&amp;amp; cursor &amp;gt; 0) {
    cursor--;
  } else if (el[0] === 'D' &amp;amp;&amp;amp; cursor &amp;lt; str.length) {
    cursor++;
  } else if (el[0] === 'B' &amp;amp;&amp;amp; cursor &amp;gt; 0) {
    // 커서 왼쪽에 있는 문자 제거
    // str = [...str.slice(0, cursor - 1), ...str.slice(cursor)];
    str.splice(cursor - 1, 1);
    cursor--;
  }
}

console.log(str.join(''));&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;color: #000000;&quot; data-ke-size=&quot;size16&quot;&gt;splie와 slice 모두 시간복잡도가 오래 걸리는 메소드라 테스트 코드 모두 통과하나 시간 초과 오류가 났다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;다른 풀이&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;pre id=&quot;code_1688641172020&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
    this.prev = null;
  }
}

// 예를 들어 A, B 사이에 C를 넣는다고 가정할 때, 
function insertAfter(node, value) {
  // 새로 추가할 노드 생성(C)
  const newNode = new Node(value);
  // 새로운 노드의 이전 노드는 현재 노드(A)
  newNode.prev = node;
  // 새로운 노드의 다음 노드는 현재 노드의 다음 노드(B)
  newNode.next = node.next;
  // 중간에 삽입하는 경우
  if (node.next) {
    // B.prev는 새로운 노드
    node.next.prev = newNode;
  }
  // 끝에 삽입하는 경우 새로 추가한 노드를 다음 노드로 변경
  node.next = newNode;
  // 새로 추가한 노드 리턴
  return newNode;
}

// 예를 들어 A, C, B가 연결되어 있다고 가정할 때
function deleteNode(node) {
  // C.prev는 A
  const prevNode = node.prev;
  // C.next는 B
  const nextNode = node.next;
  if (prevNode) {
    // A.next는 B
    prevNode.next = nextNode;
  }
  if (nextNode) {
    // B.prev는 A
    nextNode.prev = prevNode;
  }
}

let [str, n, ...list] = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
list = list.map((el) =&amp;gt; el.split(' '));

// 연결 리스트의 head에 더미 노드 할당
const head = new Node(null);
let cursor = head;

for (let i = 0; i &amp;lt; str.length; i++) {
  cursor = insertAfter(cursor, str[i]);
}

for (let i = 0; i &amp;lt; n; i++) {
  let el = list[i];
  if (el[0] === 'P') {
    cursor = insertAfter(cursor, el[1]);
  } else if (el[0] === 'L' &amp;amp;&amp;amp; cursor.prev) {
    cursor = cursor.prev;
  } else if (el[0] === 'D' &amp;amp;&amp;amp; cursor.next) {
    cursor = cursor.next;
  } else if (el[0] === 'B' &amp;amp;&amp;amp; cursor.prev) {
    const prevNode = cursor.prev;
    deleteNode(cursor);
    cursor = prevNode;
  }
}

let result = '';
let currentNode = head.next;
while (currentNode) {
  result += currentNode.value;
  currentNode = currentNode.next;
}

console.log(result);&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;코드 짜는 것도 읽는 것도 쉽지 않다.. 연습해야겠다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;연결 리스트는 class를 사용하여 구현하는 것이 더 쉽다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;스택으로 통과한 코드 추가&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;pre id=&quot;code_1689233629873&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;let [str, m, ...input] = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
let stack = [];
let arr = [];
input = input.map((el) =&amp;gt; el.split(' '));

for (let i = 0; i &amp;lt; str.length; i++) {
  stack.push(str[i]);
}

for (let i = 0; i &amp;lt; Number(m); i++) {
  let el = input[i][0];
  // $ 값 stack에 추가
  if (el === 'P') {
    stack.push(input[i][1]);
  }
  // 맨 앞이면 무시, stack.pop() 값 arr에 추가
  else if (el === 'L' &amp;amp;&amp;amp; stack.length &amp;gt; 0) {
    let popItem = stack.pop();
    arr.push(popItem);
  }
  // 맨 뒤면 무시, arr.pop() 값 stack에 추가
  else if (el === 'D' &amp;amp;&amp;amp; arr.length &amp;gt; 0) {
    let popItem = arr.pop();
    stack.push(popItem);
  }
  // 맨 앞이면 무시, stack.pop()
  else if (el === 'B' &amp;amp;&amp;amp; stack.length &amp;gt; 0) {
    stack.pop();
  }
}

arr.reverse();
console.log([...stack, ...arr].join(''));&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;기억해야 하는 정보&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;splice와 slice 모두 값비싼 작업이다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;따라서 위와 같은 문제에서는 연결리스트를 사용하여 코드를 작성해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://gobae.tistory.com/23&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;다른 접근 방식, 블로그&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>알고리즘/백준</category>
      <category>백준</category>
      <category>연결리스트</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/126</guid>
      <comments>https://1two13.tistory.com/entry/%EB%B0%B1%EC%A4%80%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8JS-%EC%97%90%EB%94%94%ED%84%B0#entry126comment</comments>
      <pubDate>Thu, 6 Jul 2023 20:31:17 +0900</pubDate>
    </item>
    <item>
      <title>[백준/연결리스트/JS] 거울냥이는 죽어서 거울을 남긴다</title>
      <link>https://1two13.tistory.com/entry/%EB%B0%B1%EC%A4%80%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8JS-%EA%B1%B0%EC%9A%B8%EB%83%A5%EC%9D%B4%EB%8A%94-%EC%A3%BD%EC%96%B4%EC%84%9C-%EA%B1%B0%EC%9A%B8%EC%9D%84-%EB%82%A8%EA%B8%B4%EB%8B%A4</link>
      <description>&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;문제 설명&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;figure id=&quot;og_1688597309000&quot; contenteditable=&quot;false&quot; data-ke-type=&quot;opengraph&quot; data-ke-align=&quot;alignCenter&quot; data-og-type=&quot;website&quot; data-og-title=&quot;16226번: 거울냥이는 죽어서 거울을 남긴다&quot; data-og-description=&quot;격자판으로 이루어진 디디몬 어드벤쳐의 어느 섬. 그 곳에는 거울냥이들이 모여 살고 있다. 거울냥이들의 생태계를 조사하던 디디는 충격적인 사실을 알게 되었다. 거울냥이들은 닿는 생명체를&quot; data-og-host=&quot;www.acmicpc.net&quot; data-og-source-url=&quot;https://www.acmicpc.net/problem/16226&quot; data-og-url=&quot;https://www.acmicpc.net/problem/16226&quot; data-og-image=&quot;https://scrap.kakaocdn.net/dn/ewuocP/hyTeclTnne/TPjbroumQXCCIK9vqm3mJ1/img.png?width=2834&amp;amp;height=1480&amp;amp;face=0_0_2834_1480&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16226&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-source-url=&quot;https://www.acmicpc.net/problem/16226&quot;&gt;
&lt;div class=&quot;og-image&quot; style=&quot;background-image: url('https://scrap.kakaocdn.net/dn/ewuocP/hyTeclTnne/TPjbroumQXCCIK9vqm3mJ1/img.png?width=2834&amp;amp;height=1480&amp;amp;face=0_0_2834_1480');&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;og-text&quot;&gt;
&lt;p class=&quot;og-title&quot; data-ke-size=&quot;size16&quot;&gt;16226번: 거울냥이는 죽어서 거울을 남긴다&lt;/p&gt;
&lt;p class=&quot;og-desc&quot; data-ke-size=&quot;size16&quot;&gt;격자판으로 이루어진 디디몬 어드벤쳐의 어느 섬. 그 곳에는 거울냥이들이 모여 살고 있다. 거울냥이들의 생태계를 조사하던 디디는 충격적인 사실을 알게 되었다. 거울냥이들은 닿는 생명체를&lt;/p&gt;
&lt;p class=&quot;og-host&quot; data-ke-size=&quot;size16&quot;&gt;www.acmicpc.net&lt;/p&gt;
&lt;/div&gt;
&lt;/a&gt;&lt;/figure&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;거울: 거울냥이의 하단, 냥이가 죽어도 거울은 남음, 거울 있으면 빔 통과하지 못함&lt;/li&gt;
&lt;li&gt;(1,1)부터 시작&lt;/li&gt;
&lt;li&gt;빔은 상하좌우 발사&lt;/li&gt;
&lt;li&gt;거울냥이가 사라지면 자기 차례와도 빔 쏘지 못함&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;입력값: 거울냥이 마릿수, 빔 쏘는 순서대로 거울냥이 위치&lt;/li&gt;
&lt;li&gt;출력값: 살아남은 거울냥이 갯수&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&amp;nbsp;&lt;/h2&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;시간 복잡도&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;시간 초과도 났고, 정답을 확인해보니 방향성도 틀렸다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;알고리즘 설계&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;처음 설계 방식 - 틀린 방식&lt;/p&gt;
&lt;pre id=&quot;code_1688597752149&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;1. 2차원 배열 생성
2. 거울 위치 구하기 =&amp;gt; mirror로 표시
3. 거울냥이 위치 구하기 =&amp;gt; cat으로 표시
4. cat 위치에서부터 상, 좌, 우로 mirror 만날때까지 반복 =&amp;gt; false로 표시
5. 2차원 배열에서 cat인 값만 세기&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;정답 설계 방식&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 객체 생성 =&amp;gt; 키: 행, &lt;span style=&quot;color: #383a42;&quot;&gt;값: [열,&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;false(거울냥이) 또는&amp;nbsp;true&lt;/span&gt;&lt;span style=&quot;color: #383a42;&quot;&gt;(거울)]&lt;/span&gt;&lt;/p&gt;
&lt;pre id=&quot;code_1688598340827&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;{
  '1': [ [ 1, false ], [ 4, false ], [ 3, false ] ],
  '2': [ [ 1, true ], [ 4, true ], [ 3, true ] ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;490&quot; data-origin-height=&quot;548&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/ILQL4/btsmzZZ4bBS/aGQqn4vPkwdFtu7YeEkXt1/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/ILQL4/btsmzZZ4bBS/aGQqn4vPkwdFtu7YeEkXt1/img.png&quot; data-alt=&quot;출처: 백준&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/ILQL4/btsmzZZ4bBS/aGQqn4vPkwdFtu7YeEkXt1/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FILQL4%2FbtsmzZZ4bBS%2FaGQqn4vPkwdFtu7YeEkXt1%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;185&quot; height=&quot;207&quot; data-origin-width=&quot;490&quot; data-origin-height=&quot;548&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: 백준&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 거울 만나면 shouldKill에 false 할당(리셋)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. shouldKill이 false면 true 할당, result++(거울 이후 첫 번째로 만난 거울냥이만 살리기)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;다른 풀이&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;pre id=&quot;code_1688624860994&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;let [n, ...cats] = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// let [n, ...cats] = `7\n1 2\n2 1\n2 3\n2 5\n3 4\n4 1\n4 2`.split('\n'); // [ '1 2', '2 1', '2 3', '2 5', '3 4', '4 1', '4 2' ]
n = Number(n);
cats = cats.map((el) =&amp;gt; el.split(' ')).map((el) =&amp;gt; el.map(Number));

let aliveCatCount = 0;
const map = {};
// 키: 행, 값: [열, false(거울냥이) 또는 true(거울)]
for (let [y, x] of cats) {
  // 거울냥이
  if (map[y] === undefined) map[y] = [];
  // 거울
  if (map[y + 1] === undefined) map[y + 1] = [];

  map[y].push([x, false]);
  map[y + 1].push([x, true]);
}

let shouldKill = false;

for (let y in map) {
  shouldKill = false;
  map[y].sort((a, b) =&amp;gt; a[0] - b[0]);

  for (let [x, isMirror] of map[y]) {
    // 리셋
    if (isMirror) {
      shouldKill = false;
      continue;
    }
    // 거울 이후 첫 번째로 만난 거울냥이++ or 거울냥이
    if (shouldKill === false) {
      shouldKill = true;
      aliveCatCount += 1;
    }
  }
}

console.log(aliveCatCount);&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;기억해야 하는 정보&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;연결리스트 문제라고는 하는데, 연결리스트로 접근하여 풀지는 않아서 아쉽다..&lt;/li&gt;
&lt;li&gt;2차원 배열을 사용할 경우 비게 되는 값들이 많기 때문에, 객체를 사용한 것도 포인트같다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;continue&lt;/b&gt;를 사용하면 아래 코드를 전부 스킵하고, 다음 포문 차례로 넘어간다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;상, 좌, 우 모두 고려해야 한다고 생각했었지만, 사실상 좌우로 쏘는 빔만 고려하면 되었다. 위로 쏘는 빔도 언젠가 거울을 만나니깐.. 안 만나도 거기에는 거울냥이가 없을 것이다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>알고리즘/백준</category>
      <category>백준</category>
      <category>연결리스트</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/125</guid>
      <comments>https://1two13.tistory.com/entry/%EB%B0%B1%EC%A4%80%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8JS-%EA%B1%B0%EC%9A%B8%EB%83%A5%EC%9D%B4%EB%8A%94-%EC%A3%BD%EC%96%B4%EC%84%9C-%EA%B1%B0%EC%9A%B8%EC%9D%84-%EB%82%A8%EA%B8%B4%EB%8B%A4#entry125comment</comments>
      <pubDate>Thu, 6 Jul 2023 15:32:42 +0900</pubDate>
    </item>
    <item>
      <title>자료구조 - 배열</title>
      <link>https://1two13.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%B0%B0%EC%97%B4</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;1. 읽기&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;b&gt;1단계&lt;/b&gt;로 배열에서 값을 찾을 수 있다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 검색&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;값이 어떤 인덱스에 있는지 찾는 것이 검색이다.&lt;/li&gt;
&lt;li&gt;선형 검색(한 번에 한 셀씩 확인하는 방법)의 경우 N개의 셀로 이루어진 배열은 &lt;b&gt;최대 N 단계&lt;/b&gt;가 소요된다.&amp;nbsp;&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 삽입&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;배열의 어디에 데이터를 삽입하는가에 따라 효율성이 다르다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;배열을 할당할 때 항상 배열의 크기를 기록하기 때문이다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;맨 뒤에 데이터를 삽입&lt;/b&gt;하는 경우 =&amp;gt;&lt;b&gt; 1단계&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;그 외&lt;/b&gt;(N개의 원소 전부 이동 + 실제 삽입 단계) =&amp;gt;&lt;b&gt; N + 1 단계&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 삭제&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;b&gt;최대 N단계(삭제 + 데이터 이동)&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>알고리즘/자료구조</category>
      <category>배열</category>
      <category>자료구조</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/123</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%B0%B0%EC%97%B4#entry123comment</comments>
      <pubDate>Wed, 5 Jul 2023 10:45:29 +0900</pubDate>
    </item>
    <item>
      <title>10일간의 해커톤 - 기획부터 배포까지(포텐데이 후기, 회고)</title>
      <link>https://1two13.tistory.com/entry/10%EC%9D%BC%EA%B0%84%EC%9D%98-%ED%95%B4%EC%BB%A4%ED%86%A4-%EA%B8%B0%ED%9A%8D%EB%B6%80%ED%84%B0-%EB%B0%B0%ED%8F%AC%EA%B9%8C%EC%A7%80%EB%B9%84%EC%82%AC%EC%9D%B4%EB%93%9C-%ED%8F%AC%ED%85%90%EB%8D%B0%EC%9D%B4</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;전에 인스타그램에서 보았던 해커톤 프로그램인데 백엔드 개발자와는 협업해본 경험이 있지만, 기획자와 디자이너와는 협업해본 경험은 없어, 취업 전에 이러한 경험을 하면 좋을 것 같아 신청하게 되었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;비사이드에서 진행하는 프로그램인 포텐데이는 딱 10일간 몰입하여 서비스 하나를 완성시키는 온라인 해커톤이다.&amp;nbsp;&lt;/p&gt;
&lt;figure id=&quot;og_1688517369697&quot; contenteditable=&quot;false&quot; data-ke-type=&quot;opengraph&quot; data-ke-align=&quot;alignCenter&quot; data-og-type=&quot;website&quot; data-og-title=&quot;비사이드 : IT 프로젝트 경험을 통해 성장하세요!&quot; data-og-description=&quot;&quot; data-og-host=&quot;bside.best&quot; data-og-source-url=&quot;https://bside.best/potenday&quot; data-og-url=&quot;https://bside.best&quot; data-og-image=&quot;https://scrap.kakaocdn.net/dn/C2Mf2/hyTcMuGfkU/DKYdF82nD2Jg3hjAf55BBK/img.png?width=1200&amp;amp;height=630&amp;amp;face=0_0_1200_630&quot;&gt;&lt;a href=&quot;https://bside.best/potenday&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-source-url=&quot;https://bside.best/potenday&quot;&gt;
&lt;div class=&quot;og-image&quot; style=&quot;background-image: url('https://scrap.kakaocdn.net/dn/C2Mf2/hyTcMuGfkU/DKYdF82nD2Jg3hjAf55BBK/img.png?width=1200&amp;amp;height=630&amp;amp;face=0_0_1200_630');&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;og-text&quot;&gt;
&lt;p class=&quot;og-title&quot; data-ke-size=&quot;size16&quot;&gt;비사이드 : IT 프로젝트 경험을 통해 성장하세요!&lt;/p&gt;
&lt;p class=&quot;og-desc&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p class=&quot;og-host&quot; data-ke-size=&quot;size16&quot;&gt;bside.best&lt;/p&gt;
&lt;/div&gt;
&lt;/a&gt;&lt;/figure&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;결론부터 말하자면.. 밤 새지 않는 온라인 해커톤이라고 하는데,&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;욕심이 난다면 밤을 무조건 새게 될 것이라는 것과.. 팀원을 잘 만나면 정말 좋은 경험이 될 수 있다는 것이다!&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;나는 정말 운이 좋게도 팀원을 너무 잘 만나서 10일간 잘 으쌰으쌰해서 배포까지 이어질 수 있었던 것 같다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;보통 팀은 기획자, 디자이너, 프론트, 백엔드 이렇게 이루어진다.&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;나는 프론트 개발자로 참여하였다.&amp;nbsp;&lt;/b&gt;&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;서로서로 개인적으로 컨텍을 하거나, 컨텍이 되지 않은 사람들끼리 모여서 팀을 이루거나, 제 5의 멤버로 합류되어 프로젝트를 진행하기도 한다. 나는 개인적으로 컨텍을 받아 팀에 합류하게 되었다! 그리고 추가적으로 프론트엔드 개발자 분이 한 분 더 있으면 더 좋은 퀄리티의 서비스를 개발할 수 있을 것 같아 제 5의 멤버를 섭외(?) 했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그래서 우리팀은 기획자, 디자이너, 프론트 2명, 백엔드 이렇게 총 5명의 팀원으로 서비스 개발을 시작했다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2370&quot; data-origin-height=&quot;648&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bmdzdb/btsmmPRSnfn/bNPk2p7U4uOKQTPwab2TpK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bmdzdb/btsmmPRSnfn/bNPk2p7U4uOKQTPwab2TpK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bmdzdb/btsmmPRSnfn/bNPk2p7U4uOKQTPwab2TpK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbmdzdb%2FbtsmmPRSnfn%2FbNPk2p7U4uOKQTPwab2TpK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;706&quot; height=&quot;193&quot; data-origin-width=&quot;2370&quot; data-origin-height=&quot;648&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;디자이너를 맡아주신 분께서 정말 손이 빠르셔서 1일만에 와이어프레임이 전부 나와, 생각했던 것보다 훨씬 빠르게 CSS를 작성할 수 있었다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;다른 프론트엔드 개발자분과 협업을 하기 위해 초기 세팅 및 규칙을 설정했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;팀 프로젝트 경험이 없다고 하셔서 &lt;b&gt;초기 세팅은 전부 내가 진행했다.&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;react, redux-toolkit, tailwind css, styled components&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;eslint, prettier, eslint plugin, husky, husky commitlint 등을 설치하고, 보기 좋게 문서화 작업을 먼저 시작했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;추가로 깃헙 관리를 위한 이슈와 풀리퀘 양식도 추가했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;초기 세팅 작업이 끝난 후 서로 반씩 나누어서 와이어프레임을 기반으로 CSS를 작성했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;내가 작성한 부분은 권한 설정, 위치 등록, 검색, 카테고리, 글 작성, 카테고리 리스트, 게시물, 내 정보 변경, 마이 페이지 등이다!&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;와이어 프레임 기반으로 CSS 작업을 끝낸 후 부터는 본격적으로 기능 개발을 시작했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;내가 맡은 페이지들은 짜잘짜잘한 기능들이 많은 편이라 예상보다 오랜 시간이 걸렸었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 역시나 개발하는 것은 재밌었다..!&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;백엔드 서버가 제출하기 10시간 전쯤.. 완성이 되어 백엔드 없이 더미 JSON을 사용하여 미리 예측하고 코드를 작성하였다. 이 과정에서 많은 어려움이 있었지만 현업에서도 이러한 방식으로 개발하게 되지 않을까 싶어 미리 연습한다는 생각으로 코드를 작성했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;항상 서버가 미리 구축되어 있거나, 협업을 통해 같이 개발하곤 했어서 내가 이러한 부분이 부족하구나라는 것을 깨닫고, 서버 없이도 api만 입히면 정상적으로 기능이 작동하게끔 구현하는 연습을 해야겠다고 생각했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;기능을 구현하면서 어려웠던 부분들도 물론 많았지만, 이건 추후 리팩터링을 거치면서 따로 블로깅을 해보려고 한다..!&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;기능적인 오류는 설명 하려면 끝이 없다~~~&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;나는 솔직히 우리팀이 1등할 줄 알았다..! 서비스가 너무 좋았고, 실제로 있었으면 하는 서비스였기 때문이였다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 10일안에 구축하기에는 너무 고도화 작업이 필요한 서비스였기 때문에 기간 안에 맞는 기획 서비스는 아니여서 아쉬움이 남는다. 하지만 추후 고도화를 위해 계속 개발을 진행할 것이다!&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;940&quot; data-origin-height=&quot;598&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/trhI7/btsmrC5fjQ6/OM31SPUOTbNZnbFZxpKS2K/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/trhI7/btsmrC5fjQ6/OM31SPUOTbNZnbFZxpKS2K/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/trhI7/btsmrC5fjQ6/OM31SPUOTbNZnbFZxpKS2K/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtrhI7%2FbtsmrC5fjQ6%2FOM31SPUOTbNZnbFZxpKS2K%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;660&quot; height=&quot;420&quot; data-origin-width=&quot;940&quot; data-origin-height=&quot;598&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1등 팀 서비스를 포함한 거의 대부분의 서비스는 설문 조사, 다이어리와 같은 서비스였다. 하지만 확실히 완성도가 높은 서비스라는 느낌이 들었다. 모두모두 고생하셨습니다 &lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;좋은 인연들도 얻고, 하나의 서비스 산출물도 얻게 되어 힘들지만 정말 많은 경험을 가지게 되었다고 생각한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이제 남은 건 코드 리뷰와 고도화인 것인가! 끝날때까지 끝난건 아니다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;아! 저희팀 서비스는 푸딧으로, 식재료 쉐어 구매를 도와주는 서비스입니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;구경 오셔서 피드백도 남겨주시고 하트도 눌러주시면 감사하겠습니다 ㅎㅎ&lt;/p&gt;
&lt;figure id=&quot;og_1688519025387&quot; contenteditable=&quot;false&quot; data-ke-type=&quot;opengraph&quot; data-ke-align=&quot;alignCenter&quot; data-og-type=&quot;website&quot; data-og-title=&quot;비사이드 : IT 프로젝트 경험을 통해 성장하세요!&quot; data-og-description=&quot;&quot; data-og-host=&quot;bside.best&quot; data-og-source-url=&quot;https://bside.best/projects/detail/P230622111341&quot; data-og-url=&quot;https://bside.best&quot; data-og-image=&quot;https://scrap.kakaocdn.net/dn/1LOC2/hyTehmhI0m/YeKk83cAwZ3ZrLxfqWgXmK/img.png?width=1200&amp;amp;height=630&amp;amp;face=0_0_1200_630&quot;&gt;&lt;a href=&quot;https://bside.best/projects/detail/P230622111341&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-source-url=&quot;https://bside.best/projects/detail/P230622111341&quot;&gt;
&lt;div class=&quot;og-image&quot; style=&quot;background-image: url('https://scrap.kakaocdn.net/dn/1LOC2/hyTehmhI0m/YeKk83cAwZ3ZrLxfqWgXmK/img.png?width=1200&amp;amp;height=630&amp;amp;face=0_0_1200_630');&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;og-text&quot;&gt;
&lt;p class=&quot;og-title&quot; data-ke-size=&quot;size16&quot;&gt;비사이드 : IT 프로젝트 경험을 통해 성장하세요!&lt;/p&gt;
&lt;p class=&quot;og-desc&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p class=&quot;og-host&quot; data-ke-size=&quot;size16&quot;&gt;bside.best&lt;/p&gt;
&lt;/div&gt;
&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2358&quot; data-origin-height=&quot;1364&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/c86nOw/btsmscZezXc/9Xh1ISzHEu7xBTDS4O017k/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/c86nOw/btsmscZezXc/9Xh1ISzHEu7xBTDS4O017k/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/c86nOw/btsmscZezXc/9Xh1ISzHEu7xBTDS4O017k/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc86nOw%2FbtsmscZezXc%2F9Xh1ISzHEu7xBTDS4O017k%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;716&quot; height=&quot;414&quot; data-origin-width=&quot;2358&quot; data-origin-height=&quot;1364&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;개인적으로 받은 코멘트&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;890&quot; data-origin-height=&quot;726&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/1RDQj/btsmmQQLpOJ/MGsxseCkwQWSVN7gkdojoK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/1RDQj/btsmmQQLpOJ/MGsxseCkwQWSVN7gkdojoK/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/1RDQj/btsmmQQLpOJ/MGsxseCkwQWSVN7gkdojoK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F1RDQj%2FbtsmmQQLpOJ%2FMGsxseCkwQWSVN7gkdojoK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;644&quot; height=&quot;525&quot; data-origin-width=&quot;890&quot; data-origin-height=&quot;726&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-filename=&quot;blob&quot; data-origin-width=&quot;972&quot; data-origin-height=&quot;231&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/b9sS2X/btsmr2JuCt6/F1TmqJOoivWNnsqOAOW1Mk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/b9sS2X/btsmr2JuCt6/F1TmqJOoivWNnsqOAOW1Mk/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/b9sS2X/btsmr2JuCt6/F1TmqJOoivWNnsqOAOW1Mk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb9sS2X%2Fbtsmr2JuCt6%2FF1TmqJOoivWNnsqOAOW1Mk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;615&quot; height=&quot;146&quot; data-filename=&quot;blob&quot; data-origin-width=&quot;972&quot; data-origin-height=&quot;231&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>회고록</category>
      <category>비사이드</category>
      <category>포텐데이</category>
      <category>해커톤</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/122</guid>
      <comments>https://1two13.tistory.com/entry/10%EC%9D%BC%EA%B0%84%EC%9D%98-%ED%95%B4%EC%BB%A4%ED%86%A4-%EA%B8%B0%ED%9A%8D%EB%B6%80%ED%84%B0-%EB%B0%B0%ED%8F%AC%EA%B9%8C%EC%A7%80%EB%B9%84%EC%82%AC%EC%9D%B4%EB%93%9C-%ED%8F%AC%ED%85%90%EB%8D%B0%EC%9D%B4#entry122comment</comments>
      <pubDate>Wed, 5 Jul 2023 10:08:41 +0900</pubDate>
    </item>
    <item>
      <title>실행 컨텍스트</title>
      <link>https://1two13.tistory.com/entry/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8</link>
      <description>&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;실행 컨텍스트&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;실행 컨텍스트는 자바스크립트가 실행되는 환경이다. &lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;여기서 환경은 this, 변수, 객체, 함수 등 코드의 실행에 필요한 기반들이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;좀 더 구체적으로 말하자면, 실행 컨텍스트는 코드를 실행하는데 필요한 환경을 제공하고 관리한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이 중에서 식별자, 스코프, this 등은 실행 컨텍스트의 렉시컬 환경을 기반으로 관리되고, 코드의 실행순서는 콜스택(실행 컨텍스트의 스택)을 통해서 관리된다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;실행 컨텍스트 종류&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;1. 전역 실행 컨텍스트&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;처음으로 자바스크립트 코드가 실행될 때 생성된다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;2. 함수 실행 컨텍스트&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;함수가&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;호출&lt;/b&gt;될 때마다 생성된다. 각각의 함수 호출은 모두 각자의 실행 컨텍스트를 생성하고 가진다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. eval 실행 컨텍스트&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;strict mode&lt;/b&gt;(엄격 모드)에서&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;독립적&lt;/b&gt;인&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;스코프&lt;/b&gt;를 생성한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 모듈 실행 컨텍스트&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;모듈별&lt;/b&gt;로&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;독립적&lt;/b&gt;인 스코프를 생성한다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;실행 컨텍스트 스택(콜스택)&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;스택은 선입 선출의 특징을 가진 자료구조이고, 자바스크립트는 스택에 실행 컨텍스트를 순차적으로 추가하고 제거하면서 코드의 순서를 관리하고 실행한다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1686671767647&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;const a = 'a';

function foo() {
  const b = 'b';
  bar();

  function bar() {
    const c = 'c';
    if(true) console.log(&quot;Hello, World&quot;);
  }
}

foo();&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;해당 코드가 실행 컨텍스트에서 어떻게 저장되고 관리되는지 알아보자.&amp;nbsp;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;0. 처음에 실행 컨텍스트 스택은 비어있다.&lt;/p&gt;
&lt;table id=&quot;e8e22087-df83-4dac-8f26-8a45688873f3&quot; style=&quot;border-collapse: collapse; width: 23.7209%; height: 51px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot;&gt;
&lt;tbody&gt;
&lt;tr id=&quot;87eb8b06-89ea-43e6-8f28-9c2a0876f742&quot; style=&quot;height: 17px;&quot;&gt;
&lt;td id=&quot;~xlW&quot; style=&quot;height: 17px; text-align: left;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 17px;&quot;&gt;
&lt;td style=&quot;height: 17px;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 17px;&quot;&gt;
&lt;td style=&quot;height: 17px;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 자바스크립트 코드가 실행되면서 전역 실행 컨텍스트가 생성된다. 전역 스코프에 선언된 변수와 함수 등의 정의가 진행된다.&amp;nbsp;&lt;/p&gt;
&lt;table id=&quot;e8e22087-df83-4dac-8f26-8a45688873f3&quot; style=&quot;border-collapse: collapse; width: 23.7209%; height: 51px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot;&gt;
&lt;tbody&gt;
&lt;tr id=&quot;87eb8b06-89ea-43e6-8f28-9c2a0876f742&quot; style=&quot;height: 17px;&quot;&gt;
&lt;td id=&quot;~xlW&quot; style=&quot;height: 17px; text-align: left;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 17px;&quot;&gt;
&lt;td style=&quot;height: 17px;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 17px;&quot;&gt;
&lt;td style=&quot;height: 17px; text-align: center;&quot;&gt;global&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 그다음 foo 함수가 호출되면서 foo 함수의 함수 실행 컨텍스트가 생성된다. 이 안에서 변수 b와 bar 등의 평가와 실행이 진행된다.&amp;nbsp;&lt;/p&gt;
&lt;table id=&quot;e8e22087-df83-4dac-8f26-8a45688873f3&quot; style=&quot;border-collapse: collapse; width: 23.7209%; height: 51px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot;&gt;
&lt;tbody&gt;
&lt;tr id=&quot;87eb8b06-89ea-43e6-8f28-9c2a0876f742&quot; style=&quot;height: 17px;&quot;&gt;
&lt;td id=&quot;~xlW&quot; style=&quot;height: 17px; text-align: left;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 17px;&quot;&gt;
&lt;td style=&quot;height: 17px; text-align: center;&quot;&gt;foo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 17px;&quot;&gt;
&lt;td style=&quot;height: 17px; text-align: center;&quot;&gt;global&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. foo 함수 안에서 bar를 호출하였기 때문에 bar 함수의 실행 컨텍스트를 생성한다.&lt;/p&gt;
&lt;table id=&quot;e8e22087-df83-4dac-8f26-8a45688873f3&quot; style=&quot;border-collapse: collapse; width: 23.7209%; height: 51px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot;&gt;
&lt;tbody&gt;
&lt;tr id=&quot;87eb8b06-89ea-43e6-8f28-9c2a0876f742&quot;&gt;
&lt;td id=&quot;~xlW&quot; style=&quot;text-align: center;&quot;&gt;bar&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;foo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;global&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. bar 함수의 동작이 완료되었으므로 bar 함수의 실행컨텍스트를 스택에서 제거한다.&amp;nbsp;&lt;/p&gt;
&lt;table id=&quot;e8e22087-df83-4dac-8f26-8a45688873f3&quot; style=&quot;border-collapse: collapse; width: 23.7209%; height: 51px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot;&gt;
&lt;tbody&gt;
&lt;tr id=&quot;87eb8b06-89ea-43e6-8f28-9c2a0876f742&quot;&gt;
&lt;td id=&quot;~xlW&quot; style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;foo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;global&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. foo 함수의 동작이 완료되었으므로 foo 함수를 실행 컨텍스트를 스택에서 제거한다.&amp;nbsp;&lt;/p&gt;
&lt;table id=&quot;e8e22087-df83-4dac-8f26-8a45688873f3&quot; style=&quot;border-collapse: collapse; width: 23.7209%; height: 51px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot;&gt;
&lt;tbody&gt;
&lt;tr id=&quot;87eb8b06-89ea-43e6-8f28-9c2a0876f742&quot;&gt;
&lt;td id=&quot;~xlW&quot; style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;foo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;global&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;6. 모든 코드의 실행이 종료되었으므로 전역 실행 컨텍스트를 스택에서 제거한다.&amp;nbsp;&lt;/p&gt;
&lt;table id=&quot;e8e22087-df83-4dac-8f26-8a45688873f3&quot; style=&quot;border-collapse: collapse; width: 23.7209%; height: 51px;&quot; border=&quot;1&quot; data-ke-align=&quot;alignLeft&quot;&gt;
&lt;tbody&gt;
&lt;tr id=&quot;87eb8b06-89ea-43e6-8f28-9c2a0876f742&quot; style=&quot;height: 17px;&quot;&gt;
&lt;td id=&quot;~xlW&quot; style=&quot;text-align: left; height: 17px;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 17px;&quot;&gt;
&lt;td style=&quot;height: 17px;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 17px;&quot;&gt;
&lt;td style=&quot;height: 17px;&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;평가와 실행&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;실행 컨텍스트는 종류별로 세부적인 구성요소와 동작이 다르다. 하지만 모든 실행 컨텍스트는 평가와 실행 과정을 거쳐서 생성되고 관리된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;평가&lt;/b&gt;&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;평가는 &lt;b&gt;실행 컨텍스트를 생성&lt;/b&gt;하고 변수, 함수 등의 선언문을 파악하여 현재 스코프 내에서 사용할 수 있는 &lt;b&gt;변수, 함수의 식별자&lt;/b&gt;를 실행 컨텍스트에 &lt;b&gt;등록&lt;/b&gt;하는 과정이다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;여기서 &lt;b&gt;호이스팅&lt;/b&gt;이라는 개념이 나온다. 호이스팅은 식별자가 마치 코드블록의 제일 상위 부분으로 끌어올려지는 것처럼 보이는 현상을 말한다. 사실 실제 자바스크립트 스펙에는 호이스팅이라는 용어가 없다. 하지만 평가 과정에서 식별자들에 대한 정보가 먼저 실행 컨텍스트에 기록된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;실행&lt;/b&gt;&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;실행은 &lt;b&gt;선언문을 제외&lt;/b&gt;한 소스코드를 실행하는 과정이다. 실행 과정에서는 소스코드 실행에 필요한 정보, 즉 변수나 함수의 참조를 &lt;b&gt;실행 컨텍스트에서 찾고&lt;/b&gt; 실행과정에서 일어나는 변숫값의 변경 등은 &lt;b&gt;다시 실행 컨텍스트에 등록&lt;/b&gt;한다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;실행 컨텍스트 내부&amp;nbsp;&lt;/b&gt;&lt;/h3&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;실행 컨텍스트 내부에는 LexicalEnvironment라는 객체가 존재한다. 이 객체는 스코프를 관리하는 역할을 하고, 이 안에 변수, 함수의 정의, 값들이 저장된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;LexicalEnvironment는 실행 컨텍스트 종류에 따라 조금씩 다르지만 크게 2가지 영역으로 구성되어 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;1. EnvironmentRecord(환경 레코드)&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;식별자를 등록하고 관리하는 역할을 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;2. OuterLexicalEnvironmentReference(외부 렉시컬 환경에 대한 참조)&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;상위 스코프를 참조하는 역할을 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그리고 LexicalEnvironment는 평가과정에서 일반적으로 3가지 동작을 수행한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. &lt;b&gt;식별자&lt;/b&gt; 생성&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. &lt;b&gt;this&lt;/b&gt; binding&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. &lt;b&gt;참조할 외부 환경&lt;/b&gt; 결정&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그다음 실행과정에서 평가과정에서 생성된 정보들을 기반으로 값들을 변경하는 방식으로 진행된다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;정리&lt;/b&gt;&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체이다.&lt;/li&gt;
&lt;li&gt;실행 컨텍스트 객체는 활성화되는 시점에 variableEnvironment, LexicalEnvironment, ThisBinding을 수집한다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;실행 컨텍스트를 생성할 때는 variableEnvironment와 LexicalEnvironment가 동일한 내용으로 구성되지만, LexicalEnvironment는 함수 실행 도중에 변경되는 사항이 즉시 반영되고, variableEnvironment는 초기 상태를 유지한다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: #333333; text-align: left;&quot;&gt;variableEnvironment와&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;LexicalEnvironment는 environmentRecord와 OuterLexicalEnvironmentReference로 구성되어 있다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;스코프는 변수의 유효범위를 말하고 OuterLexicalEnvironmentReference는 해당 함수가 선언된 위치의 LexicalEnvironment을 참조한다. 코드 상에서 어떤 변수에 접근하려고 하면 현재 컨텍스트의 LexicalEnvironment를 탐색해서 발견되면 그 값을 반환하고, 발견하지 못하면 OuterLexicalEnvironmentReference에 담긴 LexicalEnvironment를 탐색한다. 전역 컨텍스트의 LexicalEnvironment까지 탐색해도 해당 변수를 찾지 못하면 undefined를 반환한다.&lt;/li&gt;
&lt;li&gt;this에는 실행 컨텍스트를 활성화하는 당시에 지정된 this가 저장된다.&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h3 data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;원티드에서 수강한 프로그램에서 학습한 내용&lt;/li&gt;
&lt;li&gt;코어 자바스크립트 책&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>JavaScript</category>
      <category>렉시컬환경</category>
      <category>실행컨텍스트</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/121</guid>
      <comments>https://1two13.tistory.com/entry/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8#entry121comment</comments>
      <pubDate>Wed, 14 Jun 2023 02:03:37 +0900</pubDate>
    </item>
    <item>
      <title>이벤트 루프 작동 원리</title>
      <link>https://1two13.tistory.com/entry/%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;자바스크립트는 하나의 프로그램에서 하나의 코드만 실행할 수 있는 &lt;b&gt;싱글 스레드&lt;/b&gt; 프로그래밍 언어다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 자바스크립트의 &lt;b&gt;동시성&lt;/b&gt;을 지원해주는 것이 바로 이벤트 루프다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;즉, 자바스크립트 엔진은 싱글 스레드로 동작하지만, 브라우저는 멀티 스레드로 동작하는 것이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이 말은 아래의 작동 원리를 보면 조금 더 이해가 잘 될 것이다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;먼저 v8 자바스크립트 엔진이 어떤 절차로 동작하는지 간단하게 작성했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;아래의 이미지를 보면서 흐름을 읽는 것이 이해하기가 쉽다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;963&quot; data-origin-height=&quot;894&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/EHWCS/btsiej3MQF2/jY738kiKKGakhu6FY6kdwk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/EHWCS/btsiej3MQF2/jY738kiKKGakhu6FY6kdwk/img.png&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/EHWCS/btsiej3MQF2/jY738kiKKGakhu6FY6kdwk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEHWCS%2Fbtsiej3MQF2%2FjY738kiKKGakhu6FY6kdwk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;443&quot; height=&quot;411&quot; data-origin-width=&quot;963&quot; data-origin-height=&quot;894&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. &lt;b&gt;힙&lt;/b&gt; 영역에서 &lt;b&gt;메모리&lt;/b&gt;를 할당&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 콜스택에 맨 처음으로 선언한 코드들을 가지고 있는 &lt;b&gt;anonymous&lt;/b&gt;&amp;nbsp;푸시&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 그 다음에, 호출된 코드들이 순차적으로 콜스택에 푸시되고 실행&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 호출된 코드들 중 &lt;b&gt;비동기 함수&lt;/b&gt;는 &lt;b&gt;Web APIs&lt;/b&gt;로 이동&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. Web APIs에 있는 &lt;b&gt;비동기 함수의 콜백함수&lt;/b&gt; 또는 &lt;b&gt;이벤트 핸들러&lt;/b&gt;를 콜백 큐에 일시적으로 보관&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;6. &lt;b&gt;콜스택이 비어있을 때만&lt;/b&gt;, 콜백 큐에 할당된 함수들을 순차적으로 콜스택에 할당&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;7. 콜 스택이 비어있을 때까지 동작을 반복&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그럼 이제 1번부터 자세하게 설명해 보려고 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;1.&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;b&gt;힙&lt;/b&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;영역에서&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;b&gt;메모리&lt;/b&gt;를 할당&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;힙은 &lt;b&gt;메모리 할당&lt;/b&gt;이 일어나는 곳으로, &lt;b&gt;객체&lt;/b&gt;(&lt;b&gt;변수, 함수&lt;/b&gt; 등)가 담긴다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;힙은 &lt;b&gt;구조화되어 있지 않다&lt;/b&gt;는 특징이 있습니다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;객체는 크기가 정해져 있지 않아,메모리 공간의 크기가 &lt;b&gt;런타임&lt;/b&gt;에 &lt;b&gt;동적&lt;/b&gt;으로 결정되기 때문이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;2. 콜스택에 맨 처음으로 선언한 코드들을 가지고 있는&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;b&gt;anonymous&lt;/b&gt;&amp;nbsp;푸시&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;콜스택에 우선 맨 처음으로 선언한 코드들을 읽고 익명 함수를 푸시한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;3. 그 다음에, 호출된 코드들이 순차적으로 콜스택에 푸시되고 실행&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;실행 컨텍스트 스택이 바로 콜스택이다. 따라서 실행될 코드의 한 줄 단위로 할당이 된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;호출될&lt;/b&gt; 때 코드들이 &lt;b&gt;순차적&lt;/b&gt;으로 푸시되고, 실행된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;하나의 콜스택&lt;/b&gt;을 사용하기 때문에, &lt;b&gt;최상위 실행 컨텍스트&lt;/b&gt;가 콜 스택에서 제거되기 전까지 다른 테스크는 실행되지 않는다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;참고로, 브라우저 혹은 엔진마다 콜 스택의 한계점은 다르다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;따라서, setTimeout에 0초의 타이머를 설정해둔 경우 결과값이 다를 수 있다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;4. 호출된 코드들 중&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;b&gt;비동기 함수&lt;/b&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;는&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;b&gt;Web APIs&lt;/b&gt;로 이동&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;5. Web APIs에 있는&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;비동기 함수의 &lt;u&gt;콜백함수&lt;/u&gt;&lt;/b&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;또는&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;이벤트 핸들러&lt;/b&gt;를 콜백 큐에 일시적으로 보관&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;비동기함수의 콜백함수&lt;span style=&quot;background-color: #ffffff;&quot;&gt;로는 &lt;span style=&quot;color: #eb5757;&quot; data-token-index=&quot;0&quot;&gt;DOM&lt;/span&gt; (document), &lt;span style=&quot;color: #eb5757;&quot; data-token-index=&quot;2&quot;&gt;AJAX&lt;/span&gt; (XMLHttpRequest), &lt;span style=&quot;color: #eb5757;&quot; data-token-index=&quot;4&quot;&gt;Timeout&lt;/span&gt;(setTimeout) 등이 있다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;background-color: #ffffff;&quot;&gt;참고로 콜백큐는 Microtask Queue(Job Queue), Animation Frames, Task Queue(Event Queue) 등으로 이루어져 있고,&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이벤트 루프가 콜백큐에서 탐색하는 우선순위는 M &amp;gt; A &amp;gt; T 이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;6.&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;콜스택이 비어있을 때만&lt;/b&gt;, 콜백 큐에 할당된 함수들을 순차적으로 콜스택에 할당&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4 style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size20&quot;&gt;7. 콜 스택이 비어있을 때까지 동작을 반복&lt;/h4&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이벤트 루프에 대해 정리를 해보았는데, 확실히 이해를 하게 된 것 같다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;여러번 보고 코드도 많이 작성해봐야 역시 와닿는 것 같다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>JavaScript</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/120</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC#entry120comment</comments>
      <pubDate>Thu, 1 Jun 2023 21:48:50 +0900</pubDate>
    </item>
    <item>
      <title>react에서 CSS 폴더를 따로 만들었을 때, CSS 코드는 언제 변환될까?</title>
      <link>https://1two13.tistory.com/entry/react%EC%97%90%EC%84%9C-CSS-%ED%8F%B4%EB%8D%94%EB%A5%BC-%EB%94%B0%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%97%88%EC%9D%84-%EB%95%8C-CSS-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%96%B8%EC%A0%9C-%EB%B3%80%ED%99%98%EB%90%A0%EA%B9%8C</link>
      <description>&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;react에서 CSS 폴더를 따로 만들어서 각 컴포넌트에 해당하는 css를 렌더링할 때, CSS 코드를 변환하는 과정은 언제 발생할까?&lt;/b&gt;&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;위와 같은 경우에 CSS 파일들은 아래와 같은 절차를 통해 변환된다.&amp;nbsp;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. &lt;b&gt;webpack&lt;/b&gt;과 같은 &lt;b&gt;모듈 번들러&lt;/b&gt;를 통해 빌드 과정을 거친다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. &lt;span style=&quot;background-color: #ffc1c8;&quot;&gt;&lt;b&gt;빌드&lt;/b&gt;&lt;/span&gt; 과정에서 &lt;b&gt;JS 모듈&lt;/b&gt;로 변환된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 최종적으로 &lt;b&gt;브라우저&lt;/b&gt;에서 코드가 실행된다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;여기서 webpack은 의존 관계에 있는 JS, CSS, 이미지 등의 리소스들을 &lt;b&gt;하나의 파일로 번들링&lt;/b&gt;하는 모듈 번들러다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;webpack을 사용하면 의존 모듈이 하나의 파일로 번들링되기 때문에 별도의 모듈 로더가 필요없고,&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;HTML 파일에서 script 태그로 여러 개의 자바스크립트 파일을 로드해야하는 번거로움도 사라진다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>의문점 해결하기</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/119</guid>
      <comments>https://1two13.tistory.com/entry/react%EC%97%90%EC%84%9C-CSS-%ED%8F%B4%EB%8D%94%EB%A5%BC-%EB%94%B0%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%97%88%EC%9D%84-%EB%95%8C-CSS-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%96%B8%EC%A0%9C-%EB%B3%80%ED%99%98%EB%90%A0%EA%B9%8C#entry119comment</comments>
      <pubDate>Wed, 31 May 2023 16:41:35 +0900</pubDate>
    </item>
    <item>
      <title>[React + TS] 무한스크롤 구현하기</title>
      <link>https://1two13.tistory.com/entry/React-TS-%EB%AC%B4%ED%95%9C%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;기업과제를 진행하면서 무한 스크롤을 적용시켰다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;검색어를 입력하면 그에 따른 추천 검색어들이 드롭다운에 보여지게 되는데, 처음에는 10개가 노출되고, 추천 검색어가 10개 이상이면 무한스크롤을 사용해서 추가 데이터(10개)를 계속해서 화면에 보여주는게 구현 목표였다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;스크롤 바가 마지막 컨텐츠를 보여주는 시점에 추가적인 데이터를 제공할 수 있도록 구현했다.&amp;nbsp;&lt;/b&gt;&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;마지막 컨텐츠를 보여주는 시점은 아래와 같다.&amp;nbsp;&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;스크롤바를 제외한 컨텐츠 높이 + 스크롤된 거리 &amp;gt;= 스크롤바를 포함한 전체 높이&amp;nbsp;&lt;/blockquote&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;771&quot; data-origin-height=&quot;404&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/WdGb1/btsg7HxFqpn/SRXPXcUThWl5dNL3yvwkk0/img.jpg&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/WdGb1/btsg7HxFqpn/SRXPXcUThWl5dNL3yvwkk0/img.jpg&quot; data-alt=&quot;출처:&amp;amp;nbsp;https://velog.io/@hyeon930/%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0-Throttling&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/WdGb1/btsg7HxFqpn/SRXPXcUThWl5dNL3yvwkk0/img.jpg&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FWdGb1%2Fbtsg7HxFqpn%2FSRXPXcUThWl5dNL3yvwkk0%2Fimg.jpg&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; data-origin-width=&quot;771&quot; data-origin-height=&quot;404&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처:&amp;nbsp;https://velog.io/@hyeon930/%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0-Throttling&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;컨텐츠 높이와 스크롤된 거리가 스크롤바를 포함한 전체 높이보다 크거나 같을 때 스크롤을 끝까지 완료한 것이고, 마지막 컨텐&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;츠가 보이는 시점이 되는 것이다.&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;위의 내용을 바탕으로 바로 코드를 작성해도 되지만, 문제가 있다.&amp;nbsp;&lt;/p&gt;
&lt;h4 data-ke-size=&quot;size20&quot;&gt;&lt;b&gt;바로 스크롤을 움직일 때마다 함수가 실행되기 때문이다.&amp;nbsp;&lt;/b&gt;&lt;/h4&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이러한 문제점을 해결하기 위해 useThrottle 커스텀 훅을 생성했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;throttle은 일정 시간동안 함수 호출을 막기 위해 사용하는 프로그래밍 기법이다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1684846491902&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;// src/hooks/useThrottle.ts

import { useRef } from 'react';

const useThrottle = &amp;lt;T extends any[]&amp;gt;(callback: (...args: T) =&amp;gt; void, timeout: number) =&amp;gt; {
  const timer = useRef&amp;lt;ReturnType&amp;lt;typeof setTimeout&amp;gt; | null&amp;gt;(null);
  return (...args: T) =&amp;gt; {
    if (!timer.current) {
      timer.current = setTimeout(() =&amp;gt; {
        callback(...args);
        timer.current = null;
      }, timeout);
    }
  };
};

export default useThrottle;&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;timer.current 값이 null인 경우에만 새로운 타이머를 설정하고, timeout 시간이 경과하면 콜백함수를 실행하도록 코드를 작성했다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그리고 콜백함수가 실행된 이후 timer.current 값을 다시 null로 초기화하여 다음 실행을 위해 타이머를 재설정하는 코드를 작성했다.&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;생성한 커스텀 훅을 사용하여 onScroll 이벤트가 발생할 때의 코드를 작성했다.&lt;/p&gt;
&lt;pre id=&quot;code_1684852354633&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;// src/components/Dropdown.tsx

const Dropdown = () =&amp;gt; {
  const [isLoading, setIsLoading] = useState(false);
  const { searchedData, setSearchedData } = useContext(ContextList);

  const onScrollDropdown = async (e: React.UIEvent&amp;lt;HTMLDivElement&amp;gt;) =&amp;gt; {
    if (result.length &amp;gt;= total) return;

    const target = e.target as HTMLDivElement;
    const { scrollHeight, scrollTop, clientHeight } = target;

    if (clientHeight + scrollTop &amp;gt;= scrollHeight) {
      await getMoreCommendData();
    }
  };

  const throttleScroll = useThrottle&amp;lt;[React.UIEvent&amp;lt;HTMLDivElement&amp;gt;]&amp;gt;(onScrollDropdown, 700);
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre id=&quot;code_1684852390603&quot; class=&quot;typescript&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;// return 코드

&amp;lt;div className=&quot;dropdown-container&quot; onScroll={throttleScroll}&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;useThrottle 커스텀 훅을 생성하여 최적화시키는 방법을 학습했고, 무한 스크롤을 구현하는 경험을 가졌다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;무한스크롤을 직접 컨텐츠 높이를 계산하여 적용하는 방법 말고도 더 있을 거 같은데, 추가적인 방법도 궁금하다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>React</category>
      <category>원티드</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/118</guid>
      <comments>https://1two13.tistory.com/entry/React-TS-%EB%AC%B4%ED%95%9C%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0#entry118comment</comments>
      <pubDate>Tue, 23 May 2023 23:43:12 +0900</pubDate>
    </item>
    <item>
      <title>[react] 검색어 입력마다 API가 호출되지 않도록 API 호출 횟수 줄이는 법</title>
      <link>https://1two13.tistory.com/entry/react-%EA%B2%80%EC%83%89%EC%96%B4-%EC%9E%85%EB%A0%A5%EB%A7%88%EB%8B%A4-API%EA%B0%80-%ED%98%B8%EC%B6%9C%EB%90%98%EC%A7%80-%EC%95%8A%EB%8F%84%EB%A1%9D-API-%ED%98%B8%EC%B6%9C-%ED%9A%9F%EC%88%98-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B2%95</link>
      <description>&lt;p style=&quot;background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-sourcepos=&quot;27:1-27:92&quot; data-ke-size=&quot;size16&quot;&gt;input창에 검색어를 입력할 때마다 API가 호출되지 않고, 특정 기준(ms)동안 입력이 되지 않았을 때 입력된 값으로 API를 호출하도록 해줬다.&lt;/p&gt;
&lt;p style=&quot;background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-sourcepos=&quot;27:1-27:92&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-sourcepos=&quot;27:1-27:92&quot; data-ke-size=&quot;size16&quot;&gt;왜냐하면 유료 API를 사용했을 때, 입력마다 API가 호출되는 것이 큰 문제가 될 수 있기 때문이다.&lt;/p&gt;
&lt;p style=&quot;background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-sourcepos=&quot;27:1-27:92&quot; data-ke-size=&quot;size16&quot;&gt;예를 들어, 구글지도 API와 같은 것을 사용할 때 입력할 때마다 쿼리를 날리면 엄청난 손해이다. 쿼리 하나하나가 모두 돈이기 때문이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;debouncing&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;useDebounce라는 훅을 만들어서 사용을 했는데, 먼저 debouncing이 뭔지에 대해 알아보자.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;debouncing은 연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출되도록 하는 것이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;디바운싱은 앞에서 언급했던 상황처럼 검색에 자주 사용된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;코드 구현&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;1. useDebounce custom hook을 생성하여 검색어에 debounce를 적용&lt;/b&gt;&lt;/p&gt;
&lt;pre id=&quot;code_1683517244548&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;import { useEffect, useState } from 'react';

const useDebounce = (value: string, delay: number) =&amp;gt; {
  const [debouncedValue, setDebouncedValue] = useState&amp;lt;string&amp;gt;(value);

  useEffect(() =&amp;gt; {
    const timer = setTimeout(() =&amp;gt; setDebouncedValue(value), delay);
    return () =&amp;gt; clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
};

export default useDebounce;&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;2. 사용자가 검색어 입력을 시작한 후 500ms동안 입력이 없으면 API가 호출되도록 구현&lt;/b&gt;&lt;/p&gt;
&lt;pre id=&quot;code_1683517491277&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;const debouncedValue = useDebounce(inputValue, 500);
const [suggestedList, setSuggestedList] = useState&amp;lt;SuggestedListState&amp;gt;([]);

useEffect(() =&amp;gt; {
  const fetchApi = async () =&amp;gt; {
    // fetch 코드 있다고 가정
    console.info('calling api');
  };

  if (!debouncedValue) {
    setSuggestedList([]);
  } else fetchApi();
}, [inputValue, debouncedValue]);&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;debounceValue가 있을 때만 fetchApi를 호출하도록 해줬다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zerocho.com/category/JavaScript/post/59a8e9cb15ac0000182794fa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;제로초&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>React</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/117</guid>
      <comments>https://1two13.tistory.com/entry/react-%EA%B2%80%EC%83%89%EC%96%B4-%EC%9E%85%EB%A0%A5%EB%A7%88%EB%8B%A4-API%EA%B0%80-%ED%98%B8%EC%B6%9C%EB%90%98%EC%A7%80-%EC%95%8A%EB%8F%84%EB%A1%9D-API-%ED%98%B8%EC%B6%9C-%ED%9A%9F%EC%88%98-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B2%95#entry117comment</comments>
      <pubDate>Fri, 12 May 2023 10:15:40 +0900</pubDate>
    </item>
    <item>
      <title>[react] onKeyDown 이벤트 + 한글 입력 시 함수가 두 번 실행되는 문제 해결하기</title>
      <link>https://1two13.tistory.com/entry/react-onKeyDown-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%9C%EA%B8%80-%EC%9E%85%EB%A0%A5-%EC%8B%9C-%ED%95%A8%EC%88%98%EA%B0%80-%EB%91%90-%EB%B2%88-%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;검색창에 검색어를 입력하고 키보드를 사용하여 위아래에 이동 시,&amp;nbsp;맨 처음에만 2칸이 이동되는 문제가 있었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;즉, 맨 처음에 키보드를 사용하여 추천 검색어들을 이동할 때 함수가 2번 실행되는 문제점이 있었다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;결과적으로 조건식에 &lt;span style=&quot;color: #212529; text-align: start;&quot;&gt;e.nativeEvent.isComposing === false를 추가해 주면 문제점은 해결된다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;2572&quot; data-origin-height=&quot;414&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/x1qq9/btsd02kHT5h/XcbkRbEp9kP569kwv5FxMk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/x1qq9/btsd02kHT5h/XcbkRbEp9kP569kwv5FxMk/img.png&quot; data-alt=&quot;깃헙 전후 코드 비교&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/x1qq9/btsd02kHT5h/XcbkRbEp9kP569kwv5FxMk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fx1qq9%2Fbtsd02kHT5h%2FXcbkRbEp9kP569kwv5FxMk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; data-origin-width=&quot;2572&quot; data-origin-height=&quot;414&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;깃헙 전후 코드 비교&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;keyboardEvent.isComposing&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이는 입력한 문자가 조합문자인지 아닌지를 판단한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;한글은 조합문자이고, 영어는 조합문자가 아니다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;한글을 입력할 때 자세히 보면 입력 중인 글자 바로 아래 검은 밑줄이 생기는 경우가 있는데, 이 밑줄이 보이는 상황에서 키를 입력하면 이벤트가 2번 발생하는 이슈가 있다. 왜냐하면 글자가 조합 중인지, 조합이 끝난 상태인지 파악이 어렵기 때문이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그래서 위에서 설명한 이슈는 영어를 입력할 때는 발생하지 않지만, 한글을 입력할 때는 발생된다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;console.log(&lt;span style=&quot;color: #212529; text-align: start;&quot;&gt;e.nativeEvent.isComposing&lt;/span&gt;)&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;콘솔에 &lt;span style=&quot;color: #212529; text-align: start;&quot;&gt;e.nativeEvent.isComposing 값을 확인해보면, &lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #212529; text-align: start;&quot;&gt;첫 글자를 입력할 때, 공백을 입력할 때, 방향키를 사용할 때 false 값이 찍히고,&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #212529; text-align: start;&quot;&gt;글자를 입력하는 동안에는 true,&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #212529; text-align: start;&quot;&gt;Enter키를 누르면 true와 false가 함께 찍히는 것을 확인할 수 있었다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #212529; text-align: start;&quot;&gt;방향키를 이동할 때를 조건식에 추가해주면 정상적으로 함수가 한 번 실행되는 것을 확인할 수 있다. &lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>React/이슈 해결</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/116</guid>
      <comments>https://1two13.tistory.com/entry/react-onKeyDown-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%9C%EA%B8%80-%EC%9E%85%EB%A0%A5-%EC%8B%9C-%ED%95%A8%EC%88%98%EA%B0%80-%EB%91%90-%EB%B2%88-%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0#entry116comment</comments>
      <pubDate>Tue, 9 May 2023 22:47:00 +0900</pubDate>
    </item>
    <item>
      <title>[react + vercel] cra vercel로 배포하기 + cors 이슈로 인한 proxy 설정</title>
      <link>https://1two13.tistory.com/entry/react-vercel-cra-vercel%EB%A1%9C-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-cors-%EC%9D%B4%EC%8A%88%EB%A1%9C-%EC%9D%B8%ED%95%9C-proxy-%EC%84%A4%EC%A0%95</link>
      <description>&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;문제 상황&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;cra를 vercel로 배포하려고 하는데 오류가 발생했다.&amp;nbsp;&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;Uncaught&amp;nbsp;(in&amp;nbsp;promise)&amp;nbsp;SyntaxError:&amp;nbsp;Unexpected&amp;nbsp;token&amp;nbsp;'&amp;lt;',&amp;nbsp;&quot;&amp;lt;!doctype&amp;nbsp;&quot;...&amp;nbsp;is&amp;nbsp;not&amp;nbsp;valid&amp;nbsp;JSON&lt;/blockquote&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;821&quot; data-origin-height=&quot;63&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/blcVBh/btsnrtMp656/9b2eCetMT3ck2HYGteNXAK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/blcVBh/btsnrtMp656/9b2eCetMT3ck2HYGteNXAK/img.png&quot; data-alt=&quot;콘솔창 오류&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/blcVBh/btsnrtMp656/9b2eCetMT3ck2HYGteNXAK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FblcVBh%2FbtsnrtMp656%2F9b2eCetMT3ck2HYGteNXAK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; data-origin-width=&quot;821&quot; data-origin-height=&quot;63&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;콘솔창 오류&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;일단 현재 상황은 아래와 같았다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;package.json에 proxy를 추가해 두었고, cra를 사용했다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그리고 vercel로 배포하였을 때 HTML과 CSS는 처음에 렌더링이 잘 되지만, 검색창에 검색어를 입력했을 때 바로 오류가 발생했다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;일단 위의 조건들만 가지고 생각했을 때 package.json에 proxy를 추가해 둔 경우, &lt;b&gt;로컬인 나의 서버에서만 동작&lt;/b&gt;되고,&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;vercel로 배포하면 정적으로 배포되어 &lt;b&gt;cors 오류&lt;/b&gt;가 발생되는 것 같았다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;해결 방법&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그래서 이러한 문제점을 해결하기 위해 구글링을 해보니 해결방법이 있었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;vercel.json이라는 파일을 생성하고, '/api/*' 패턴을 특정 URL로 프록시 해주는 코드를 작성해 주면 문제는 해결된다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;src에는 요청을 보내는 경로를 작성하고,&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;dest에는 프록시 할 대상 URL을 작성해 주면 된다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1683520345751&quot; class=&quot;typescript&quot; style=&quot;background-color: #f8f8f8; color: #383a42; text-align: start;&quot; data-ke-language=&quot;typescript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;{
  &quot;routes&quot;: [
    {
      &quot;src&quot;: &quot;/api/(.*)&quot;,
      &quot;dest&quot;: &quot;https://api.test.com/api/$1&quot;
    }
  ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;src는 정규 표현식으로 작성했고, /api/ 다음에 오는 모든 것을 캡처하고, $1을 사용하여 대상 URL에 다시 삽입한다는 뜻이다.&amp;nbsp;여기서 $1은 src에서 캡처한 그룹이다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;다시 말해, /api/ 다음에 오는 모든 것을 캡처하고, 대상 URL에 다시 삽입되어 경로를 완성하는 것이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://velog.io/@jeajea0127/Vercel%EC%97%90%EC%84%9C-proxy-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;velog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/65456701/how-can-i-setup-proxy-using-vercel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>React/이슈 해결</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/115</guid>
      <comments>https://1two13.tistory.com/entry/react-vercel-cra-vercel%EB%A1%9C-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-cors-%EC%9D%B4%EC%8A%88%EB%A1%9C-%EC%9D%B8%ED%95%9C-proxy-%EC%84%A4%EC%A0%95#entry115comment</comments>
      <pubDate>Mon, 8 May 2023 17:47:35 +0900</pubDate>
    </item>
    <item>
      <title>[원티드] 첫 번째 프로젝트 회고</title>
      <link>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9A%8C%EA%B3%A0</link>
      <description>&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;프로젝트 소개&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;첫 번째 과제는 &lt;span style=&quot;background-color: #ffffff; color: #1f2328; text-align: start;&quot;&gt;로그인/회원가입 기능과, TODO 리스트를 구현하는 것이였다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;background-color: #ffffff; color: #1f2328; text-align: start;&quot;&gt;원티드 프리온보딩 사전과제 주어지는 조건에 맞는 프로젝트를 개발했다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이 프로젝트는 10명의 팀원 모두 함께 진행하였고, 각자 과제를 수행한 후 결과물을 통해서 팀원들끼리 토론하여 가장 적절하다고 생각하는 방식을 도출했다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;이 프로젝트를 통해 동료와 함께 협업하는 방법을 학습했고, 다양한 관점에서 코드를 해석해보는 경험을 했다.&lt;/p&gt;
&lt;p style=&quot;background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;개발환경&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc; background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;테스트 환경 : Chrome browser&lt;/li&gt;
&lt;li&gt;IDE : Visual Studio Code 1.71.0 (Universal)&lt;/li&gt;
&lt;li&gt;인프라 : Vercel&lt;/li&gt;
&lt;li&gt;주요 라이브러리
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;React : 18.2.0&lt;/li&gt;
&lt;li&gt;TypeScript : 4.9.5&lt;/li&gt;
&lt;li&gt;React-router-dom : 6.10.0&lt;/li&gt;
&lt;li&gt;tailwindcss : 3.3.2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;&lt;span style=&quot;background-color: #ffffff; color: #1f2328; text-align: start;&quot;&gt;프로젝트에서 사용한 기능과 그 이유&lt;/span&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. API 호출(axios)&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc; background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;axios의 intercepter 기능을 사용하여 API 요청 시, &lt;b&gt;URL과 헤더를 반복해서 입력하는 대신&lt;/b&gt; &lt;b&gt;공통적인 end point를 설정&lt;/b&gt;하여 간편하게 관리할 수 있습니다. 또한, 로그인한 인증된 사용자의 경우 interceptor를 이용하여 중간에 가로채어 헤더에 token 값을 추가하여 API를 호출할 수 있습니다. 이를 통해 보안성을 높일 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 상태관리&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc; background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;props를 사용하여 상태를 전달하였습니다.&lt;/li&gt;
&lt;li&gt;토큰 유무에 따른 리다이렉트에 &lt;u&gt;고차 컴포넌트를 사용&lt;/u&gt;했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 라우터&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc; background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;react-router-dom에서 제공하는&lt;b&gt; useRoutes&lt;/b&gt;를 사용하여 App.tsx에서 Routes.tsx를 Rendering 하였습니다.&lt;/li&gt;
&lt;li&gt;Routes.tsx에서는 react에서 제공하는 &lt;b&gt;lazy&lt;/b&gt; 메소드를 사용하였습니다.&lt;/li&gt;
&lt;li&gt;이는 첫 페이지가 로딩될 때 모든 컴포넌트가 렌더링되는 것이 아니라, &lt;b&gt;해당 컴포넌트가 필요한 시점에 이를 렌더링&lt;/b&gt;하여 첫 페이지에서 로딩시간이 오래걸리는 &lt;b&gt;CSR의 단점을 커버&lt;/b&gt;할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. craco-alias&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc; background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;다른 경로의 모듈을 import로 가져올때 상대 경로로 하면 depth가 길어지게 됩니다. alias를 통해 더 간단하게 depth를 표기하고자 했습니다. 그러나 CRA(Create React App)의 경우 alias를 설정하려면 npm eject를 사용해야합니다. depth의 간단한 표기를 위해 npm eject를 사용하는 대신 craco-alias 라이브러리를 통해 해결했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. TypeScript&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc; background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;React+TypeScript를 활용해 개발을 하였습니다.&lt;/li&gt;
&lt;li&gt;타입으로 인해 예상치못한 오류를 미리 점검하였습니다.&lt;/li&gt;
&lt;li&gt;타입을 가지고있어 팀원의 코드를 보고 빠른 피드백을 받았습니다.&lt;/li&gt;
&lt;li&gt;TypeScript 자동완성기능을 적절히 활용하였습니다.&lt;/li&gt;
&lt;li&gt;TypeScript를 사용해 &lt;b&gt;정적 타이핑&lt;/b&gt; 및 에러 핸들링을 했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;6. 유효성 검사&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc; background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;유효성 검사를 수행하는 함수를 &lt;u&gt;utils&lt;/u&gt; 폴더에 따로 정리하여 회원가입, 로그인에서 모두 사용할 수 있도록 했습니다. (재사용성 고려)&lt;/li&gt;
&lt;li&gt;아이디 input 태그의 type을 email이 아닌 text로 하여 @만 포함하면 유효한 것으로 하는 과제의 요구사항을 더 세밀하게 수행하였습니다.&lt;/li&gt;
&lt;li&gt;또한 과제의 요구사항이 복잡하지 않으므로 includes와 length를 이용하여 간단하게 유효성 검사를 실시하였습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;7. prettier + eslint&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc; background-color: #ffffff; color: #1f2328; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;prettier를 통하여 협업하는 팀원의 일관적인 코드스타일을 유지할 수 있게 적용을 하였고 ESLint를 통해 코드소스를 분석하여 문법적인 오류나 적절하지 않은 구조 등을 정의하여 미리 식별 할 수 있게 적용 하였습니다.&lt;/li&gt;
&lt;li&gt;ESLint의 경우 널리 사용되는 기준인 airbnb 와 airbnb-typescript 을 활용하였으며 팀원 간 소통 및 회의를 통해 제외시킬 옵션을 추가 정의하였습니다.&lt;/li&gt;
&lt;li&gt;이를 통해 코드의 통일성을 유지하고 발생할 수 있는 오류를 미리 식별하는 효과를 이루었습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;color: #1f2328;&quot;&gt;&lt;span style=&quot;background-color: #ffffff;&quot;&gt;&lt;b&gt;회고&lt;/b&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;10명의 팀원이 함께 이야기를 하며 과제를 수행하는 과정은 어려움이 많았다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;의견을 조율하는 부분에서도 시간이 많이 지체되었다. 결론적으로 5명씩 2팀으로 나누어서 한 팀은 로그인/회원가입 기능을, 다른 한 팀은 TODO 리스트 구현을 하기로 했다. 주차를 진행하면서 어떻게 팀을 나눠서 진행하는 것이 좋을지에 대한 고민은 계속 해봐야겠지만, 5명씩 나눠서 프로젝트를 진행하는 것이 10명에서 한꺼번에 의견을 나누는 것보다는 효율적이라는 생각이 들었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그리고, 팀으로 함께 일하기 위해 처음에 기본 세팅을 하는데 시간을 많이 투자했다. 시간을 투자한 만큼 팀으로 함께 일하는 방법에 대해 익힐 수 있어서 좋았다. 따로 블로깅을 할 예정이지만 간단하게 말하자면, 자동화할 수 있는 부분들은 템플릿을 사용하여 최대한 자동화 시켰고, ESLint와 Prettier, Husky를 이용하여 팀의 능률 올리기 위한 바탕을 만들었다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;다른 팀원 분들의 코드를 보며 코드 리뷰를 하는 과정도 매우 재밌었다. 다양한 관점에서 코드를 바라보는 시각을 가질 수 있는 좋은 경험이였다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>etc/[원티드] 프리온보딩 FE 인턴십</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/114</guid>
      <comments>https://1two13.tistory.com/entry/%EC%9B%90%ED%8B%B0%EB%93%9C-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9A%8C%EA%B3%A0#entry114comment</comments>
      <pubDate>Mon, 8 May 2023 12:25:50 +0900</pubDate>
    </item>
    <item>
      <title>[컴퓨터 네트워크/스터디] IP Address</title>
      <link>https://1two13.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%8A%A4%ED%84%B0%EB%94%94-IP-Address-1</link>
      <description>&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;1. IP Address&lt;/b&gt;&lt;/h2&gt;
&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1-1&lt;span style=&quot;color: #000000;&quot;&gt;. 쿠키에 대해 설명해 주세요&lt;/span&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가이드: 쿠키를 통해 HTTP 상태유지를 어떻게 하는지 클라이언트-서버 관점에서 설명. 장단점 설명, 사용해 본 적이 있다면 경험과 연관 지어 설명&lt;/p&gt;
&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;쿠키는 &lt;b&gt;HTTP 서버가 클라이언트를 식별할 수 있도록&lt;/b&gt; 하기 위해 사용됩니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;클라이언트가 웹 서버에 처음 접속하면, &lt;b&gt;서버는 쿠키를 생성&lt;/b&gt;해서 클라이언트에게 줍니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;이후 클라이언트는 서버에 요청을 보낼 때 자신의 정보가 들어있는 쿠키를 같이 보냅니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;그러면 서버는 쿠키를 통해 클라이언트를 식별할 수 있습니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;쿠키는 클라이언트 단에 저장되기 때문에 쿠키에 들어있는 사용자 정보가 유출될 수 있는 단점이 있습니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;1-2. 세션에 대해 설명해 주세요.&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가이드: 세션을 통해 HTTP 상태유지를 어떻게 하는지 클라이언트-서버 관점에서 설명. 장단점 설명, 사용해 본 적이 있다면 경험과 연관 지어 설명&lt;/p&gt;
&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;세션은&lt;b&gt; HTTP 서버가 클라이언트를 식별할 수 있도록 &lt;/b&gt;하기 위해 사용됩니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;클라이언트가 웹 서버에 처음 접속하면, &lt;b&gt;서버&lt;/b&gt;는 &lt;b&gt;세션 id&lt;/b&gt;와 &lt;b&gt;저장소&lt;/b&gt;를 만들고 세션 id를 클라이언트에게 줍니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;이후 클라이언트는 서버에 요청을 보낼 때 세션 id를 같이 보냅니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;그러면 서버는 세션 id를 통해서 서버가 자신을 식별할 수 있도록 합니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;세션을 사용하면, &lt;b&gt;정보가 서버에 저장되지 않기 때문에 정보 유출 우려가 없습니다.&amp;nbsp;&lt;/b&gt;&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;하지만 유저에 대한 &lt;b&gt;세션 정보를 유지해야 하기&lt;/b&gt; 때문에 많은 유저가 접속하면, &lt;b&gt;성능 저하&lt;/b&gt;가 발생할 수 있는 단점이 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1-3&lt;span style=&quot;color: #000000;&quot;&gt;. CORS가 뭘까요?&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가이드: Same Origin Plicy와 함께 설명, 프론트, 백엔드 관점에서 설명&amp;nbsp;&lt;/p&gt;
&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;CORS는 &lt;b&gt;클라이언트 브라우저에서&lt;/b&gt; 현재 접속한 사이트 외에 &lt;b&gt;다른 도메인에 접근할 수 있도록&lt;/b&gt; 처리해 주는 &lt;b&gt;웹 브라우저 표준 기술&lt;/b&gt;입니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;브라우저에는 크로사이트 스크립트 등의 이유로 &lt;b&gt;보안상 스크립트를 사용해서 다른 도메인으로 접근하는 것을 제한&lt;/b&gt;합니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;이를 &lt;b&gt;Same Origin Policy&lt;/b&gt;라고 하는데, 이러한 정책 제한을 넘어서기 위해 CORS가 필요합니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;예를 들어, 웹 서비스를 프론트와 백으로 완전히 나누고 API로 묶는 방식으로 구현한 경우,&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;백엔드 서버에 프론트엔드에 대한 CORS 설정을 허용해 줘서 프론트엔드가 백엔드 API를 사용할 수 있게 해줘야 합니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1-4&lt;span style=&quot;color: #000000;&quot;&gt;. REST에 대해서 설명해 주세요.&lt;/span&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가이드: 간단한 정의 정도만 설명해도 좋고, 6가지 원칙을 다 설명해도 좋다., RESTful, REST API에 대해서도 설명&amp;nbsp;&lt;/p&gt;
&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;REST는 &lt;b&gt;자원을 이름으로 구분&lt;/b&gt;하고, 해당 &lt;b&gt;자원의 상태를 주고받는 방법&lt;/b&gt;을 의미합니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;구체적으로는 &lt;b&gt;HTTP URL&lt;/b&gt;을 통해 자원을 명시하고, &lt;b&gt;HTTP Method&lt;/b&gt;를 통해 해당 자원에 대해 CRUD 연산을 적용하는 것입니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;REST의 원리를 따르는 시스템을 RESTful이라고 부르고,&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;REST 형식의 API를 REST API라고 부릅니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1-5&lt;span style=&quot;color: #000000;&quot;&gt;. XXS가 뭘까요?&lt;/span&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가이드: 공격 방식과 대응 방식 대해 설명&lt;/p&gt;
&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;XXS는 &lt;b&gt;웹 브라우저에 악성 스크립트를 삽입하여 사용자 정보를 탈취하는 공격방식&lt;/b&gt;입니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;웹 브라우저에서 &lt;b&gt;사용자 입력값과 출력값을 철저히 검증&lt;/b&gt;해서 XXS를 예방할 수 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;모든 &lt;b&gt;입력값&lt;/b&gt;에 대해 악의적인 스크립트가 있는지 체크하는 &lt;b&gt;validation&lt;/b&gt;을 추가하고,&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;입력값을 &lt;b&gt;출력&lt;/b&gt;할 때는 &lt;b&gt;특수문자를 이스케이스&lt;/b&gt; 하는 처리를 추가해서 예방하는 방법이 있습니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1-6&lt;span style=&quot;color: #000000;&quot;&gt;. SQL Injection 공격이 뭘까요? 어떻게 대비할 수 있을까요?&lt;/span&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가이드: 공격 방식과 대응 방식에 대해 설명&lt;/p&gt;
&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;악의적인 SQL 쿼리문을 삽입하여 &lt;b&gt;데이터베이스를 비정상적으로 조작&lt;/b&gt;하는 공격 기법입니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;웹 브라우저에서 들어오는 입력값에 대해 악성 SQL 패턴에 대한 validation을 추가하고,&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;데이터베이스에 평소 사용자에 의해 발생하는 SQL 패턴이 아닌 비정상적인 SQL이 발생하는지 &lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;주기적으로 모니터링하고, 비상 알람을 걸어두는 방식을 선택할 수 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;blockquote data-ke-style=&quot;style3&quot;&gt;# 조금 더 디테일한 질문&lt;/blockquote&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1-7&lt;span style=&quot;color: #000000;&quot;&gt;. 토큰에 대해 설명해 주세요.&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가이드: 토큰을 통해 HTTP 상태유지를 어떻게 하는지 클라이언트-서버 관점에서 설명. 장단점 설명, 사용해 본 적이 있다면 경험과 연관 지어 설명&lt;/p&gt;
&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;토큰은 &lt;b&gt;클라이언트 인가&lt;/b&gt;하는 방법입니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;토큰에는 &lt;b&gt;서버가 비밀키로 만들어둔 서명&lt;/b&gt;이 있는데,&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;서버는 공개키로 서명을 검증&lt;/b&gt;해서 클라이언트를 인가할 수 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;세션과 달리 토큰은 그 자체를 공개키로 검증만 하면 되기 때문에&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;서버에 부하를 주지 않고&lt;/b&gt;,&lt;b&gt; 여러 서버에 사용할 수 있는 확장성&lt;/b&gt;이 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;JSON을 사용하기 때문에 클라이언트가 브라우저인지 앱인지 아니면 다른 형태의 클라이언트 인지 상관없이&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;토큰 인증을 사용할 수 있다는 장점이 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1-8&lt;span style=&quot;color: #000000;&quot;&gt;. URL, URI, URN의 차이가 뭘까요?&lt;/span&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가이드: 각각 자원을 식별하는 방식을 설명&lt;/p&gt;
&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;URL은 &lt;b&gt;인터넷상에서 특정 자원을 가리키는 식별자&lt;/b&gt;입니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;b&gt;URI&lt;/b&gt;의 두 가지 형태로 URL과 URN이 있습니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;URL은 특정 시점에서 자원의 구체적인 위치를 나타내는데,&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;만약 자원의 위치가 변경되면 기존 URL은 더 이상 사용 불가능하다는 단점이 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;URN은 이러한 URL의 단점을 보완하기 위해 새롭게 정의된 표준인데,&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;URN은 자원에 대해 영속적이고 고유한 식별자를 뜻합니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1-9&lt;span style=&quot;color: #000000;&quot;&gt;. 웹 캐시에 대해서 설명해 주세요.&lt;/span&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가이드: 웹 캐시를 사용했을 때의 이점에 대해서 설명&lt;/p&gt;
&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;웹 캐시는 자주 사용되는 자원의 사본을 자동으로 보관하는 장치입니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;만약에 어떤 HTTP 요청에 대한 사본이 캐싱되어 있으면, 서버까지 요청이 가지 않고 바로 캐시에서 바로 자원을 제공받게 됩니다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;캐시를 사용하면,&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt; 반복되는 요청을 줄여줘서 서버의 부하를 줄여주고,&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;갑작스러운 트래픽을 대처하게 해 주고,&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;네트워크 병목을 줄여주고,&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;먼 거리로 인한 전송 지연을 줄여줍니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;b&gt;1-10&lt;span style=&quot;color: #000000;&quot;&gt;. 웹 프록시에 대해서 설명해 주세요.&lt;/span&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;가이드: 프록시의 역할과 사용 예시 설명, 포워드 프록시, 리버스 프록시에 대해 설명&lt;/p&gt;
&lt;hr data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;프록시 서버는 클라이언트와 서버 사이에 존재하는 중개자입니다.&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;그렇기 때문에 프록시는 클라이언트로 동작하기도 하고, 서버로 동작하기도 합니다.&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;프록시는 데이터 필터링 또는 변환하거나,&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;방화벽을 세우거나,&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;또는 캐시 서버로 동작할 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;클라이언트 앞&lt;/b&gt;에 위치하는 프록시를 포워드 프록시라고 하는데,&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;포워드 프록시를 사용해서 &lt;b&gt;익명으로 서버에 접근&lt;/b&gt;할 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;반대로 &lt;b&gt;서버 앞&lt;/b&gt;에 위치하는 프록시를 리버스 프록시라고 하는데,&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;하나의 리버스 프록시에 여러 개의 서버를 연결시켜서 로드 밸런싱을 할 수 있고,&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;서버에 직접 접근하지 못하게 할 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #555555; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>CS/[JSCODE] 컴퓨터 네트워크</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/113</guid>
      <comments>https://1two13.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%8A%A4%ED%84%B0%EB%94%94-IP-Address-1#entry113comment</comments>
      <pubDate>Sun, 7 May 2023 23:17:28 +0900</pubDate>
    </item>
    <item>
      <title>[react] 언제 memoization을 해야 할까?</title>
      <link>https://1two13.tistory.com/entry/react-%EC%96%B8%EC%A0%9C-memoization%EC%9D%84-%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;메모이제이션 개념만 보았을 때는 굉장히 효율적이고 최적화가 이루어질 것 같지만,&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;명확한 목적없이 사용하는 것은 오히려 비효율적이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그러므로, memoization 하기 전에&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 새로운 값을 만드는 것이 비용이 적게 들지&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 이전의 값을 저장해두고, 메모이제이션 함수를 호출하고, 의존성을 비교해서 가져오는 것이 비용지 적게 들지&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;판단하는 과정이 필요하다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;판단의 대한 답은 상황에 따라 다르다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;리엑트에서 메모이제이션이 필요하다고 판단할 수 있는 요인은 2가지가 있다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. &lt;b&gt;새로운 값을 만드는 연산이 복잡&lt;/b&gt;한 경우&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 함수 컴포넌트의 이전 호출과 다음 호출 간 사용하는 &lt;b&gt;값의 동일성을 보장&lt;/b&gt;하고 싶은 경우&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1번의 경우, 만약 100000개의 요소를 가진 배열이 있다고 생각하면 이 배열을 매번 생성하는 것보다 메모해서 사용하는 것이 보다 효율적이다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2번의 경우 React.memo와 연동해서 사용하기 위해서이다. props로 전달되는 객체의 동일성이 보장되지 않는다면 실제 객체의 내용은 같을 지라도 shallow compare를 통해 다른 객체라고 판단되어 매번 리렌더링이 실행될 수 있다. 이러한 상황에서는 전달되는 객체의 동일성을 보장하기 위해 메모이제이션을 사용하는 것이 보다 효율적일 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>의문점 해결하기</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/112</guid>
      <comments>https://1two13.tistory.com/entry/react-%EC%96%B8%EC%A0%9C-memoization%EC%9D%84-%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C#entry112comment</comments>
      <pubDate>Sun, 7 May 2023 16:17:41 +0900</pubDate>
    </item>
    <item>
      <title>React 렌더링과 최적화 + React.memo로 재사용여부 판단하기</title>
      <link>https://1two13.tistory.com/entry/React-%EB%A0%8C%EB%8D%94%EB%A7%81%EA%B3%BC-%EC%B5%9C%EC%A0%81%ED%99%94-Reactmemo%EB%A1%9C-%EC%9E%AC%EC%82%AC%EC%9A%A9%EC%97%AC%EB%B6%80-%ED%8C%90%EB%8B%A8%ED%95%98%EA%B8%B0</link>
      <description>&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;렌더링&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;브라우저에서 렌더링이란 DOM 요소를 계산하고 그려내는 것을 의미한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. HTML과 CSS를 통해 DOM을 만든다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 계산된 DOM은 CSSOM과 결합된다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 위치를 계산한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 브라우저에 그려진다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 브라우저에서 제공하는 DOM API를 JS를 통해 호출하고, 브라우저에 그려진 화면을 변화시킨다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;Vanila JavaScript를 이용해서 DOM에 직접 접근하고 수정하고(명령형) 최적화하는 것은 애플리케이션 규모가 커질수록 관리하기 힘들다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그래서 애플리케이션에서 보여주고 싶은 핵심 UI를 선언하기만 하면 실제로 DOM을 조작해서 UI를 그리고, 변화시키는 일은 React와 같은 라이브러리나 프레임워크가 대신해 주는 방법을 사용하게 된 것이다.(선언형)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;React에서 리렌더링 되는 시점&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;리엑트에서 리렌더링이 발생하는 시점은 state가 변했을 때이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;특정 컴포넌트의 state가 변한다면, 해당 컴포넌트와 해당 컴포넌트 하위에 있는 모든 컴포넌트들은 리렌더링을 하게 된다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;React의 렌더링 과정&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;state가 변화되고 최종적으로 브라우저상의 UI에 반영되기까지 각 컴포넌트에서는 크게 4단계를 거치게 된다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 기존 컴포넌트의 UI를 재사용할지 확인한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. 함수 컴포넌트: 컴포넌트 함수를 호출한다 / Class 컴포넌트: render 메서드를 호출한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 2의 결과를 통해서 &lt;b&gt;새로운 Virtual DOM&lt;/b&gt;을 생성한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. 이전의 Virtual DOM과 새로운 Virtual DOM을 비교해서 &lt;b&gt;실제 변경된 부분만&lt;/b&gt; DOM에 적용한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;React를 사용하는 개발자가 할 수 있는 최적화&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;결론부터 말하면 개발자는 1단계와 3단계를 최적화할 수 있다.(4단계에 해당하는 최적화는 리액트 내부적으로 수행되기 때문이다.)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. 기존 컴포넌트의 UI를 재사용할지 확인한다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;만약 리렌더링 될 컴포넌트의 UI가 이전의 UI와 동일하다고 판단되는 경우&lt;br /&gt;새롭게 컴포넌트 함수를 호출하지 않고 이전의 결괏값을 그대로 사용함으로써 최적화를 수행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. 2의 결과를 통해서 새로운 Virtual DOM을 생성한다.&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;컴포넌트 함수가 호출되면서 만들어질 Virtual DOM의 형태를 비교적 차이가 적은 형태로 만들어지도록 하는 것이다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;예를 들어, UI를 바꾸기 위해서&lt;span style=&quot;background-color: #ffffff; color: #333333;&quot;&gt; &amp;lt;div&amp;gt; 태그를 &amp;lt;span&amp;gt; 태그로 변환시키는 것보다는 &amp;lt;div className=&quot;block&quot; /&amp;gt;을 &amp;lt;div className=&quot;inline&quot;&amp;gt;으로 변환시키는 것이 VirtualDOM끼리 비교했을 때 차이가 적은 형태로 만들어지도록 하는 것이다.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그 근거는 Virtual DOM에 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;브라우저는 화면을 보여주기 위해서 HTML, CSS, JS를 다운로드하고, 이를 처리해서 화면에 픽셀 형태로 그린다. 이 과정을 CRP(Critical Rendering Path)라고 한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;1. HTML을 파싱 해서 DOM을 만든다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;2. CSS를 파싱 해서 CSSOM을 만든다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;3. DOM과 CSSOM을 결합해서 Render Tree를 만든다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;4. Render Tree와 Viewport의 width를 통해서 각 요소들의 위치와 크기를 계산한다.(layout)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;5. 지금까지 계산된 정보를 이용해 Render Tree 상의 요소들을 실제 Pixel로 그려낸다.(paint)&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이후 DOM 또는 CSSOM이 수정될 때마다 위의 과정을 반복한다. 따라서 이 과정을 최적화하는 것이 매우 중요하다. 특히 layout과 paint 과정은 많은 계산을 필요로 하기 때문에 CRP가 수행되는 횟수를 최적화하기 위해서 Virtual DOM을 사용하는 것이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;1. 기존 컴포넌트의 UI를 재사용할지 확인한다.&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;리엑트는 state가 변한 경우 해당 컴포넌트와 하위 컴포넌트를 모두 리렌더링 한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;그런데 state가 변한 컴포넌트의 경우 당연히 리렌더링 해야 하지만,&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하위 컴포넌트의 경우에는 props가 변화하지 않았다면 해당 컴포넌트 UI가 변화하지 않았을 수도 있기 때문에 리렌더링 하지 않아도 되는 경우도 있다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;이런 경우에는 굳이 새로운 컴포넌트 함수를 호출하지 않고, 이전에 저장되어 있던 결과를 그대로 사용하는 것이 효율적이다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;하지만 UI가 실질적으로 변화되었는지 안되었는지를 매번 리엑트가 렌더링 과정에서 일일이 모든 컴포넌트 트리를 순회하면서 검사하는 것 은 비효율적이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;따라서 리엑트에서는 개발자에게 이 컴포넌트가 리렌더링이 되어야 할지 아닐지에 대한 여부를 표현할 수 있는 React.memo 함수를 제공하고, 기존의 컴포넌트의 UI를 재사용할지 판단하는 방법을 사용한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;React.memo&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
&lt;pre id=&quot;code_1683440660463&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;const MyComponent = React.memo(function MyComponent(props) {
  /* render using props */
});&lt;/code&gt;&lt;/pre&gt;
&lt;pre id=&quot;code_1683440670055&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;function HOC(Component) {
  /* do something */
  return &amp;lt;Component /&amp;gt;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React.memo는 HOC(Higher Order Component)이다. HOC는 &lt;b&gt;컴포넌트를 인자로 받아서 컴포넌트를 리턴하는 컴포넌트&lt;/b&gt;이다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;React.memo로 감싸진 컴포넌트의 경우 상위 컴포넌트가 리렌더링 될 경우 무조건 리렌더링 하지 않고,&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;컴포넌트의 이전 props와 다음 렌더링 때 사용될 props를 비교해서 차이가 있을 경우에만 리렌더링 한다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;만약 차이가 없다면, 기존의 렌더링 결과를 재사용한다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;props를 비교할 때 React.memo는 기본적으로 &lt;b&gt;shallow Compare 하여&lt;/b&gt; 판단한다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;color: #333333; text-align: start;&quot; data-ke-size=&quot;size16&quot;&gt;만약 기본적인 비교 로직을 사용하지 않고 비교를 판단하는 로직을 직접 작성하고 싶다면, React.memo의 인자로 변화를 판단하는 함수를 두 번째 인자로 넣어주면 된다.&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1683440867998&quot; class=&quot;javascript&quot; data-ke-language=&quot;javascript&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;function MyComponent(props) {
  /* render using props */
}

function areEqual(prevProps, nextProps) {
  /*
  true를 return할 경우 이전 결과를 재사용
  false를 return할 경우 리렌더링을 수행
  */
}

export default React.memo(MyComponent, areEqual);&lt;/code&gt;&lt;/pre&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;위의 예제에서 이전의 props와 새로운 props가 인자로 전달되고, return 값이 true일 경우에는 이전 결과를 재사용하고, return 값이 false일 때는 리렌더링을 수행한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #333333; text-align: start;&quot;&gt;props를 비교할 때 React.memo는 기본적으로&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;b&gt;shallow Compare 하여&lt;/b&gt; 판단한다는 것은 다시 말해, props 객체 간을 비교하는 방식을 통해서 동작한다는 것이다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;props 객체는 매 렌더링마다 새롭게 생성되기 때문에 props 자체를 비교하는 것은 의미가 없다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;비교해야 하는 것은 props 객체 안의 각 property&lt;/b&gt;이다. 따라서 리엑트는 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Object.is()&lt;/a&gt; 연산자를 통해서 비교한다.&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;만약 하나라도 false가 나올 경우 props가 변경되었다고 판단하고 리렌더링을 수행한다.&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>React</category>
      <category>react</category>
      <category>최적화</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/111</guid>
      <comments>https://1two13.tistory.com/entry/React-%EB%A0%8C%EB%8D%94%EB%A7%81%EA%B3%BC-%EC%B5%9C%EC%A0%81%ED%99%94-Reactmemo%EB%A1%9C-%EC%9E%AC%EC%82%AC%EC%9A%A9%EC%97%AC%EB%B6%80-%ED%8C%90%EB%8B%A8%ED%95%98%EA%B8%B0#entry111comment</comments>
      <pubDate>Sun, 7 May 2023 15:57:23 +0900</pubDate>
    </item>
    <item>
      <title>[JS] [12, 13, 1, 2]를 sort()한 결과가 sort((a,b) =&amp;gt; a-b)한 결과랑 같을까?</title>
      <link>https://1two13.tistory.com/entry/JS-12-13-1-2%EB%A5%BC-sort%ED%95%9C-%EA%B2%B0%EA%B3%BC%EA%B0%80-sortab-a-b%ED%95%9C-%EA%B2%B0%EA%B3%BC%EB%9E%91-%EA%B0%99%EC%9D%84%EA%B9%8C</link>
      <description>&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;문제의 답은 일단 &lt;b&gt;같지 않다&lt;/b&gt; 이다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;놀랍게도 콘솔창에서 확인해보면 결과 값은 아래와 같다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;496&quot; data-origin-height=&quot;278&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/dKHcdP/btsdhzJNXvj/30dd5BqoCpZfAkphWQqUmk/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/dKHcdP/btsdhzJNXvj/30dd5BqoCpZfAkphWQqUmk/img.png&quot; data-alt=&quot;콘솔&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/dKHcdP/btsdhzJNXvj/30dd5BqoCpZfAkphWQqUmk/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdKHcdP%2FbtsdhzJNXvj%2F30dd5BqoCpZfAkphWQqUmk%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; width=&quot;425&quot; height=&quot;238&quot; data-origin-width=&quot;496&quot; data-origin-height=&quot;278&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;콘솔&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;이유는 뭘까?&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;그 이유는 우선 mdn에서 확인해 볼 수 있었다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-origin-width=&quot;1514&quot; data-origin-height=&quot;194&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/1isEO/btsdtF9VPx8/HfRBgMxZp1fydKkIn7queK/img.png&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/1isEO/btsdtF9VPx8/HfRBgMxZp1fydKkIn7queK/img.png&quot; data-alt=&quot;출처: mdn&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/1isEO/btsdtF9VPx8/HfRBgMxZp1fydKkIn7queK/img.png&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F1isEO%2FbtsdtF9VPx8%2FHfRBgMxZp1fydKkIn7queK%2Fimg.png&quot; onerror=&quot;this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';&quot; data-origin-width=&quot;1514&quot; data-origin-height=&quot;194&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;출처: mdn&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;위의 사진에서 확인할 수 있듯이, sort 메소드는 &lt;b&gt;요소를 문자열로 변환&lt;/b&gt;하고,&amp;nbsp;&lt;b&gt;변환된 문자열을 비교하여 정렬&lt;/b&gt;한다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;그래서 위의 예제에서 2가 12보다 앞에 오지만 문자열로 변환되어, 유니 코드 순서에서 1은 2보다 작기 때문에 12가 2보다 앞에 정렬되게 된 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;정리하자면, 정확한 정렬을 하기 위해서는(예외 케이스를 피하기 위해서는) sort((a,b) =&amp;gt; a-b)와 같이 작성해주는 것이 좋다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 data-ke-size=&quot;size26&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/h2&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mdn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style3&quot; /&gt;
&lt;p style=&quot;text-align: center;&quot; data-ke-size=&quot;size16&quot;&gt;질문이나&lt;span&gt; &lt;/span&gt;잘못된&lt;span&gt; &lt;/span&gt;점은&lt;span&gt; &lt;/span&gt;댓글로&lt;span&gt; &lt;/span&gt;남겨주세요&lt;span&gt; :)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <category>의문점 해결하기</category>
      <author>1two13</author>
      <guid isPermaLink="true">https://1two13.tistory.com/110</guid>
      <comments>https://1two13.tistory.com/entry/JS-12-13-1-2%EB%A5%BC-sort%ED%95%9C-%EA%B2%B0%EA%B3%BC%EA%B0%80-sortab-a-b%ED%95%9C-%EA%B2%B0%EA%B3%BC%EB%9E%91-%EA%B0%99%EC%9D%84%EA%B9%8C#entry110comment</comments>
      <pubDate>Mon, 1 May 2023 20:01:09 +0900</pubDate>
    </item>
  </channel>
</rss>